'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../../constants");
const errors_1 = require("../../descriptors/errors");
const utils_1 = require("../../utils");
const { odp, SymbolConstructorName, MNEMONICA, MNEMOSYNE, } = constants_1.constants;
const { WRONG_TYPE_DEFINITION, } = errors_1.ErrorsTypes;
const { collectConstructors } = utils_1.utils;
const Props_1 = require("../types/Props");
const CreationHandler = function (constructionAnswer) {
    return constructionAnswer;
};
const compileNewModificatorFunctionBody_1 = require("../types/compileNewModificatorFunctionBody");
const checkProto = (proto) => {
    if (!(proto instanceof Object)) {
        throw new WRONG_TYPE_DEFINITION('expect prototype to be an object');
    }
};
const getTypeChecker = (TypeName) => {
    const seeker = (instance) => {
        if (typeof instance !== 'object') {
            return false;
        }
        if (!instance.constructor) {
            return false;
        }
        if (Reflect.getPrototypeOf(instance).constructor.name === 'Promise') {
            return instance[SymbolConstructorName] === TypeName;
        }
        const constructors = collectConstructors(instance);
        return constructors[TypeName] || false;
    };
    return seeker;
};
const getTypeSplitPath = (path) => {
    const split = path
        .replace(/\n|\t| /g, '')
        .replace(/\[(\w+)\]/g, '.$1')
        .replace(/^\./, '')
        .split(/\.|\/|:/);
    return split;
};
const getExistentAsyncStack = (existentInstance) => {
    const stack = [];
    let proto = existentInstance;
    while (proto) {
        const props = (0, Props_1._getProps)(proto);
        if (!props.__stack__) {
            break;
        }
        const pstack = props
            .__stack__
            .split('\n')
            .reduce((arr, line) => {
            if (line.length) {
                arr.push(line);
            }
            return arr;
        }, []);
        proto = proto.parent();
        const protoProps = (0, Props_1._getProps)(proto);
        if (proto && protoProps && protoProps.__type__) {
            if (protoProps.__type__.isSubType) {
                stack.push(...pstack.slice(0, 1));
            }
            else {
                stack.push(...pstack);
            }
        }
        else {
            stack.push(...pstack);
            break;
        }
    }
    return stack;
};
const forbiddenNames = [MNEMONICA, MNEMOSYNE];
const checkTypeName = (name) => {
    if (!name.length) {
        throw new WRONG_TYPE_DEFINITION('TypeName must not be empty');
    }
    if (name[0] !== name[0].toUpperCase()) {
        throw new WRONG_TYPE_DEFINITION('TypeName should start with Uppercase Letter');
    }
    if (forbiddenNames.includes(name)) {
        throw new WRONG_TYPE_DEFINITION('TypeName of reserved keyword');
    }
};
const findSubTypeFromParent = (instance, subType) => {
    let subtype = null;
    const props = (0, Props_1._getProps)(instance);
    if (props.__type__.subtypes.has(subType)) {
        subtype = props.__type__.subtypes.get(subType);
        return subtype;
    }
    return findSubTypeFromParent(props.__parent__, subType);
};
const isClass = (fn) => {
    if (!(fn.prototype instanceof Object)) {
        return false;
    }
    if (fn.prototype.constructor !== fn) {
        return false;
    }
    return Reflect.getOwnPropertyDescriptor(fn, 'prototype').writable === false;
};
const makeFakeModificatorType = (TypeName, fakeModificator = function () { }) => {
    const modificatorBody = (0, compileNewModificatorFunctionBody_1.default)(TypeName);
    const modificatorType = modificatorBody(fakeModificator, CreationHandler, SymbolConstructorName);
    return modificatorType();
};
const reflectPrimitiveWrappers = (_thisArg) => {
    let thisArg = _thisArg;
    if (_thisArg === null) {
        thisArg = Object.create(null);
        odp(thisArg, Symbol.toPrimitive, {
            get() {
                return () => {
                    return _thisArg;
                };
            }
        });
    }
    if (_thisArg instanceof Number ||
        _thisArg instanceof Boolean ||
        _thisArg instanceof String) {
        odp(thisArg, Symbol.toPrimitive, {
            get() {
                return () => {
                    return _thisArg.valueOf();
                };
            }
        });
    }
    return thisArg;
};
const TypesUtils = {
    isClass,
    CreationHandler,
    checkProto,
    getTypeChecker,
    getTypeSplitPath,
    getExistentAsyncStack,
    checkTypeName,
    findSubTypeFromParent,
    makeFakeModificatorType,
    reflectPrimitiveWrappers,
};
exports.default = TypesUtils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYXBpL3V0aWxzL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7QUFFYiwrQ0FBNEM7QUFDNUMscURBQXVEO0FBQ3ZELHVDQUFvQztBQUVwQyxNQUFNLEVBQ0wsR0FBRyxFQUNILHFCQUFxQixFQUNyQixTQUFTLEVBQ1QsU0FBUyxHQUNULEdBQUcscUJBQVMsQ0FBQztBQUVkLE1BQU0sRUFDTCxxQkFBcUIsR0FDckIsR0FBRyxvQkFBVyxDQUFDO0FBRWhCLE1BQU0sRUFDTCxtQkFBbUIsRUFDbkIsR0FBRyxhQUFLLENBQUM7QUFFViwwQ0FBa0Q7QUFFbEQsTUFBTSxlQUFlLEdBQUcsVUFBMkQsa0JBQTJCO0lBYzdHLE9BQU8sa0JBQWtCLENBQUM7QUFNM0IsQ0FBQyxDQUFDO0FBRUYsa0dBQTJGO0FBRTNGLE1BQU0sVUFBVSxHQUFHLENBQUMsS0FBYyxFQUFFLEVBQUU7SUFDckMsSUFBSSxDQUFDLENBQUMsS0FBSyxZQUFZLE1BQU0sQ0FBQyxFQUFFLENBQUM7UUFDaEMsTUFBTSxJQUFJLHFCQUFxQixDQUFDLGtDQUFrQyxDQUFDLENBQUM7SUFDckUsQ0FBQztBQUNGLENBQUMsQ0FBQztBQUVGLE1BQU0sY0FBYyxHQUFHLENBQUMsUUFBZ0IsRUFBRSxFQUFFO0lBQzNDLE1BQU0sTUFBTSxHQUFZLENBQUMsUUFBZ0IsRUFBRSxFQUFFO1FBRTVDLElBQUksT0FBTyxRQUFRLEtBQUssUUFBUSxFQUFFLENBQUM7WUFDbEMsT0FBTyxLQUFLLENBQUM7UUFDZCxDQUFDO1FBR0QsSUFBSSxDQUFDLFFBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUM1QixPQUFPLEtBQUssQ0FBQztRQUNkLENBQUM7UUFHRCxJQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsV0FBVyxDQUFDLElBQUksS0FBSyxTQUFTLEVBQUUsQ0FBQztZ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eyBjb25zdGFudHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgRXJyb3JzVHlwZXMgfSBmcm9tICcuLi8uLi9kZXNjcmlwdG9ycy9lcnJvcnMnO1xuaW1wb3J0IHsgdXRpbHMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmNvbnN0IHtcblx0b2RwLFxuXHRTeW1ib2xDb25zdHJ1Y3Rvck5hbWUsXG5cdE1ORU1PTklDQSxcblx0TU5FTU9TWU5FLFxufSA9IGNvbnN0YW50cztcblxuY29uc3Qge1xuXHRXUk9OR19UWVBFX0RFRklOSVRJT04sXG59ID0gRXJyb3JzVHlwZXM7XG5cbmNvbnN0IHtcblx0Y29sbGVjdENvbnN0cnVjdG9yc1xufSA9IHV0aWxzO1xuXG5pbXBvcnQgeyBfZ2V0UHJvcHMsIFByb3BzIH0gZnJvbSAnLi4vdHlwZXMvUHJvcHMnO1xuXG5jb25zdCBDcmVhdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAodGhpczogb2JqZWN0ICYgeyBjb25zdHJ1Y3RvcjogTmV3YWJsZUZ1bmN0aW9uIH0sIGNvbnN0cnVjdGlvbkFuc3dlcjogdW5rbm93bikge1xuXHQvLyBzdGFuZGFyZCBzYXlzIDpcblx0Ly8gaWYgY29uc3RydWN0b3IgcmV0dXJucyBzb21ldGhpbmdcblx0Ly8gdGhlbiB0aGlzIGlzIGEgdG95XG5cdC8vIHdlIGhhdmUgdG8gcGxheSB3aXRoXG5cdC8vIHJlc3BlY3RpdmVseVxuXHQvLyBzbyB3ZSB3aWxsIG5vdCBmb2xsb3cgdGhlIHJ1bGVcblx0Ly8gaWYgKGNvbnN0cnVjdGlvbkFuc3dlciBpbnN0YW5jZW9mIHR5cGVzW1R5cGVOYW1lXSkge1xuXHQvLyBhbmQgaW5zdGVhZCBmb2xsb3cgdGhlIGxpbmUgYmVsb3dcblxuXHQvLyBidXQgaWYgaXQgaXMgbm90IGFuIGluc3RhY2Ugb2YgT2JqZWN0IC4uLiBzbyAuLi5cblx0Ly8gaWYgKCBjb25zdHJ1Y3Rpb25BbnN3ZXIgaW5zdGFuY2VvZiBPYmplY3QgKVxuXHQvLyBpZiAoY29uc3RydWN0aW9uQW5zd2VyIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcilcblx0Ly8gd2lsbCBmYWxsIHRoZSBvbiBwb3N0IHByb2Nlc3Npbmdcblx0cmV0dXJuIGNvbnN0cnVjdGlvbkFuc3dlcjtcblxuXHQvLyBUT0RPOiB0aGlzIGNoZWNrIHdhcyBub3QgY292ZXJlZCB3aXRoIHRlc3RzXG5cdC8vIGlmICh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuXHQvLyBcdHJldHVybiB0aGlzO1xuXHQvLyB9XG59O1xuXG5pbXBvcnQgY29tcGlsZU5ld01vZGlmaWNhdG9yRnVuY3Rpb25Cb2R5IGZyb20gJy4uL3R5cGVzL2NvbXBpbGVOZXdNb2RpZmljYXRvckZ1bmN0aW9uQm9keSc7XG5cbmNvbnN0IGNoZWNrUHJvdG8gPSAocHJvdG86IHVua25vd24pID0+IHtcblx0aWYgKCEocHJvdG8gaW5zdGFuY2VvZiBPYmplY3QpKSB7XG5cdFx0dGhyb3cgbmV3IFdST05HX1RZUEVfREVGSU5JVElPTignZXhwZWN0IHByb3RvdHlwZSB0byBiZSBhbiBvYmplY3QnKTtcblx0fVxufTtcblxuY29uc3QgZ2V0VHlwZUNoZWNrZXIgPSAoVHlwZU5hbWU6IHN0cmluZykgPT4ge1xuXHRjb25zdCBzZWVrZXI6IHVua25vd24gPSAoaW5zdGFuY2U6IG9iamVjdCkgPT4ge1xuXG5cdFx0aWYgKHR5cGVvZiBpbnN0YW5jZSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuXHRcdGlmICghaW5zdGFuY2UhLmNvbnN0cnVjdG9yKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0aWYgKFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YoaW5zdGFuY2UpLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdQcm9taXNlJykge1xuXHRcdFx0Ly8gaWYgKCBpbnN0YW5jZSBpbnN0YW5jZW9mIFByb21pc2UgKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRyZXR1cm4gaW5zdGFuY2VbIFN5bWJvbENvbnN0cnVjdG9yTmFtZSBdID09PSBUeXBlTmFtZTtcblx0XHR9XG5cblx0XHRjb25zdCBjb25zdHJ1Y3RvcnM6IHtcblx0XHRcdHN0cmluZzogbmV3ICgpID0+IHVua25vd25cblx0XHR9ID0gY29sbGVjdENvbnN0cnVjdG9ycyhpbnN0YW5jZSk7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gY29uc3RydWN0b3JzWyBUeXBlTmFtZSBdIHx8IGZhbHNlO1xuXG5cdH07XG5cdHJldHVybiBzZWVrZXI7XG59O1xuXG5jb25zdCBnZXRUeXBlU3BsaXRQYXRoID0gKHBhdGg6IHN0cmluZykgPT4ge1xuXHRjb25zdCBzcGxpdCA9IHBhdGhcblx0XHQvLyBiZWF1dGlmdWxsIG5hbWVzXG5cdFx0LnJlcGxhY2UoL1xcbnxcXHR8IC9nLCAnJylcblx0XHQucmVwbGFjZSgvXFxbKFxcdyspXFxdL2csICcuJDEnKVxuXHRcdC5yZXBsYWNlKC9eXFwuLywgJycpXG5cdFx0LnNwbGl0KC9cXC58XFwvfDovKTtcblx0cmV0dXJuIHNwbGl0O1xufTtcblxuZXhwb3J0IHR5cGUgYXN5bmNTdGFjayA9IHtcblx0X19zdGFja19fPzogc3RyaW5nXG5cdF9fdHlwZV9fOiB7XG5cdFx0aXNTdWJUeXBlOiBib29sZWFuXG5cdH1cblx0cGFyZW50OiAoKSA9PiBhc3luY1N0YWNrXG59XG5cbmNvbnN0IGdldEV4aXN0ZW50QXN5bmNTdGFjayA9IChleGlzdGVudEluc3RhbmNlOiBhc3luY1N0YWNrKTogdW5rbm93biA9PiB7XG5cblx0Y29uc3Qgc3RhY2sgPSBbXTtcblx0bGV0IHByb3RvID0gZXhpc3RlbnRJbnN0YW5jZTtcblxuXHR3aGlsZSAocHJvdG8pIHtcblxuXHRcdGNvbnN0IHByb3BzID0gX2dldFByb3BzKHByb3RvKSBhcyBQcm9wcztcblxuXHRcdGlmICghcHJvcHMuX19zdGFja19fKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRjb25zdCBwc3RhY2sgPSBwcm9wc1xuXHRcdFx0Ll9fc3RhY2tfX1xuXHRcdFx0LnNwbGl0KCdcXG4nKVxuXHRcdFx0LnJlZHVjZSgoYXJyOiBzdHJpbmdbXSwgbGluZTogc3RyaW5nKSA9PiB7XG5cdFx0XHRcdGlmIChsaW5lLmxlbmd0aCkge1xuXHRcdFx0XHRcdGFyci5wdXNoKGxpbmUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBhcnI7XG5cdFx0XHR9LCBbXSk7XG5cblx0XHRwcm90byA9IHByb3RvLnBhcmVudCgpO1xuXG5cdFx0Y29uc3QgcHJvdG9Qcm9wcyA9IF9nZXRQcm9wcyhwcm90bykgYXMgUHJvcHM7XG5cblx0XHRpZiAocHJvdG8gJiYgcHJvdG9Qcm9wcyAmJiBwcm90b1Byb3BzLl9fdHlwZV9fKSB7XG5cblx0XHRcdGlmIChwcm90b1Byb3BzLl9fdHlwZV9fLmlzU3ViVHlwZSkge1xuXHRcdFx0XHRzdGFjay5wdXNoKC4uLnBzdGFjay5zbGljZSgwLCAxKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdGFjay5wdXNoKC4uLnBzdGFjayk7XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RhY2sucHVzaCguLi5wc3RhY2spO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHN0YWNrO1xuXG59O1xuXG5jb25zdCBmb3JiaWRkZW5OYW1lcyA9IFsgTU5FTU9OSUNBLCBNTkVNT1NZTkUgXTtcblxuY29uc3QgY2hlY2tUeXBlTmFtZSA9IChuYW1lOiBzdHJpbmcpID0+IHtcblxuXHRpZiAoIW5hbWUubGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3IFdST05HX1RZUEVfREVGSU5JVElPTignVHlwZU5hbWUgbXVzdCBub3QgYmUgZW1wdHknKTtcblx0fVxuXG5cdGlmIChuYW1lWyAwIF0gIT09IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpKSB7XG5cdFx0dGhyb3cgbmV3IFdST05HX1RZUEVfREVGSU5JVElPTignVHlwZU5hbWUgc2hvdWxkIHN0YXJ0IHdpdGggVXBwZXJjYXNlIExldHRlcicpO1xuXHR9XG5cblx0aWYgKGZvcmJpZGRlbk5hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XG5cdFx0dGhyb3cgbmV3IFdST05HX1RZUEVfREVGSU5JVElPTignVHlwZU5hbWUgb2YgcmVzZXJ2ZWQga2V5d29yZCcpO1xuXHR9XG5cbn07XG5cbnR5cGUgcGFyZW50U3ViID0ge1xuXHRfX3R5cGVfXzoge1xuXHRcdHN1YnR5cGVzOiBNYXA8c3RyaW5nLCBwYXJlbnRTdWI+XG5cdH1cblx0X19wYXJlbnRfXzogcGFyZW50U3ViXG59XG5cbmNvbnN0IGZpbmRTdWJUeXBlRnJvbVBhcmVudCA9IChpbnN0YW5jZTogcGFyZW50U3ViLCBzdWJUeXBlOiBzdHJpbmcpOiBwYXJlbnRTdWIgfCB1bmRlZmluZWQgPT4ge1xuXHRsZXQgc3VidHlwZSA9IG51bGw7XG5cblx0Ly8gaWYgKCFpbnN0YW5jZS5fX3N1YnR5cGVzX18pIHtcblxuXHQvLyBpZiAoICFpbnN0YW5jZS5fX3R5cGVfXyApIHtcblx0Ly8gXHQvLyBtb2NoYSArIGNoYWkgbWFrZXMgLmluc3BlY3QgNCBTaGFwZXIgY2xhc3Ncblx0Ly8gXHQvLyBvciAuc2hvd0RpZmYgaWYgc29tZXRoaW5nIHdyb25nIHdpdGggY29uc3RydWN0b3Jcblx0Ly8gXHQvLyBkZWJ1Z2dlcjtcblx0Ly8gXHRyZXR1cm4gbnVsbDtcblx0Ly8gfVxuXG5cdGNvbnN0IHByb3BzID0gX2dldFByb3BzKGluc3RhbmNlKSBhcyBQcm9wcztcblxuXHRpZiAocHJvcHMuX190eXBlX18uc3VidHlwZXMuaGFzKHN1YlR5cGUpKSB7XG5cdFx0c3VidHlwZSA9IHByb3BzLl9fdHlwZV9fLnN1YnR5cGVzLmdldChzdWJUeXBlKTtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBzdWJ0eXBlO1xuXHR9XG5cdHJldHVybiBmaW5kU3ViVHlwZUZyb21QYXJlbnQocHJvcHMuX19wYXJlbnRfXywgc3ViVHlwZSk7XG59O1xuXG4vLyBjb25zdCBpc0NsYXNzID0gKCBmdW5jdGlvblBvaW50ZXI6IENhbGxhYmxlRnVuY3Rpb24gKSA9PiB7XG4vLyBcdGNvbnN0IHZhbHVlID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoIGZ1bmN0aW9uUG9pbnRlciApO1xuLy8gXHRyZXR1cm4gL15cXHMqY2xhc3NcXHMrLy50ZXN0KCB2YWx1ZS50cmltKCkgKTtcbi8vIH07XG5cbi8vIGFjY29yZGluZ2x5IHRvIHRoZSBnaXN0IGZyb20gaGVyZTpcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3dlbnRvdXQvZWEzYWZlOWM4MjJhNmI2ZWYzMmY5ZTRmM2U5OGIxYmFcbmNvbnN0IGlzQ2xhc3MgPSAoZm46IENhbGxhYmxlRnVuY3Rpb24pID0+IHtcblx0Ly8gbm90IG5lY2Vzc2FyeSB0byBjaGVjayBmbiBmb3IgdHlwZW9mXG5cdC8vIGJlY2F1c2Ugb2Ygb3RoZXIgY2hlY2tzIG1hZGUgYmVmb3JlXG5cdC8vIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0Ly8gXHRyZXR1cm4gZmFsc2U7XG5cdC8vIH1cblxuXHQvLyBjbGFzcyBwcm90b3R5cGUgaXMgYWx3YXlzIG9iamVjdFxuXHRpZiAoIShmbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gY2xhc3MgcHJvdG90eXBlLmNvbnN0cnVjdG9yIGNhbm5vdCBiZSByZS1kZWZpbmVkICh1c3VhbGx5KVxuXHQvLyBidXQgZm9yIGZ1bmN0aW9ucyB1c2VyIG1heSByZS1hc3NpZ24gaXQgZWFzaWx5XG5cdC8vIGp1c3QgYXNzaWduaW5nIHRoZSB3YXkgLnByb3RvdHlwZSA9IHt9XG5cdC8vIGFuZCB0aGV5IDk5LjklIGRvIHRoaXMsIGNhdXNlIG5vYm9keSBjYXJlc1xuXHQvLyBidXQgd2UgYXJlIGNoZWNraW5nIGlmIHRoaXMgaXMgY2xhc3MsIHNvIGl0IHdvcmtzIC4uLlxuXHRpZiAoZm4ucHJvdG90eXBlLmNvbnN0cnVjdG9yICE9PSBmbikge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIGFuZCB0aGUgbW9zdCB1bmtub3duIHRoaW5nIGlzIHRoYXQsXG5cdC8vIGNhdXNlIGZvciBmdW5jdGlvbnMgaXQgaXQgd3JpdGVhYmxlICkpKVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuXHRyZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZm4sICdwcm90b3R5cGUnKSEud3JpdGFibGUgPT09IGZhbHNlO1xufTtcblxuY29uc3QgbWFrZUZha2VNb2RpZmljYXRvclR5cGUgPSAoXG5cdFR5cGVOYW1lOiBzdHJpbmcsXG5cdGZha2VNb2RpZmljYXRvciA9IGZ1bmN0aW9uICgpIHsgfVxuKSA9PiB7XG5cblx0Y29uc3QgbW9kaWZpY2F0b3JCb2R5ID0gY29tcGlsZU5ld01vZGlmaWNhdG9yRnVuY3Rpb25Cb2R5KFR5cGVOYW1lKTtcblxuXHRjb25zdCBtb2RpZmljYXRvclR5cGUgPSBtb2RpZmljYXRvckJvZHkoXG5cdFx0ZmFrZU1vZGlmaWNhdG9yLFxuXHRcdENyZWF0aW9uSGFuZGxlcixcblx0XHRTeW1ib2xDb25zdHJ1Y3Rvck5hbWVcblx0KTtcblxuXHRyZXR1cm4gbW9kaWZpY2F0b3JUeXBlKCk7XG5cbn07XG5cblxuLy8gVE9ETzogLnZhbHVlT2YoKSwgLnRvU3RyaW5nKCkgPz8/XG5jb25zdCByZWZsZWN0UHJpbWl0aXZlV3JhcHBlcnMgPSAoX3RoaXNBcmc6IHVua25vd24pID0+IHtcblx0bGV0IHRoaXNBcmcgPSBfdGhpc0FyZztcblxuXHRpZiAoX3RoaXNBcmcgPT09IG51bGwpIHtcblx0XHR0aGlzQXJnID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRvZHAodGhpc0FyZywgU3ltYm9sLnRvUHJpbWl0aXZlLCB7XG5cdFx0XHRnZXQgKCkge1xuXHRcdFx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBfdGhpc0FyZztcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGlmIChcblx0XHRfdGhpc0FyZyBpbnN0YW5jZW9mIE51bWJlciB8fFxuXHRcdF90aGlzQXJnIGluc3RhbmNlb2YgQm9vbGVhbiB8fFxuXHRcdF90aGlzQXJnIGluc3RhbmNlb2YgU3RyaW5nXG5cdCkge1xuXHRcdG9kcCh0aGlzQXJnLCBTeW1ib2wudG9QcmltaXRpdmUsIHtcblx0XHRcdGdldCAoKSB7XG5cdFx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIF90aGlzQXJnLnZhbHVlT2YoKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiB0aGlzQXJnO1xufTtcblxuY29uc3QgVHlwZXNVdGlscyA9IHtcblx0aXNDbGFzcyxcblx0Q3JlYXRpb25IYW5kbGVyLFxuXHRjaGVja1Byb3RvLFxuXHRnZXRUeXBlQ2hlY2tlcixcblx0Z2V0VHlwZVNwbGl0UGF0aCxcblx0Z2V0RXhpc3RlbnRBc3luY1N0YWNrLFxuXHRjaGVja1R5cGVOYW1lLFxuXHRmaW5kU3ViVHlwZUZyb21QYXJlbnQsXG5cdG1ha2VGYWtlTW9kaWZpY2F0b3JUeXBlLFxuXHRyZWZsZWN0UHJpbWl0aXZlV3JhcHBlcnMsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBUeXBlc1V0aWxzO1xuIl19