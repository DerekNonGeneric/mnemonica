'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.lookup = exports.define = void 0;
const hop_1 = require("../../utils/hop");
const constants_1 = require("../../constants");
const { odp, SymbolParentType, SymbolConstructorName, SymbolConfig, TYPE_TITLE_PREFIX, MNEMOSYNE, } = constants_1.constants;
const errors_1 = require("../../descriptors/errors");
const Mnemosyne_1 = require("./Mnemosyne");
const { getDefaultPrototype } = Mnemosyne_1.default;
const { ALREADY_DECLARED, WRONG_TYPE_DEFINITION, TYPENAME_MUST_BE_A_STRING, HANDLER_MUST_BE_A_FUNCTION, } = errors_1.ErrorsTypes;
const hooksApi = require("../hooks");
const TypeProxy_1 = require("./TypeProxy");
const compileNewModificatorFunctionBody_1 = require("./compileNewModificatorFunctionBody");
const utils_1 = require("../utils");
const { getTypeChecker, CreationHandler, getTypeSplitPath, checkTypeName, isClass, } = utils_1.default;
const errors_2 = require("../errors");
const TypeDescriptor = function (defineOrigin, types, TypeName, constructHandler, proto, config) {
    const parentType = types[SymbolParentType] || null;
    const isSubType = parentType ? true : false;
    const collection = isSubType ? parentType.collection : types[MNEMOSYNE];
    if (types.has(TypeName)) {
        throw new ALREADY_DECLARED;
    }
    const subtypes = new Map();
    const title = `${TYPE_TITLE_PREFIX}${TypeName}`;
    config = Object.assign({}, collection[SymbolConfig], config);
    const type = Object.assign(this, {
        get constructHandler() {
            return constructHandler;
        },
        TypeName,
        proto,
        isSubType,
        subtypes,
        parentType,
        collection,
        title,
        config,
        hooks: Object.create(null)
    });
    errors_2.getStack.call(this, `Definition of [ ${TypeName} ] made at:`, [], defineOrigin);
    odp(subtypes, SymbolParentType, {
        get() {
            return type;
        }
    });
    const Uranus = isSubType ? undefined : proto;
    types.set(TypeName, new TypeProxy_1.TypeProxy(type, Uranus));
    return types.get(TypeName);
};
Object.assign(TypeDescriptor.prototype, hooksApi);
TypeDescriptor.prototype.define = function (...args) {
    return exports.define.call(exports.define, this.subtypes, ...args);
};
TypeDescriptor.prototype.lookup = function (...args) {
    return exports.lookup.call(this.subtypes, ...args);
};
odp(TypeDescriptor.prototype, Symbol.hasInstance, {
    get() {
        return getTypeChecker(this.TypeName);
    }
});
const defineUsingType = function (subtypes, constructHandlerGetter, config) {
    const type = constructHandlerGetter();
    if (typeof type !== 'function') {
        throw new HANDLER_MUST_BE_A_FUNCTION;
    }
    const TypeName = type.name;
    if (!TypeName) {
        throw new TYPENAME_MUST_BE_A_STRING;
    }
    const asClass = isClass(type);
    const makeConstructHandler = () => {
        const constructHandler = constructHandlerGetter();
        odp(constructHandler, SymbolConstructorName, {
            get() {
                return TypeName;
            }
        });
        const protoDesc = Object
            .getOwnPropertyDescriptor(constructHandler, 'prototype');
        if (protoDesc.writable) {
            constructHandler.prototype = getDefaultPrototype();
        }
        return constructHandler;
    };
    if (typeof config === 'object') {
        config = Object.assign({}, config);
    }
    else {
        config = {};
    }
    config.asClass = asClass;
    return new TypeDescriptor(this, subtypes, TypeName, makeConstructHandler, type.prototype, config);
};
const defineUsingFunction = function (subtypes, TypeName, constructHandler = function () { }, config = {}) {
    if (typeof constructHandler !== 'function') {
        throw new HANDLER_MUST_BE_A_FUNCTION;
    }
    const asClass = isClass(constructHandler);
    const modificatorBody = (0, compileNewModificatorFunctionBody_1.default)(TypeName, asClass);
    const makeConstructHandler = modificatorBody(constructHandler, CreationHandler, SymbolConstructorName);
    if (config instanceof Function) {
        config = {
            ModificationConstructor: config
        };
    }
    if (typeof config !== 'object') {
        config = {};
    }
    config.asClass = asClass;
    const proto = ((0, hop_1.hop)(constructHandler, 'prototype') &&
        (typeof constructHandler.prototype === 'object')) ? constructHandler.prototype : getDefaultPrototype();
    return new TypeDescriptor(this, subtypes, TypeName, makeConstructHandler, proto, config);
};
const define = function (subtypes, TypeOrTypeName, constructHandlerOrConfig, config) {
    if (typeof TypeOrTypeName === 'function') {
        if (TypeOrTypeName.name) {
            return exports.define.call(this, subtypes, TypeOrTypeName.name, TypeOrTypeName, config);
        }
        else {
            return defineUsingType.call(this, subtypes, TypeOrTypeName, constructHandlerOrConfig);
        }
    }
    if (typeof TypeOrTypeName === 'string') {
        checkTypeName(TypeOrTypeName);
        const split = getTypeSplitPath(TypeOrTypeName);
        const Type = exports.lookup.call(subtypes, split[0]);
        if (!Type) {
            if (split.length === 1) {
                return defineUsingFunction.call(this, subtypes, TypeOrTypeName, constructHandlerOrConfig, config);
            }
            throw new WRONG_TYPE_DEFINITION(`${split[0]} definition is not yet exists`);
        }
        const TypeName = split.slice(1).join('.');
        if (split.length > 1) {
            return exports.define.call(this, Type.subtypes, TypeName, constructHandlerOrConfig, config);
        }
        return exports.define.call(this, Type.subtypes, constructHandlerOrConfig, config);
    }
    throw new WRONG_TYPE_DEFINITION('definition is not provided');
};
exports.define = define;
const lookup = function (TypeNestedPath) {
    if (typeof TypeNestedPath !== 'string') {
        throw new WRONG_TYPE_DEFINITION('arg : type nested path must be a string');
    }
    if (!TypeNestedPath.length) {
        throw new WRONG_TYPE_DEFINITION('arg : type nested path has no path');
    }
    const split = getTypeSplitPath(TypeNestedPath);
    const [name] = split;
    const type = this.get(name);
    if (split.length === 1) {
        return type;
    }
    const NextNestedPath = split.slice(1).join('.');
    return exports.lookup.call(type.subtypes, NextNestedPath);
};
exports.lookup = lookup;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYXBpL3R5cGVzL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7O0FBSWIseUNBQXNDO0FBRXRDLCtDQUE0QztBQUM1QyxNQUFNLEVBQ0wsR0FBRyxFQUNILGdCQUFnQixFQUNoQixxQkFBcUIsRUFDckIsWUFBWSxFQUVaLGlCQUFpQixFQUNqQixTQUFTLEdBRVQsR0FBRyxxQkFBUyxDQUFDO0FBRWQscURBQXVEO0FBR3ZELDJDQUFxQztBQUNyQyxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsR0FBRyxtQkFBVSxDQUFDO0FBRTNDLE1BQU0sRUFDTCxnQkFBZ0IsRUFDaEIscUJBQXFCLEVBQ3JCLHlCQUF5QixFQUN6QiwwQkFBMEIsR0FDMUIsR0FBRyxvQkFBVyxDQUFDO0FBS2hCLHFDQUFxQztBQUNyQywyQ0FBd0M7QUFFeEMsMkZBQW9GO0FBRXBGLG9DQUFrQztBQUNsQyxNQUFNLEVBQ0wsY0FBYyxFQUNkLGVBQWUsRUFDZixnQkFBZ0IsRUFDaEIsYUFBYSxFQUNiLE9BQU8sR0FDUCxHQUFHLGVBQVUsQ0FBQztBQUVmLHNDQUFxQztBQUVyQyxNQUFNLGNBQWMsR0FBRyxVQUV0QixZQUE4QixFQUM5QixLQUFVLEVBQ1YsUUFBZ0IsRUFDaEIsZ0JBQWtDLEVBQ2xDLEtBQXFDLEVBQ3JDLE1BQXNDO0lBS3RDLE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBRSxnQkFBZ0IsQ0FBRSxJQUFJLElBQUksQ0FBQztJQUVyRCxNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBRTVDLE1BQU0sVUFBVSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFFLFNBQVMsQ0FBRSxDQUFDO0lBRTFFLElBQUssS0FBSyxDQUFDLEdB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QU8sY0FBYyxLQUFLLFFBQVEsRUFBRyxDQUFDO1FBQzFDLE1BQU0sSUFBSSxxQkFBcUIsQ0FBRSx5Q0FBeUMsQ0FBRSxDQUFDO0lBQzlFLENBQUM7SUFFRCxJQUFLLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRyxDQUFDO1FBQzlCLE1BQU0sSUFBSSxxQkFBcUIsQ0FBRSxvQ0FBb0MsQ0FBRSxDQUFDO0lBQ3pFLENBQUM7SUFFRCxNQUFNLEtBQUssR0FBRyxnQkFBZ0IsQ0FBRSxjQUFjLENBQUUsQ0FBQztJQUVqRCxNQUFNLENBQUUsSUFBSSxDQUFFLEdBQUcsS0FBSyxDQUFDO0lBQ3ZCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUUsSUFBSSxDQUFFLENBQUM7SUFDOUIsSUFBSyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRyxDQUFDO1FBQzFCLE9BQU8sSUFBSSxDQUFDO0lBQ2IsQ0FBQztJQUVELE1BQU0sY0FBYyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUUsQ0FBQyxDQUFFLENBQUMsSUFBSSxDQUFFLEdBQUcsQ0FBRSxDQUFDO0lBQ3BELE9BQU8sY0FBTSxDQUFDLElBQUksQ0FBRSxJQUFJLENBQUMsUUFBUSxFQUFFLGNBQWMsQ0FBRSxDQUFDO0FBRXJELENBQUMsQ0FBQztBQXJCVyxRQUFBLE1BQU0sVUFxQmpCIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBDb25zdHJ1Y3RvckZ1bmN0aW9uLCBUeXBlRGVzY3JpcHRvckluc3RhbmNlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBob3AgfSBmcm9tICcuLi8uLi91dGlscy9ob3AnO1xuXG5pbXBvcnQgeyBjb25zdGFudHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuY29uc3Qge1xuXHRvZHAsXG5cdFN5bWJvbFBhcmVudFR5cGUsXG5cdFN5bWJvbENvbnN0cnVjdG9yTmFtZSxcblx0U3ltYm9sQ29uZmlnLFxuXG5cdFRZUEVfVElUTEVfUFJFRklYLFxuXHRNTkVNT1NZTkUsXG5cbn0gPSBjb25zdGFudHM7XG5cbmltcG9ydCB7IEVycm9yc1R5cGVzIH0gZnJvbSAnLi4vLi4vZGVzY3JpcHRvcnMvZXJyb3JzJztcbi8vIGltcG9ydCB7IGRlc2NyaXB0b3JzIH0gZnJvbSAnLi4vLi4vZGVzY3JpcHRvcnMnO1xuXG5pbXBvcnQgbW5lbW9zeW5lcyBmcm9tICcuL01uZW1vc3luZSc7XG5jb25zdCB7IGdldERlZmF1bHRQcm90b3R5cGUgfSA9IG1uZW1vc3luZXM7XG5cbmNvbnN0IHtcblx0QUxSRUFEWV9ERUNMQVJFRCxcblx0V1JPTkdfVFlQRV9ERUZJTklUSU9OLFxuXHRUWVBFTkFNRV9NVVNUX0JFX0FfU1RSSU5HLFxuXHRIQU5ETEVSX01VU1RfQkVfQV9GVU5DVElPTixcbn0gPSBFcnJvcnNUeXBlcztcblxuLy8gaW52b2tlSG9va1xuLy8gcmVnaXN0ZXJIb29rXG4vLyByZWdpc3RlckZsb3dDaGVja2VyXG5pbXBvcnQgKiBhcyBob29rc0FwaSBmcm9tICcuLi9ob29rcyc7XG5pbXBvcnQgeyBUeXBlUHJveHkgfSBmcm9tICcuL1R5cGVQcm94eSc7XG5cbmltcG9ydCBjb21waWxlTmV3TW9kaWZpY2F0b3JGdW5jdGlvbkJvZHkgZnJvbSAnLi9jb21waWxlTmV3TW9kaWZpY2F0b3JGdW5jdGlvbkJvZHknO1xuXG5pbXBvcnQgVHlwZXNVdGlscyBmcm9tICcuLi91dGlscyc7XG5jb25zdCB7XG5cdGdldFR5cGVDaGVja2VyLFxuXHRDcmVhdGlvbkhhbmRsZXIsXG5cdGdldFR5cGVTcGxpdFBhdGgsXG5cdGNoZWNrVHlwZU5hbWUsXG5cdGlzQ2xhc3MsXG59ID0gVHlwZXNVdGlscztcblxuaW1wb3J0IHsgZ2V0U3RhY2sgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5jb25zdCBUeXBlRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChcblx0dGhpczogYW55LFxuXHRkZWZpbmVPcmlnaW46IENhbGxhYmxlRnVuY3Rpb24sXG5cdHR5cGVzOiBhbnksXG5cdFR5cGVOYW1lOiBzdHJpbmcsXG5cdGNvbnN0cnVjdEhhbmRsZXI6IENhbGxhYmxlRnVuY3Rpb24sXG5cdHByb3RvOiB7IFsgaW5kZXg6IHN0cmluZyBdOiB1bmtub3duIH0sXG5cdGNvbmZpZzogeyBbIGluZGV4OiBzdHJpbmcgXTogdW5rbm93biB9LFxuKSB7XG5cblx0Ly8gaGVyZSBcInR5cGVzXCIgcmVmZXJzIHRvIHN1YnR5cGVzIG9mIHR5cGUgb3IgY29sbGVjdGlvbiBvYmplY3Qge31cblxuXHRjb25zdCBwYXJlbnRUeXBlID0gdHlwZXNbIFN5bWJvbFBhcmVudFR5cGUgXSB8fCBudWxsO1xuXG5cdGNvbnN0IGlzU3ViVHlwZSA9IHBhcmVudFR5cGUgPyB0cnVlIDogZmFsc2U7XG5cblx0Y29uc3QgY29sbGVjdGlvbiA9IGlzU3ViVHlwZSA/IHBhcmVudFR5cGUuY29sbGVjdGlvbiA6IHR5cGVzWyBNTkVNT1NZTkUgXTtcblxuXHRpZiAoIHR5cGVzLmhhcyggVHlwZU5hbWUgKSApIHtcblx0XHR0aHJvdyBuZXcgQUxSRUFEWV9ERUNMQVJFRDtcblx0fVxuXG5cdC8vIGNvbnN0IHN1YnR5cGVzID0gZGVzY3JpcHRvcnMuY3JlYXRlVHlwZXNDb2xsZWN0aW9uKCk7XG5cdGNvbnN0IHN1YnR5cGVzID0gbmV3IE1hcCgpO1xuXG5cdGNvbnN0IHRpdGxlID0gYCR7VFlQRV9USVRMRV9QUkVGSVh9JHtUeXBlTmFtZX1gO1xuXG5cdGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oIHt9LCBjb2xsZWN0aW9uWyBTeW1ib2xDb25maWcgXSwgY29uZmlnICk7XG5cblx0Y29uc3QgdHlwZSA9IE9iamVjdC5hc3NpZ24oIHRoaXMsIHtcblxuXHRcdGdldCBjb25zdHJ1Y3RIYW5kbGVyICgpIHtcblx0XHRcdHJldHVybiBjb25zdHJ1Y3RIYW5kbGVyO1xuXHRcdH0sXG5cblxuXHRcdFR5cGVOYW1lLFxuXHRcdHByb3RvLFxuXG5cdFx0aXNTdWJUeXBlLFxuXHRcdHN1YnR5cGVzLFxuXHRcdHBhcmVudFR5cGUsXG5cblx0XHRjb2xsZWN0aW9uLFxuXG5cdFx0dGl0bGUsXG5cblx0XHRjb25maWcsXG5cblx0XHRob29rcyA6IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXG5cdH0gKTtcblxuXHRnZXRTdGFjay5jYWxsKCB0aGlzLCBgRGVmaW5pdGlvbiBvZiBbICR7VHlwZU5hbWV9IF0gbWFkZSBhdDpgLCBbXSwgZGVmaW5lT3JpZ2luICk7XG5cblx0b2RwKCBzdWJ0eXBlcywgU3ltYm9sUGFyZW50VHlwZSwge1xuXHRcdGdldCAoKSB7XG5cdFx0XHRyZXR1cm4gdHlwZTtcblx0XHR9XG5cdH0gKTtcblxuXHQvLyBjb25zdCBVcmFudXMgPSBpc1N1YlR5cGUgPyBPYmplY3QuY3JlYXRlKG51bGwpIDogcHJvdG87XG5cdGNvbnN0IFVyYW51cyA9IGlzU3ViVHlwZSA/IHVuZGVmaW5lZCA6IHByb3RvO1xuXHR0eXBlcy5zZXQoIFR5cGVOYW1lLCBuZXcgVHlwZVByb3h5KCB0eXBlLCBVcmFudXMgKSApO1xuXHRcblx0Ly8gdHlwZXMuc2V0KCBUeXBlTmFtZSwgbmV3IFR5cGVQcm94eSggdHlwZSApICk7XG5cblx0cmV0dXJuIHR5cGVzLmdldCggVHlwZU5hbWUgKTtcblxufSBhcyBDb25zdHJ1Y3RvckZ1bmN0aW9uPFR5cGVEZXNjcmlwdG9ySW5zdGFuY2U+O1xuXG5PYmplY3QuYXNzaWduKCBUeXBlRGVzY3JpcHRvci5wcm90b3R5cGUsIGhvb2tzQXBpICk7XG5cblR5cGVEZXNjcmlwdG9yLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbiAoIC4uLmFyZ3M6IGFueVtdICkge1xuXHRyZXR1cm4gZGVmaW5lLmNhbGwoIGRlZmluZSwgdGhpcy5zdWJ0eXBlcywgLi4uYXJncyApO1xufTtcblxuVHlwZURlc2NyaXB0b3IucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uICggLi4uYXJnczogYW55W10gKSB7XG5cdHJldHVybiBsb29rdXAuY2FsbCggdGhpcy5zdWJ0eXBlcywgLi4uYXJncyApO1xufTtcblxub2RwKCBUeXBlRGVzY3JpcHRvci5wcm90b3R5cGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuXHRnZXQgKCkge1xuXHRcdHJldHVybiBnZXRUeXBlQ2hlY2tlciggdGhpcy5UeXBlTmFtZSApO1xuXHR9XG59ICk7XG5cbi8qXG5oZXJlIHdlIHVzZSBmdW5jdGlvbiB0byByZXRyZWl2ZSBhIGNvbnRydWN0b3JcbmFuZCBjb25zdHJ1Y3RIYW5kbGVyR2V0dGVyIGlzIHRoYXQgZnVuY3Rpb25cbiovXG5jb25zdCBkZWZpbmVVc2luZ1R5cGUgPSBmdW5jdGlvbiAoIHRoaXM6IGFueSwgc3VidHlwZXM6IGFueSwgY29uc3RydWN0SGFuZGxlckdldHRlcjogQ2FsbGFibGVGdW5jdGlvbiwgY29uZmlnOiBhbnkgKSB7XG5cdC8vIHdlIG5lZWQgdGhpcyB0byBleHRyYWN0IFR5cGVOYW1lXG5cdGNvbnN0IHR5cGUgPSBjb25zdHJ1Y3RIYW5kbGVyR2V0dGVyKCk7XG5cblx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHR0aHJvdyBuZXcgSEFORExFUl9NVVNUX0JFX0FfRlVOQ1RJT047XG5cdH1cblxuXHRjb25zdCBUeXBlTmFtZSA9IHR5cGUubmFtZTtcblxuXHRpZiAoICFUeXBlTmFtZSApIHtcblx0XHR0aHJvdyBuZXcgVFlQRU5BTUVfTVVTVF9CRV9BX1NUUklORztcblx0fVxuXG5cdGNvbnN0IGFzQ2xhc3MgPSBpc0NsYXNzKCB0eXBlICk7XG5cblx0Y29uc3QgbWFrZUNvbnN0cnVjdEhhbmRsZXIgPSAoKSA9PiB7XG5cdFx0Y29uc3QgY29uc3RydWN0SGFuZGxlciA9IGNvbnN0cnVjdEhhbmRsZXJHZXR0ZXIoKTtcblx0XHQvLyBjb25zdHJ1Y3RIYW5kbGVyW1N5bWJvbENvbnN0cnVjdG9yTmFtZV0gPSBUeXBlTmFtZTtcblx0XHRvZHAoIGNvbnN0cnVjdEhhbmRsZXIsIFN5bWJvbENvbnN0cnVjdG9yTmFtZSwge1xuXHRcdFx0Z2V0ICgpIHtcblx0XHRcdFx0cmV0dXJuIFR5cGVOYW1lO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRcblx0XHQvLyB0aGlzIHdhcyBjaGVja2luZyBmb3IgY2xhc3MgLyBmdW5jdGlvblxuXHRcdC8vIGZ1bmN0aW9ucyBoYXMgLndyaXRhYmxlIHByb3RvdHlwZVxuXHRcdC8vIGFuZCBjbGFzc2VzIGFyZSBoYXMgbm90XG5cdFx0Y29uc3QgcHJvdG9EZXNjOiBhbnkgPSBPYmplY3Rcblx0XHRcdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIGNvbnN0cnVjdEhhbmRsZXIsICdwcm90b3R5cGUnICk7XG5cdFx0aWYgKCBwcm90b0Rlc2Mud3JpdGFibGUgKSB7XG5cdFx0XHQvLyBjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSA9IHt9O1xuXHRcdFx0Y29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUgPSBnZXREZWZhdWx0UHJvdG90eXBlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFRPRE86XG5cdFx0Ly8gc2lkZS13YXksIG5vbiBjb3JyZWN0bHkgd29ya2luZ1xuXHRcdC8vIHdpdGggY3JlYXRlSW5zdGFuY2VNb2RpZmljYXRvciBmb3IgbGluZVxuXHRcdC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1vZGlmaWNhdG9yVHlwZS5wcm90b3R5cGUsIHByb3BzKTtcblx0XHQvLyBmb3IgcmVwZWF0YWJsZSBpbnN0YW5jZSBjcmVhdGlvbnNcblx0XHQvLyDihpPihpPihpMg4oaT4oaT4oaTIOKGk+KGk+KGk1xuXHRcdC8vIGVsc2Uge1xuXHRcdC8vIFx0Ly8gc28gbGV0IHVzZSBPYmplY3Quc2V0UHJvdG90eXBlT2YgaW5zdGVhZFxuXHRcdC8vIFx0Ly8gT2JqZWN0LnNldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSksIGdldERlZmF1bHRQcm90b3R5cGUoKSk7XG5cdFx0Ly8gXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoY29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUsIGdldERlZmF1bHRQcm90b3R5cGUoKSk7XG5cdFx0Ly8gfVxuXG5cdFx0cmV0dXJuIGNvbnN0cnVjdEhhbmRsZXI7XG5cdH07XG5cblx0aWYgKCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyApIHtcblx0XHRjb25maWcgPSBPYmplY3QuYXNzaWduKCB7fSwgY29uZmlnICk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uZmlnID0ge307XG5cdH1cblxuXHRjb25maWcuYXNDbGFzcyA9IGFzQ2xhc3M7XG5cblx0cmV0dXJuIG5ldyBUeXBlRGVzY3JpcHRvcihcblx0XHR0aGlzLFxuXHRcdHN1YnR5cGVzLFxuXHRcdFR5cGVOYW1lLFxuXHRcdG1ha2VDb25zdHJ1Y3RIYW5kbGVyLFxuXHRcdHR5cGUucHJvdG90eXBlLFxuXHRcdGNvbmZpZ1xuXHQpO1xufTtcblxuXG4vKlxuaGVyZSB3ZSBkaXJlY3RseSBwYXNzaW5nIGNvbnN0cnVjdEhhbmRsZXJcbmFzIGEgY29uc3RydWN0b3IgZm9yIGluc3RhbmNlcyBjcmVhdGlvbnNcbiovXG5jb25zdCBkZWZpbmVVc2luZ0Z1bmN0aW9uID0gZnVuY3Rpb24gKFxuXHR0aGlzOiBhbnksXG5cdHN1YnR5cGVzOiBhbnksXG5cdFR5cGVOYW1lOiBzdHJpbmcsXG5cdGNvbnN0cnVjdEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7IH0sXG5cdGNvbmZpZzogYW55ID0ge31cbikge1xuXG5cdGlmICggdHlwZW9mIGNvbnN0cnVjdEhhbmRsZXIgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0dGhyb3cgbmV3IEhBTkRMRVJfTVVTVF9CRV9BX0ZVTkNUSU9OO1xuXHR9XG5cblx0Y29uc3QgYXNDbGFzcyA9IGlzQ2xhc3MoIGNvbnN0cnVjdEhhbmRsZXIgKTtcblx0Y29uc3QgbW9kaWZpY2F0b3JCb2R5ID0gY29tcGlsZU5ld01vZGlmaWNhdG9yRnVuY3Rpb25Cb2R5KCBUeXBlTmFtZSwgYXNDbGFzcyApO1xuXG5cdGNvbnN0IG1ha2VDb25zdHJ1Y3RIYW5kbGVyID0gbW9kaWZpY2F0b3JCb2R5KFxuXHRcdGNvbnN0cnVjdEhhbmRsZXIsXG5cdFx0Q3JlYXRpb25IYW5kbGVyLFxuXHRcdFN5bWJvbENvbnN0cnVjdG9yTmFtZVxuXHQpO1xuXG5cdGlmICggY29uZmlnIGluc3RhbmNlb2YgRnVuY3Rpb24gKSB7XG5cdFx0Y29uZmlnID0ge1xuXHRcdFx0TW9kaWZpY2F0aW9uQ29uc3RydWN0b3IgOiBjb25maWdcblx0XHR9O1xuXHR9XG5cblx0aWYgKCB0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0JyApIHtcblx0XHRjb25maWcgPSB7fTtcblx0fVxuXG5cblx0Y29uZmlnLmFzQ2xhc3MgPSBhc0NsYXNzO1xuXG5cdGNvbnN0IHByb3RvID0gKFxuXHRcdGhvcCggY29uc3RydWN0SGFuZGxlciwgJ3Byb3RvdHlwZScgKSAmJlxuXHRcdC8vIHVzaW5nIOKGk+KGk+KGkyBjYXVzZSBmb3IgcHJveHkgaW4gY2hhaW4gaXMgaW5zdGFuY2VvZiBmYWlsc1xuXHRcdC8vIGFuZCBhbHNvIGZhaWxzIGZvciBqdXN0IE9iamVjdC5jcmVhdGUobnVsbClcblx0XHQoIHR5cGVvZiBjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSA9PT0gJ29iamVjdCcgKVxuXHQvLyApID8gY29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUgOiBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHQpID8gY29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUgOiBnZXREZWZhdWx0UHJvdG90eXBlKCk7XG5cdFxuXHQvLyBsZXQgcHJvdG8gPSB7fTtcblx0Ly8gaWYgKCBob3AoIGNvbnN0cnVjdEhhbmRsZXIsICdwcm90b3R5cGUnICkgJiYgKCBjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIE9iamVjdCApICkge1xuXHQvLyBcdHByb3RvID0gT2JqZWN0LmFzc2lnbigge30sIGNvbnN0cnVjdEhhbmRsZXIucHJvdG90eXBlICk7XG5cdC8vIFx0T2JqZWN0LnNldFByb3RvdHlwZU9mKCBwcm90bywgY29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUgKTtcblx0Ly8gfVxuXG5cdHJldHVybiBuZXcgVHlwZURlc2NyaXB0b3IoXG5cdFx0dGhpcyxcblx0XHRzdWJ0eXBlcyxcblx0XHRUeXBlTmFtZSxcblx0XHRtYWtlQ29uc3RydWN0SGFuZGxlcixcblx0XHQvLyBwcm90byBwcm9wIGZvciBUeXBlRGVzY3JpcHRvclxuXHRcdHByb3RvLFxuXHRcdGNvbmZpZ1xuXHQpO1xuXG59O1xuXG5cbmV4cG9ydCBjb25zdCBkZWZpbmU6IGFueSA9IGZ1bmN0aW9uICggdGhpczogYW55LCBzdWJ0eXBlczogYW55LCBUeXBlT3JUeXBlTmFtZTogc3RyaW5nIHwgYW55LCBjb25zdHJ1Y3RIYW5kbGVyT3JDb25maWc6IGFueSwgY29uZmlnOiBvYmplY3QgKSB7XG5cblx0aWYgKCB0eXBlb2YgVHlwZU9yVHlwZU5hbWUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0Ly8gVE9ETzogaWYgKCBob3AoIFR5cGVPclR5cGVOYW1lLCAnbmFtZScgKSApIHtcblx0XHQvLyBUT0RPOiBpZiAoIGhvcCggVHlwZU9yVHlwZU5hbWUuY29uc3RydWN0b3IsICduYW1lJyApICkge1xuXHRcdGlmICggVHlwZU9yVHlwZU5hbWUubmFtZSApIHtcblx0XHRcdHJldHVybiBkZWZpbmUuY2FsbCggdGhpcywgc3VidHlwZXMsIFR5cGVPclR5cGVOYW1lLm5hbWUsIFR5cGVPclR5cGVOYW1lLCBjb25maWcgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGRlZmluZVVzaW5nVHlwZS5jYWxsKCB0aGlzLCBzdWJ0eXBlcywgVHlwZU9yVHlwZU5hbWUsIGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZyApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggdHlwZW9mIFR5cGVPclR5cGVOYW1lID09PSAnc3RyaW5nJyApIHtcblxuXHRcdGNoZWNrVHlwZU5hbWUoIFR5cGVPclR5cGVOYW1lICk7XG5cblx0XHRjb25zdCBzcGxpdCA9IGdldFR5cGVTcGxpdFBhdGgoIFR5cGVPclR5cGVOYW1lICk7XG5cblx0XHRjb25zdCBUeXBlID0gbG9va3VwLmNhbGwoIHN1YnR5cGVzLCBzcGxpdFsgMCBdICk7XG5cblx0XHRpZiAoICFUeXBlICkge1xuXG5cdFx0XHRpZiAoIHNwbGl0Lmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGRlZmluZVVzaW5nRnVuY3Rpb24uY2FsbCggdGhpcywgc3VidHlwZXMsIFR5cGVPclR5cGVOYW1lLCBjb25zdHJ1Y3RIYW5kbGVyT3JDb25maWcsIGNvbmZpZyApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyBuZXcgV1JPTkdfVFlQRV9ERUZJTklUSU9OKCBgJHtzcGxpdFsgMCBdfSBkZWZpbml0aW9uIGlzIG5vdCB5ZXQgZXhpc3RzYCApO1xuXHRcdH1cblxuXHRcdGNvbnN0IFR5cGVOYW1lID0gc3BsaXQuc2xpY2UoIDEgKS5qb2luKCAnLicgKTtcblxuXHRcdGlmICggc3BsaXQubGVuZ3RoID4gMSApIHtcblx0XHRcdHJldHVybiBkZWZpbmUuY2FsbCggdGhpcywgVHlwZS5zdWJ0eXBlcywgVHlwZU5hbWUsIGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZywgY29uZmlnICk7XG5cdFx0fVxuXG5cdFx0Ly8gc28sIGhlcmUgd2UgZ28gd2l0aFxuXHRcdC8vIGRlZmluZVVzaW5nVHlwZS5jYWxsXG5cdFx0Ly8gZnJvbSB0aGUgbmV4dCBzdGVwXG5cdFx0cmV0dXJuIGRlZmluZS5jYWxsKCB0aGlzLCBUeXBlLnN1YnR5cGVzLCBjb25zdHJ1Y3RIYW5kbGVyT3JDb25maWcsIGNvbmZpZyApO1xuXG5cdH1cblxuXHR0aHJvdyBuZXcgV1JPTkdfVFlQRV9ERUZJTklUSU9OKCAnZGVmaW5pdGlvbiBpcyBub3QgcHJvdmlkZWQnICk7XG5cbn07XG5cbmV4cG9ydCBjb25zdCBsb29rdXA6IGFueSA9IGZ1bmN0aW9uICggdGhpczogYW55LCBUeXBlTmVzdGVkUGF0aDogc3RyaW5nICkge1xuXG5cdGlmICggdHlwZW9mIFR5cGVOZXN0ZWRQYXRoICE9PSAnc3RyaW5nJyApIHtcblx0XHR0aHJvdyBuZXcgV1JPTkdfVFlQRV9ERUZJTklUSU9OKCAnYXJnIDogdHlwZSBuZXN0ZWQgcGF0aCBtdXN0IGJlIGEgc3RyaW5nJyApO1xuXHR9XG5cblx0aWYgKCAhVHlwZU5lc3RlZFBhdGgubGVuZ3RoICkge1xuXHRcdHRocm93IG5ldyBXUk9OR19UWVBFX0RFRklOSVRJT04oICdhcmcgOiB0eXBlIG5lc3RlZCBwYXRoIGhhcyBubyBwYXRoJyApO1xuXHR9XG5cblx0Y29uc3Qgc3BsaXQgPSBnZXRUeXBlU3BsaXRQYXRoKCBUeXBlTmVzdGVkUGF0aCApO1xuXG5cdGNvbnN0IFsgbmFtZSBdID0gc3BsaXQ7XG5cdGNvbnN0IHR5cGUgPSB0aGlzLmdldCggbmFtZSApO1xuXHRpZiAoIHNwbGl0Lmxlbmd0aCA9PT0gMSApIHtcblx0XHRyZXR1cm4gdHlwZTtcblx0fVxuXG5cdGNvbnN0IE5leHROZXN0ZWRQYXRoID0gc3BsaXQuc2xpY2UoIDEgKS5qb2luKCAnLicgKTtcblx0cmV0dXJuIGxvb2t1cC5jYWxsKCB0eXBlLnN1YnR5cGVzLCBOZXh0TmVzdGVkUGF0aCApO1xuXG59O1xuXG5cblxuIl19