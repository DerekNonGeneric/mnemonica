'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.lookup = exports.define = void 0;
const hop_1 = require("../../utils/hop");
const constants_1 = require("../../constants");
const { odp, SymbolParentType, SymbolConstructorName, SymbolConfig, TYPE_TITLE_PREFIX, MNEMOSYNE, } = constants_1.constants;
const errors_1 = require("../../descriptors/errors");
const { ALREADY_DECLARED, WRONG_TYPE_DEFINITION, TYPENAME_MUST_BE_A_STRING, HANDLER_MUST_BE_A_FUNCTION, } = errors_1.ErrorsTypes;
const hooksApi = require("../hooks");
const TypeProxy_1 = require("./TypeProxy");
const compileNewModificatorFunctionBody_1 = require("./compileNewModificatorFunctionBody");
const utils_1 = require("../utils");
const { checkProto, getTypeChecker, CreationHandler, getTypeSplitPath, checkTypeName, isClass, } = utils_1.default;
const errors_2 = require("../errors");
const TypeDescriptor = function (defineOrigin, types, TypeName, constructHandler, proto, config) {
    const parentType = types[SymbolParentType] || null;
    const isSubType = parentType ? true : false;
    const collection = isSubType ? parentType.collection : types[MNEMOSYNE];
    if (types.has(TypeName)) {
        throw new ALREADY_DECLARED;
    }
    checkProto(proto);
    const subtypes = new Map();
    const title = `${TYPE_TITLE_PREFIX}${TypeName}`;
    config = Object.assign({}, collection[SymbolConfig], config);
    const type = Object.assign(this, {
        get constructHandler() {
            return constructHandler;
        },
        TypeName,
        proto,
        isSubType,
        subtypes,
        parentType,
        collection,
        title,
        config,
        hooks: Object.create(null)
    });
    errors_2.getStack.call(this, `Definition of [ ${TypeName} ] made at:`, [], defineOrigin);
    odp(subtypes, SymbolParentType, {
        get() {
            return type;
        }
    });
    types.set(TypeName, new TypeProxy_1.TypeProxy(type));
    return types.get(TypeName);
};
Object.assign(TypeDescriptor.prototype, hooksApi);
TypeDescriptor.prototype.define = function (...args) {
    return exports.define.call(exports.define, this.subtypes, ...args);
};
TypeDescriptor.prototype.lookup = function (...args) {
    return exports.lookup.call(this.subtypes, ...args);
};
odp(TypeDescriptor.prototype, Symbol.hasInstance, {
    get() {
        return getTypeChecker(this.TypeName);
    }
});
const defineUsingType = function (subtypes, constructHandlerGetter, config) {
    const type = constructHandlerGetter();
    if (typeof type !== 'function') {
        throw new HANDLER_MUST_BE_A_FUNCTION;
    }
    const TypeName = type.name;
    if (!TypeName) {
        throw new TYPENAME_MUST_BE_A_STRING;
    }
    const asClass = isClass(type);
    const makeConstructHandler = () => {
        const constructHandler = constructHandlerGetter();
        odp(constructHandler, SymbolConstructorName, {
            get() {
                return TypeName;
            }
        });
        const protoDesc = Object
            .getOwnPropertyDescriptor(constructHandler, 'prototype');
        if (protoDesc.writable) {
            constructHandler.prototype = {};
        }
        return constructHandler;
    };
    if (typeof config === 'object') {
        config = Object.assign({}, config);
    }
    else {
        config = {};
    }
    config.asClass = asClass;
    return new TypeDescriptor(this, subtypes, TypeName, makeConstructHandler, type.prototype, config);
};
const extractNonEnumerableProps = (_obj) => {
    const extracted = Object.entries(Object.getOwnPropertyDescriptors(_obj)).reduce((obj, entry) => {
        const [name, { value }] = entry;
        odp(obj, name, {
            value,
            configurable: true,
            enumerable: true,
            writable: true,
        });
        return obj;
    }, {});
    return extracted;
};
const defineUsingFunction = function (subtypes, TypeName, constructHandler = function () { }, proto, config = {}) {
    if (typeof constructHandler !== 'function') {
        throw new HANDLER_MUST_BE_A_FUNCTION;
    }
    const asClass = isClass(constructHandler);
    const modificatorBody = (0, compileNewModificatorFunctionBody_1.default)(TypeName, asClass);
    const makeConstructHandler = modificatorBody(constructHandler, CreationHandler, SymbolConstructorName);
    if (!proto) {
        if ((0, hop_1.hop)(constructHandler, 'prototype')) {
            proto = Object.assign({}, constructHandler.prototype);
        }
        else {
            proto = {};
        }
    }
    if (asClass) {
        proto = extractNonEnumerableProps(proto);
    }
    if (config instanceof Function) {
        config = {
            ModificationConstructor: config
        };
    }
    if (typeof config !== 'object') {
        config = {};
    }
    config.asClass = asClass;
    return new TypeDescriptor(this, subtypes, TypeName, makeConstructHandler, proto, config);
};
const define = function (subtypes, TypeOrTypeName, constructHandlerOrConfig, proto, config) {
    if (typeof TypeOrTypeName === 'function') {
        if (TypeOrTypeName.name) {
            return exports.define.call(this, subtypes, TypeOrTypeName.name, TypeOrTypeName, constructHandlerOrConfig || TypeOrTypeName.prototype, config);
        }
        else {
            return defineUsingType.call(this, subtypes, TypeOrTypeName, constructHandlerOrConfig);
        }
    }
    if (typeof TypeOrTypeName === 'string') {
        checkTypeName(TypeOrTypeName);
        const split = getTypeSplitPath(TypeOrTypeName);
        const Type = exports.lookup.call(subtypes, split[0]);
        if (!Type) {
            if (split.length === 1) {
                return defineUsingFunction.call(this, subtypes, TypeOrTypeName, constructHandlerOrConfig, proto, config);
            }
            throw new WRONG_TYPE_DEFINITION(`${split[0]} definition is not yet exists`);
        }
        const TypeName = split.slice(1).join('.');
        if (split.length > 1) {
            return exports.define.call(this, Type.subtypes, TypeName, constructHandlerOrConfig, proto, config);
        }
        return exports.define.call(this, Type.subtypes, constructHandlerOrConfig, proto, config);
    }
    throw new WRONG_TYPE_DEFINITION('definition is not provided');
};
exports.define = define;
const lookup = function (TypeNestedPath) {
    if (typeof TypeNestedPath !== 'string') {
        throw new WRONG_TYPE_DEFINITION('arg : type nested path must be a string');
    }
    if (!TypeNestedPath.length) {
        throw new WRONG_TYPE_DEFINITION('arg : type nested path has no path');
    }
    const split = getTypeSplitPath(TypeNestedPath);
    const [name] = split;
    const type = this.get(name);
    if (split.length === 1) {
        return type;
    }
    const NextNestedPath = split.slice(1).join('.');
    return exports.lookup.call(type.subtypes, NextNestedPath);
};
exports.lookup = lookup;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYXBpL3R5cGVzL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7O0FBSWIseUNBQXNDO0FBRXRDLCtDQUE0QztBQUM1QyxNQUFNLEVBQ0wsR0FBRyxFQUNILGdCQUFnQixFQUNoQixxQkFBcUIsRUFDckIsWUFBWSxFQUVaLGlCQUFpQixFQUNqQixTQUFTLEdBRVQsR0FBRyxxQkFBUyxDQUFDO0FBRWQscURBQXVEO0FBR3ZELE1BQU0sRUFDTCxnQkFBZ0IsRUFDaEIscUJBQXFCLEVBQ3JCLHlCQUF5QixFQUN6QiwwQkFBMEIsR0FDMUIsR0FBRyxvQkFBVyxDQUFDO0FBS2hCLHFDQUFxQztBQUNyQywyQ0FBd0M7QUFFeEMsMkZBQW9GO0FBRXBGLG9DQUFrQztBQUNsQyxNQUFNLEVBQ0wsVUFBVSxFQUNWLGNBQWMsRUFDZCxlQUFlLEVBQ2YsZ0JBQWdCLEVBQ2hCLGFBQWEsRUFDYixPQUFPLEdBQ1AsR0FBRyxlQUFVLENBQUM7QUFFZixzQ0FBcUM7QUFFckMsTUFBTSxjQUFjLEdBQUcsVUFFdEIsWUFBOEIsRUFDOUIsS0FBVSxFQUNWLFFBQWdCLEVBQ2hCLGdCQUFrQyxFQUNsQyxLQUFxQyxFQUNyQyxNQUFzQztJQUt0QyxNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUUsZ0JBQWdCLENBQUUsSUFBSSxJQUFJLENBQUM7SUFFckQsTUFBTSxTQUFTLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztJQUU1QyxNQUFNLFVBQVUsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBRSxTQUFTLENBQUUsQ0FBQztJQUUxRSxJQUFLLEtBQUssQ0FBQyxHQUFHLENBQUUsUUFBUSxDQUFFLEVBQUcsQ0FBQztRQUM3QixNQUFNLElBQUksZ0JB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RyxDQUFDO1FBQzFCLE9BQU8sSUFBSSxDQUFDO0lBQ2IsQ0FBQztJQUVELE1BQU0sY0FBYyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUUsQ0FBQyxDQUFFLENBQUMsSUFBSSxDQUFFLEdBQUcsQ0FBRSxDQUFDO0lBQ3BELE9BQU8sY0FBTSxDQUFDLElBQUksQ0FBRSxJQUFJLENBQUMsUUFBUSxFQUFFLGNBQWMsQ0FBRSxDQUFDO0FBRXJELENBQUMsQ0FBQztBQXJCVyxRQUFBLE1BQU0sVUFxQmpCIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBDb25zdHJ1Y3RvckZ1bmN0aW9uLCBUeXBlRGVzY3JpcHRvckluc3RhbmNlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBob3AgfSBmcm9tICcuLi8uLi91dGlscy9ob3AnO1xuXG5pbXBvcnQgeyBjb25zdGFudHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuY29uc3Qge1xuXHRvZHAsXG5cdFN5bWJvbFBhcmVudFR5cGUsXG5cdFN5bWJvbENvbnN0cnVjdG9yTmFtZSxcblx0U3ltYm9sQ29uZmlnLFxuXG5cdFRZUEVfVElUTEVfUFJFRklYLFxuXHRNTkVNT1NZTkUsXG5cbn0gPSBjb25zdGFudHM7XG5cbmltcG9ydCB7IEVycm9yc1R5cGVzIH0gZnJvbSAnLi4vLi4vZGVzY3JpcHRvcnMvZXJyb3JzJztcbi8vIGltcG9ydCB7IGRlc2NyaXB0b3JzIH0gZnJvbSAnLi4vLi4vZGVzY3JpcHRvcnMnO1xuXG5jb25zdCB7XG5cdEFMUkVBRFlfREVDTEFSRUQsXG5cdFdST05HX1RZUEVfREVGSU5JVElPTixcblx0VFlQRU5BTUVfTVVTVF9CRV9BX1NUUklORyxcblx0SEFORExFUl9NVVNUX0JFX0FfRlVOQ1RJT04sXG59ID0gRXJyb3JzVHlwZXM7XG5cbi8vIGludm9rZUhvb2tcbi8vIHJlZ2lzdGVySG9va1xuLy8gcmVnaXN0ZXJGbG93Q2hlY2tlclxuaW1wb3J0ICogYXMgaG9va3NBcGkgZnJvbSAnLi4vaG9va3MnO1xuaW1wb3J0IHsgVHlwZVByb3h5IH0gZnJvbSAnLi9UeXBlUHJveHknO1xuXG5pbXBvcnQgY29tcGlsZU5ld01vZGlmaWNhdG9yRnVuY3Rpb25Cb2R5IGZyb20gJy4vY29tcGlsZU5ld01vZGlmaWNhdG9yRnVuY3Rpb25Cb2R5JztcblxuaW1wb3J0IFR5cGVzVXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuY29uc3Qge1xuXHRjaGVja1Byb3RvLFxuXHRnZXRUeXBlQ2hlY2tlcixcblx0Q3JlYXRpb25IYW5kbGVyLFxuXHRnZXRUeXBlU3BsaXRQYXRoLFxuXHRjaGVja1R5cGVOYW1lLFxuXHRpc0NsYXNzLFxufSA9IFR5cGVzVXRpbHM7XG5cbmltcG9ydCB7IGdldFN0YWNrIH0gZnJvbSAnLi4vZXJyb3JzJztcblxuY29uc3QgVHlwZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAoXG5cdHRoaXM6IGFueSxcblx0ZGVmaW5lT3JpZ2luOiBDYWxsYWJsZUZ1bmN0aW9uLFxuXHR0eXBlczogYW55LFxuXHRUeXBlTmFtZTogc3RyaW5nLFxuXHRjb25zdHJ1Y3RIYW5kbGVyOiBDYWxsYWJsZUZ1bmN0aW9uLFxuXHRwcm90bzogeyBbIGluZGV4OiBzdHJpbmcgXTogdW5rbm93biB9LFxuXHRjb25maWc6IHsgWyBpbmRleDogc3RyaW5nIF06IHVua25vd24gfSxcbikge1xuXG5cdC8vIGhlcmUgXCJ0eXBlc1wiIHJlZmVycyB0byBzdWJ0eXBlcyBvZiB0eXBlIG9yIGNvbGxlY3Rpb24gb2JqZWN0IHt9XG5cblx0Y29uc3QgcGFyZW50VHlwZSA9IHR5cGVzWyBTeW1ib2xQYXJlbnRUeXBlIF0gfHwgbnVsbDtcblxuXHRjb25zdCBpc1N1YlR5cGUgPSBwYXJlbnRUeXBlID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdGNvbnN0IGNvbGxlY3Rpb24gPSBpc1N1YlR5cGUgPyBwYXJlbnRUeXBlLmNvbGxlY3Rpb24gOiB0eXBlc1sgTU5FTU9TWU5FIF07XG5cblx0aWYgKCB0eXBlcy5oYXMoIFR5cGVOYW1lICkgKSB7XG5cdFx0dGhyb3cgbmV3IEFMUkVBRFlfREVDTEFSRUQ7XG5cdH1cblxuXHRjaGVja1Byb3RvKCBwcm90byApO1xuXG5cdC8vIGNvbnN0IHN1YnR5cGVzID0gZGVzY3JpcHRvcnMuY3JlYXRlVHlwZXNDb2xsZWN0aW9uKCk7XG5cdGNvbnN0IHN1YnR5cGVzID0gbmV3IE1hcCgpO1xuXG5cdGNvbnN0IHRpdGxlID0gYCR7VFlQRV9USVRMRV9QUkVGSVh9JHtUeXBlTmFtZX1gO1xuXG5cdGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oIHt9LCBjb2xsZWN0aW9uWyBTeW1ib2xDb25maWcgXSwgY29uZmlnICk7XG5cblx0Y29uc3QgdHlwZSA9IE9iamVjdC5hc3NpZ24oIHRoaXMsIHtcblxuXHRcdGdldCBjb25zdHJ1Y3RIYW5kbGVyICgpIHtcblx0XHRcdHJldHVybiBjb25zdHJ1Y3RIYW5kbGVyO1xuXHRcdH0sXG5cblxuXHRcdFR5cGVOYW1lLFxuXHRcdHByb3RvLFxuXG5cdFx0aXNTdWJUeXBlLFxuXHRcdHN1YnR5cGVzLFxuXHRcdHBhcmVudFR5cGUsXG5cblx0XHRjb2xsZWN0aW9uLFxuXG5cdFx0dGl0bGUsXG5cblx0XHRjb25maWcsXG5cblx0XHRob29rcyA6IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXG5cdH0gKTtcblxuXHRnZXRTdGFjay5jYWxsKCB0aGlzLCBgRGVmaW5pdGlvbiBvZiBbICR7VHlwZU5hbWV9IF0gbWFkZSBhdDpgLCBbXSwgZGVmaW5lT3JpZ2luICk7XG5cblx0b2RwKCBzdWJ0eXBlcywgU3ltYm9sUGFyZW50VHlwZSwge1xuXHRcdGdldCAoKSB7XG5cdFx0XHRyZXR1cm4gdHlwZTtcblx0XHR9XG5cdH0gKTtcblxuXHR0eXBlcy5zZXQoIFR5cGVOYW1lLCBuZXcgVHlwZVByb3h5KCB0eXBlICkgKTtcblxuXHRyZXR1cm4gdHlwZXMuZ2V0KCBUeXBlTmFtZSApO1xuXG59IGFzIENvbnN0cnVjdG9yRnVuY3Rpb248VHlwZURlc2NyaXB0b3JJbnN0YW5jZT47XG5cbk9iamVjdC5hc3NpZ24oIFR5cGVEZXNjcmlwdG9yLnByb3RvdHlwZSwgaG9va3NBcGkgKTtcblxuVHlwZURlc2NyaXB0b3IucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uICggLi4uYXJnczogYW55W10gKSB7XG5cdHJldHVybiBkZWZpbmUuY2FsbCggZGVmaW5lLCB0aGlzLnN1YnR5cGVzLCAuLi5hcmdzICk7XG59O1xuXG5UeXBlRGVzY3JpcHRvci5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gKCAuLi5hcmdzOiBhbnlbXSApIHtcblx0cmV0dXJuIGxvb2t1cC5jYWxsKCB0aGlzLnN1YnR5cGVzLCAuLi5hcmdzICk7XG59O1xuXG5vZHAoIFR5cGVEZXNjcmlwdG9yLnByb3RvdHlwZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG5cdGdldCAoKSB7XG5cdFx0cmV0dXJuIGdldFR5cGVDaGVja2VyKCB0aGlzLlR5cGVOYW1lICk7XG5cdH1cbn0gKTtcblxuY29uc3QgZGVmaW5lVXNpbmdUeXBlID0gZnVuY3Rpb24gKCB0aGlzOiBhbnksIHN1YnR5cGVzOiBhbnksIGNvbnN0cnVjdEhhbmRsZXJHZXR0ZXI6IENhbGxhYmxlRnVuY3Rpb24sIGNvbmZpZzogYW55ICkge1xuXHQvLyB3ZSBuZWVkIHRoaXMgdG8gZXh0cmFjdCBUeXBlTmFtZVxuXHRjb25zdCB0eXBlID0gY29uc3RydWN0SGFuZGxlckdldHRlcigpO1xuXG5cdGlmICggdHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0dGhyb3cgbmV3IEhBTkRMRVJfTVVTVF9CRV9BX0ZVTkNUSU9OO1xuXHR9XG5cblx0Y29uc3QgVHlwZU5hbWUgPSB0eXBlLm5hbWU7XG5cblx0aWYgKCAhVHlwZU5hbWUgKSB7XG5cdFx0dGhyb3cgbmV3IFRZUEVOQU1FX01VU1RfQkVfQV9TVFJJTkc7XG5cdH1cblxuXHRjb25zdCBhc0NsYXNzID0gaXNDbGFzcyggdHlwZSApO1xuXG5cdGNvbnN0IG1ha2VDb25zdHJ1Y3RIYW5kbGVyID0gKCkgPT4ge1xuXHRcdGNvbnN0IGNvbnN0cnVjdEhhbmRsZXIgPSBjb25zdHJ1Y3RIYW5kbGVyR2V0dGVyKCk7XG5cdFx0Ly8gY29uc3RydWN0SGFuZGxlcltTeW1ib2xDb25zdHJ1Y3Rvck5hbWVdID0gVHlwZU5hbWU7XG5cdFx0b2RwKCBjb25zdHJ1Y3RIYW5kbGVyLCBTeW1ib2xDb25zdHJ1Y3Rvck5hbWUsIHtcblx0XHRcdGdldCAoKSB7XG5cdFx0XHRcdHJldHVybiBUeXBlTmFtZTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0Y29uc3QgcHJvdG9EZXNjOiBhbnkgPSBPYmplY3Rcblx0XHRcdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIGNvbnN0cnVjdEhhbmRsZXIsICdwcm90b3R5cGUnICk7XG5cdFx0aWYgKCBwcm90b0Rlc2Mud3JpdGFibGUgKSB7XG5cdFx0XHRjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSA9IHt9O1xuXHRcdH1cblx0XHRyZXR1cm4gY29uc3RydWN0SGFuZGxlcjtcblx0fTtcblxuXHRpZiAoIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICkge1xuXHRcdGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oIHt9LCBjb25maWcgKTtcblx0fSBlbHNlIHtcblx0XHRjb25maWcgPSB7fTtcblx0fVxuXG5cdGNvbmZpZy5hc0NsYXNzID0gYXNDbGFzcztcblxuXHRyZXR1cm4gbmV3IFR5cGVEZXNjcmlwdG9yKFxuXHRcdHRoaXMsXG5cdFx0c3VidHlwZXMsXG5cdFx0VHlwZU5hbWUsXG5cdFx0bWFrZUNvbnN0cnVjdEhhbmRsZXIsXG5cdFx0dHlwZS5wcm90b3R5cGUsXG5cdFx0Y29uZmlnXG5cdCk7XG59O1xuXG5jb25zdCBleHRyYWN0Tm9uRW51bWVyYWJsZVByb3BzID0gKCBfb2JqOiBvYmplY3QgKSA9PiB7XG5cdGNvbnN0IGV4dHJhY3RlZCA9IE9iamVjdC5lbnRyaWVzKCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyggX29iaiApICkucmVkdWNlKCAoIG9iaiwgZW50cnkgKSA9PiB7XG5cdFx0Y29uc3QgWyBuYW1lLCB7IHZhbHVlIH0gXSA9IGVudHJ5O1xuXHRcdG9kcCggb2JqLCBuYW1lLCB7XG5cdFx0XHR2YWx1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZSA6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlICAgOiB0cnVlLFxuXHRcdFx0d3JpdGFibGUgICAgIDogdHJ1ZSxcblx0XHR9XG5cdFx0KTtcblx0XHRyZXR1cm4gb2JqO1xuXHR9LCB7fSApO1xuXHRyZXR1cm4gZXh0cmFjdGVkO1xufTtcblxuXG5jb25zdCBkZWZpbmVVc2luZ0Z1bmN0aW9uID0gZnVuY3Rpb24gKFxuXHR0aGlzOiBhbnksXG5cdHN1YnR5cGVzOiBhbnksXG5cdFR5cGVOYW1lOiBzdHJpbmcsXG5cdGNvbnN0cnVjdEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7IH0sXG5cdHByb3RvOiBhbnksXG5cdGNvbmZpZzogYW55ID0ge31cbikge1xuXG5cdGlmICggdHlwZW9mIGNvbnN0cnVjdEhhbmRsZXIgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0dGhyb3cgbmV3IEhBTkRMRVJfTVVTVF9CRV9BX0ZVTkNUSU9OO1xuXHR9XG5cblx0Y29uc3QgYXNDbGFzcyA9IGlzQ2xhc3MoIGNvbnN0cnVjdEhhbmRsZXIgKTtcblx0Y29uc3QgbW9kaWZpY2F0b3JCb2R5ID0gY29tcGlsZU5ld01vZGlmaWNhdG9yRnVuY3Rpb25Cb2R5KCBUeXBlTmFtZSwgYXNDbGFzcyApO1xuXG5cdGNvbnN0IG1ha2VDb25zdHJ1Y3RIYW5kbGVyID0gbW9kaWZpY2F0b3JCb2R5KFxuXHRcdGNvbnN0cnVjdEhhbmRsZXIsXG5cdFx0Q3JlYXRpb25IYW5kbGVyLFxuXHRcdFN5bWJvbENvbnN0cnVjdG9yTmFtZVxuXHQpO1xuXG5cdGlmICggIXByb3RvICkge1xuXHRcdGlmICggaG9wKCBjb25zdHJ1Y3RIYW5kbGVyLCAncHJvdG90eXBlJyApICkge1xuXHRcdFx0cHJvdG8gPSBPYmplY3QuYXNzaWduKCB7fSwgY29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvdG8gPSB7fTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIGFzQ2xhc3MgKSB7XG5cdFx0cHJvdG8gPSBleHRyYWN0Tm9uRW51bWVyYWJsZVByb3BzKCBwcm90byApO1xuXHR9XG5cblx0aWYgKCBjb25maWcgaW5zdGFuY2VvZiBGdW5jdGlvbiApIHtcblx0XHRjb25maWcgPSB7XG5cdFx0XHRNb2RpZmljYXRpb25Db25zdHJ1Y3RvciA6IGNvbmZpZ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoIHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnICkge1xuXHRcdGNvbmZpZyA9IHt9O1xuXHR9XG5cblxuXHRjb25maWcuYXNDbGFzcyA9IGFzQ2xhc3M7XG5cblx0cmV0dXJuIG5ldyBUeXBlRGVzY3JpcHRvcihcblx0XHR0aGlzLFxuXHRcdHN1YnR5cGVzLFxuXHRcdFR5cGVOYW1lLFxuXHRcdG1ha2VDb25zdHJ1Y3RIYW5kbGVyLFxuXHRcdHByb3RvLFxuXHRcdGNvbmZpZ1xuXHQpO1xuXG59O1xuXG5cbmV4cG9ydCBjb25zdCBkZWZpbmU6IGFueSA9IGZ1bmN0aW9uICggdGhpczogYW55LCBzdWJ0eXBlczogYW55LCBUeXBlT3JUeXBlTmFtZTogc3RyaW5nIHwgYW55LCBjb25zdHJ1Y3RIYW5kbGVyT3JDb25maWc6IGFueSwgcHJvdG86IG9iamVjdCwgY29uZmlnOiBvYmplY3QgKSB7XG5cblx0aWYgKCB0eXBlb2YgVHlwZU9yVHlwZU5hbWUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0aWYgKCBUeXBlT3JUeXBlTmFtZS5uYW1lICkge1xuXHRcdFx0cmV0dXJuIGRlZmluZS5jYWxsKCB0aGlzLCBzdWJ0eXBlcywgVHlwZU9yVHlwZU5hbWUubmFtZSwgVHlwZU9yVHlwZU5hbWUsIGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZyB8fCBUeXBlT3JUeXBlTmFtZS5wcm90b3R5cGUsIGNvbmZpZyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZGVmaW5lVXNpbmdUeXBlLmNhbGwoIHRoaXMsIHN1YnR5cGVzLCBUeXBlT3JUeXBlTmFtZSwgY29uc3RydWN0SGFuZGxlck9yQ29uZmlnICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCB0eXBlb2YgVHlwZU9yVHlwZU5hbWUgPT09ICdzdHJpbmcnICkge1xuXG5cdFx0Y2hlY2tUeXBlTmFtZSggVHlwZU9yVHlwZU5hbWUgKTtcblxuXHRcdGNvbnN0IHNwbGl0ID0gZ2V0VHlwZVNwbGl0UGF0aCggVHlwZU9yVHlwZU5hbWUgKTtcblxuXHRcdGNvbnN0IFR5cGUgPSBsb29rdXAuY2FsbCggc3VidHlwZXMsIHNwbGl0WyAwIF0gKTtcblxuXHRcdGlmICggIVR5cGUgKSB7XG5cblx0XHRcdGlmICggc3BsaXQubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZGVmaW5lVXNpbmdGdW5jdGlvbi5jYWxsKCB0aGlzLCBzdWJ0eXBlcywgVHlwZU9yVHlwZU5hbWUsIGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZywgcHJvdG8sIGNvbmZpZyApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyBuZXcgV1JPTkdfVFlQRV9ERUZJTklUSU9OKCBgJHtzcGxpdFsgMCBdfSBkZWZpbml0aW9uIGlzIG5vdCB5ZXQgZXhpc3RzYCApO1xuXHRcdH1cblxuXHRcdGNvbnN0IFR5cGVOYW1lID0gc3BsaXQuc2xpY2UoIDEgKS5qb2luKCAnLicgKTtcblxuXHRcdGlmICggc3BsaXQubGVuZ3RoID4gMSApIHtcblx0XHRcdHJldHVybiBkZWZpbmUuY2FsbCggdGhpcywgVHlwZS5zdWJ0eXBlcywgVHlwZU5hbWUsIGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZywgcHJvdG8sIGNvbmZpZyApO1xuXHRcdH1cblxuXHRcdC8vIHNvLCBoZXJlIHdlIGdvIHdpdGhcblx0XHQvLyBkZWZpbmVVc2luZ1R5cGUuY2FsbFxuXHRcdC8vIGZyb20gdGhlIG5leHQgc3RlcFxuXHRcdHJldHVybiBkZWZpbmUuY2FsbCggdGhpcywgVHlwZS5zdWJ0eXBlcywgY29uc3RydWN0SGFuZGxlck9yQ29uZmlnLCBwcm90bywgY29uZmlnICk7XG5cblx0fVxuXG5cdHRocm93IG5ldyBXUk9OR19UWVBFX0RFRklOSVRJT04oICdkZWZpbml0aW9uIGlzIG5vdCBwcm92aWRlZCcgKTtcblxufTtcblxuZXhwb3J0IGNvbnN0IGxvb2t1cDogYW55ID0gZnVuY3Rpb24gKCB0aGlzOiBhbnksIFR5cGVOZXN0ZWRQYXRoOiBzdHJpbmcgKSB7XG5cblx0aWYgKCB0eXBlb2YgVHlwZU5lc3RlZFBhdGggIT09ICdzdHJpbmcnICkge1xuXHRcdHRocm93IG5ldyBXUk9OR19UWVBFX0RFRklOSVRJT04oICdhcmcgOiB0eXBlIG5lc3RlZCBwYXRoIG11c3QgYmUgYSBzdHJpbmcnICk7XG5cdH1cblxuXHRpZiAoICFUeXBlTmVzdGVkUGF0aC5sZW5ndGggKSB7XG5cdFx0dGhyb3cgbmV3IFdST05HX1RZUEVfREVGSU5JVElPTiggJ2FyZyA6IHR5cGUgbmVzdGVkIHBhdGggaGFzIG5vIHBhdGgnICk7XG5cdH1cblxuXHRjb25zdCBzcGxpdCA9IGdldFR5cGVTcGxpdFBhdGgoIFR5cGVOZXN0ZWRQYXRoICk7XG5cblx0Y29uc3QgWyBuYW1lIF0gPSBzcGxpdDtcblx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0KCBuYW1lICk7XG5cdGlmICggc3BsaXQubGVuZ3RoID09PSAxICkge1xuXHRcdHJldHVybiB0eXBlO1xuXHR9XG5cblx0Y29uc3QgTmV4dE5lc3RlZFBhdGggPSBzcGxpdC5zbGljZSggMSApLmpvaW4oICcuJyApO1xuXHRyZXR1cm4gbG9va3VwLmNhbGwoIHR5cGUuc3VidHlwZXMsIE5leHROZXN0ZWRQYXRoICk7XG5cbn07XG4iXX0=