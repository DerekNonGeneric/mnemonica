'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.lookup = exports.define = void 0;
const hop_1 = require("../../utils/hop");
const constants_1 = require("../../constants");
const { odp, SymbolParentType, SymbolConstructorName, SymbolConfig, TYPE_TITLE_PREFIX, MNEMOSYNE, } = constants_1.constants;
const errors_1 = require("../../descriptors/errors");
const { ALREADY_DECLARED, WRONG_TYPE_DEFINITION, TYPENAME_MUST_BE_A_STRING, HANDLER_MUST_BE_A_FUNCTION, } = errors_1.ErrorsTypes;
const hooksApi = require("../hooks");
const TypeProxy_1 = require("./TypeProxy");
const compileNewModificatorFunctionBody_1 = require("./compileNewModificatorFunctionBody");
const utils_1 = require("../utils");
const { getTypeChecker, CreationHandler, getTypeSplitPath, checkTypeName, isClass, } = utils_1.default;
const errors_2 = require("../errors");
const TypeDescriptor = function (defineOrigin, types, TypeName, constructHandler, proto, config) {
    const parentType = types[SymbolParentType] || null;
    const isSubType = parentType ? true : false;
    const collection = isSubType ? parentType.collection : types[MNEMOSYNE];
    if (types.has(TypeName)) {
        throw new ALREADY_DECLARED;
    }
    const subtypes = new Map();
    const title = `${TYPE_TITLE_PREFIX}${TypeName}`;
    config = Object.assign({}, collection[SymbolConfig], config);
    const type = Object.assign(this, {
        get constructHandler() {
            return constructHandler;
        },
        TypeName,
        proto,
        isSubType,
        subtypes,
        parentType,
        collection,
        title,
        config,
        hooks: Object.create(null)
    });
    errors_2.getStack.call(this, `Definition of [ ${TypeName} ] made at:`, [], defineOrigin);
    odp(subtypes, SymbolParentType, {
        get() {
            return type;
        }
    });
    types.set(TypeName, new TypeProxy_1.TypeProxy(type));
    return types.get(TypeName);
};
Object.assign(TypeDescriptor.prototype, hooksApi);
TypeDescriptor.prototype.define = function (...args) {
    return exports.define.call(exports.define, this.subtypes, ...args);
};
TypeDescriptor.prototype.lookup = function (...args) {
    return exports.lookup.call(this.subtypes, ...args);
};
odp(TypeDescriptor.prototype, Symbol.hasInstance, {
    get() {
        return getTypeChecker(this.TypeName);
    }
});
const defineUsingType = function (subtypes, constructHandlerGetter, config) {
    const type = constructHandlerGetter();
    if (typeof type !== 'function') {
        throw new HANDLER_MUST_BE_A_FUNCTION;
    }
    const TypeName = type.name;
    if (!TypeName) {
        throw new TYPENAME_MUST_BE_A_STRING;
    }
    const asClass = isClass(type);
    const makeConstructHandler = () => {
        const constructHandler = constructHandlerGetter();
        odp(constructHandler, SymbolConstructorName, {
            get() {
                return TypeName;
            }
        });
        const protoDesc = Object
            .getOwnPropertyDescriptor(constructHandler, 'prototype');
        if (protoDesc.writable) {
            constructHandler.prototype = {};
        }
        return constructHandler;
    };
    if (typeof config === 'object') {
        config = Object.assign({}, config);
    }
    else {
        config = {};
    }
    config.asClass = asClass;
    return new TypeDescriptor(this, subtypes, TypeName, makeConstructHandler, type.prototype, config);
};
const defineUsingFunction = function (subtypes, TypeName, constructHandler = function () { }, config = {}) {
    if (typeof constructHandler !== 'function') {
        throw new HANDLER_MUST_BE_A_FUNCTION;
    }
    const asClass = isClass(constructHandler);
    const modificatorBody = (0, compileNewModificatorFunctionBody_1.default)(TypeName, asClass);
    const makeConstructHandler = modificatorBody(constructHandler, CreationHandler, SymbolConstructorName);
    if (config instanceof Function) {
        config = {
            ModificationConstructor: config
        };
    }
    if (typeof config !== 'object') {
        config = {};
    }
    config.asClass = asClass;
    const proto = (0, hop_1.hop)(constructHandler, 'prototype') &&
        (constructHandler.prototype instanceof Object) ?
        Object.assign({}, constructHandler.prototype) :
        {};
    return new TypeDescriptor(this, subtypes, TypeName, makeConstructHandler, proto, config);
};
const define = function (subtypes, TypeOrTypeName, constructHandlerOrConfig, config) {
    if (typeof TypeOrTypeName === 'function') {
        if (TypeOrTypeName.name) {
            return exports.define.call(this, subtypes, TypeOrTypeName.name, TypeOrTypeName, config);
        }
        else {
            return defineUsingType.call(this, subtypes, TypeOrTypeName, constructHandlerOrConfig);
        }
    }
    if (typeof TypeOrTypeName === 'string') {
        checkTypeName(TypeOrTypeName);
        const split = getTypeSplitPath(TypeOrTypeName);
        const Type = exports.lookup.call(subtypes, split[0]);
        if (!Type) {
            if (split.length === 1) {
                return defineUsingFunction.call(this, subtypes, TypeOrTypeName, constructHandlerOrConfig, config);
            }
            throw new WRONG_TYPE_DEFINITION(`${split[0]} definition is not yet exists`);
        }
        const TypeName = split.slice(1).join('.');
        if (split.length > 1) {
            return exports.define.call(this, Type.subtypes, TypeName, constructHandlerOrConfig, config);
        }
        return exports.define.call(this, Type.subtypes, constructHandlerOrConfig, config);
    }
    throw new WRONG_TYPE_DEFINITION('definition is not provided');
};
exports.define = define;
const lookup = function (TypeNestedPath) {
    if (typeof TypeNestedPath !== 'string') {
        throw new WRONG_TYPE_DEFINITION('arg : type nested path must be a string');
    }
    if (!TypeNestedPath.length) {
        throw new WRONG_TYPE_DEFINITION('arg : type nested path has no path');
    }
    const split = getTypeSplitPath(TypeNestedPath);
    const [name] = split;
    const type = this.get(name);
    if (split.length === 1) {
        return type;
    }
    const NextNestedPath = split.slice(1).join('.');
    return exports.lookup.call(type.subtypes, NextNestedPath);
};
exports.lookup = lookup;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYXBpL3R5cGVzL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7O0FBSWIseUNBQXNDO0FBRXRDLCtDQUE0QztBQUM1QyxNQUFNLEVBQ0wsR0FBRyxFQUNILGdCQUFnQixFQUNoQixxQkFBcUIsRUFDckIsWUFBWSxFQUVaLGlCQUFpQixFQUNqQixTQUFTLEdBRVQsR0FBRyxxQkFBUyxDQUFDO0FBRWQscURBQXVEO0FBR3ZELE1BQU0sRUFDTCxnQkFBZ0IsRUFDaEIscUJBQXFCLEVBQ3JCLHlCQUF5QixFQUN6QiwwQkFBMEIsR0FDMUIsR0FBRyxvQkFBVyxDQUFDO0FBS2hCLHFDQUFxQztBQUNyQywyQ0FBd0M7QUFFeEMsMkZBQW9GO0FBRXBGLG9DQUFrQztBQUNsQyxNQUFNLEVBQ0wsY0FBYyxFQUNkLGVBQWUsRUFDZixnQkFBZ0IsRUFDaEIsYUFBYSxFQUNiLE9BQU8sR0FDUCxHQUFHLGVBQVUsQ0FBQztBQUVmLHNDQUFxQztBQUVyQyxNQUFNLGNBQWMsR0FBRyxVQUV0QixZQUE4QixFQUM5QixLQUFVLEVBQ1YsUUFBZ0IsRUFDaEIsZ0JBQWtDLEVBQ2xDLEtBQXFDLEVBQ3JDLE1BQXNDO0lBS3RDLE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBRSxnQkFBZ0IsQ0FBRSxJQUFJLElBQUksQ0FBQztJQUVyRCxNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBRTVDLE1BQU0sVUFBVSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFFLFNBQVMsQ0FBRSxDQUFDO0lBRTFFLElBQUssS0FBSyxDQUFDLEdBQUcsQ0FBRSxRQUFRLENBQUUsRUFBRyxDQUFDO1FBQzdCLE1BQU0sSUFBSSxnQkFBZ0IsQ0FBQztJQUM1QixDQUFDO0lBR0QsTUFBTSxRQUFRLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUUzQixNQUFNLEtBQUssR0FBRyxHQUFHLGlCQUFpQixHQUFHLFFBQVEsRUFBRSxDQUFDO0lBRWhELE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFFLEVBQUUsRUFBRSxVQUFVLENBQUUsWUFBWSxDQUFFLEVBQUUsTUFBTSxDQUFFLENBQUM7SUFFakUsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBRSxJQUFJLEVBQUU7UUFFakMsSUFBSSxnQkFBZ0I7WUFDbkIsT0FBTyxnQkFBZ0IsQ0FBQztRQUN6QixDQUFDO1FBR0QsUUFBUTtRQUNSLEtBQUs7UUFFTCxTQUFTO1FBQ1QsUUFBUTtRQUNSLFVBQVU7UUFFVixVQUFVO1FBRVYsS0FBSztRQUVMLE1BQU07UUFFTixLQUFLLEVBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBRSxJQUFJLENBQUU7S0FFN0IsQ0FBRSxDQUFDO0lBRUosaUJBQVEsQ0FBQyxJQUFJLENBQUUsSUFBSSxFQUFFLG1CQUFtQixRQUFRLGFBQWEsRUFBRSxFQUFFLEVBQUUsWUFBWSxDQUFFLENBQUM7SUFFbEYsR0FBRyxDQUFFLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRTtRQUNoQyxHQUFHO1lBQ0YsT0FBTyxJQUFJLENBQUM7UUFDYixDQUFDO0tBQ0QsQ0FBRSxDQUFDO0lBRUosS0FBSyxDQUFDLEdBQUcsQ0FBRSxRQUFRLEVBQUUsSUFBSSxxQkFBUyxDQUFFLElBQUksQ0FBRSxDQUFFLENBQUM7SUFFN0MsT0FBTyxLQUFLLENBQUMsR0FBRyxDQUFFLFFBQVEsQ0FBRSxDQUFDO0FBRTlCLENBQWdELENBQUM7QUFFakQsTUFBTSxDQUFDLE1BQU0sQ0FBRSxjQUFjLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBRSxDQUFDO0FBRXBELGNBQWMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFVBQVcsR0FBRyxJQUFXO0lBQzFELE9BQU8sY0FBTSxDQUFDLElBQUksQ0FBRSxjQUFNLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBRSxDQUFDO0FBQ3RELENBQUMsQ0FBQztBQUVGLGNBQWMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFVBQVcsR0FBRyxJQUFXO0lBQzFELE9BQU8sY0FBTSxDQUFDLElBQUksQ0FBRSxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFFLENBQUM7QUFDOUMsQ0FBQyxDQUFDO0FBRUYsR0FBRyxDQUFFLGNBQWMsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLFdBQVcsRUFBRTtJQUNsRCxHQUFHO1FBQ0YsT0FBTyxjQUFjLENBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBRSxDQUFDO0lBQ3hDLENBQUM7Q0FDRCxDQUFFLENBQUM7QUFFSixNQUFNLGVBQWUsR0FBRyxVQUFzQixRQUFhLEVBQUUsc0JBQXdDLEVBQUUsTUFBVztJQUVqSCxNQUFNLElBQUksR0FBRyxzQkFBc0IsRUFBRSxDQUFDO0lBRXRDLElBQUssT0FBTyxJQUFJLEtBQUssVUFBVSxFQUFHLENBQUM7UUFDbEMsTUFBTSxJQUFJLDBCQUEwQixDQUFDO0lBQ3RDLENBQUM7SUFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBRTNCLElBQUssQ0FBQyxRQUFRLEVBQUcsQ0FBQztRQUNqQixNQUFNLElBQUkseUJBQXlCLENBQUM7SUFDckMsQ0FBQztJQUVELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBRSxJQUFJLENBQUUsQ0FBQztJQUVoQyxNQUFNLG9CQUFvQixHQUFHLEdBQUcsRUFBRTtRQUNqQyxNQUFNLGdCQUFnQixHQUFHLHNCQUFzQixFQUFFLENBQUM7UUFFbEQsR0FBRyxDQUFFLGdCQUFnQixFQUFFLHFCQUFxQixFQUFFO1lBQzdDLEdBQUc7Z0JBQ0YsT0FBTyxRQUFRLENBQUM7WUFDakIsQ0FBQztTQUNELENBQUUsQ0FBQztRQUNKLE1BQU0sU0FBUyxHQUFRLE1BQU07YUFDM0Isd0JBQXdCLENBQUUsZ0JBQWdCLEVBQUUsV0FBVyxDQUFFLENBQUM7UUFDNUQsSUFBSyxTQUFTLENBQUMsUUFBUSxFQUFHLENBQUM7WUFDMUIsZ0JBQWdCLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztRQUNqQyxDQUFDO1FBQ0QsT0FBTyxnQkFBZ0IsQ0FBQztJQUN6QixDQUFDLENBQUM7SUFFRixJQUFLLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRyxDQUFDO1FBQ2xDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFFLEVBQUUsRUFBRSxNQUFNLENBQUUsQ0FBQztJQUN0QyxDQUFDO1NBQU0sQ0FBQztRQUNQLE1BQU0sR0FBRyxFQUFFLENBQUM7SUFDYixDQUFDO0lBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7SUFFekIsT0FBTyxJQUFJLGNBQWMsQ0FDeEIsSUFBSSxFQUNKLFFBQVEsRUFDUixRQUFRLEVBQ1Isb0JBQW9CLEVBQ3BCLElBQUksQ0FBQyxTQUFTLEVBQ2QsTUFBTSxDQUNOLENBQUM7QUFDSCxDQUFDLENBQUM7QUFFRixNQUFNLG1CQUFtQixHQUFHLFVBRTNCLFFBQWEsRUFDYixRQUFnQixFQUNoQixnQkFBZ0IsR0FBRyxjQUFjLENBQUMsRUFDbEMsU0FBYyxFQUFFO0lBR2hCLElBQUssT0FBTyxnQkFBZ0IsS0FBSyxVQUFVLEVBQUcsQ0FBQztRQUM5QyxNQUFNLElBQUksMEJBQTBCLENBQUM7SUFDdEMsQ0FBQztJQUVELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBRSxnQkFBZ0IsQ0FBRSxDQUFDO0lBQzVDLE1BQU0sZUFBZSxHQUFHLElBQUEsMkNBQWlDLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBRSxDQUFDO0lBRS9FLE1BQU0sb0JBQW9CLEdBQUcsZUFBZSxDQUMzQyxnQkFBZ0IsRUFDaEIsZUFBZSxFQUNmLHFCQUFxQixDQUNyQixDQUFDO0lBRUYsSUFBSyxNQUFNLFlBQVksUUFBUSxFQUFHLENBQUM7UUFDbEMsTUFBTSxHQUFHO1lBQ1IsdUJBQXVCLEVBQUcsTUFBTTtTQUNoQyxDQUFDO0lBQ0gsQ0FBQztJQUVELElBQUssT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFHLENBQUM7UUFDbEMsTUFBTSxHQUFHLEVBQUUsQ0FBQztJQUNiLENBQUM7SUFHRCxNQUFNLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztJQUV6QixNQUFNLEtBQUssR0FBRyxJQUFBLFNBQUcsRUFBRSxnQkFBZ0IsRUFBRSxXQUFXLENBQUU7UUFDakQsQ0FBRSxnQkFBZ0IsQ0FBQyxTQUFTLFlBQVksTUFBTSxDQUFFLENBQUMsQ0FBQztRQUNsRCxNQUFNLENBQUMsTUFBTSxDQUFFLEVBQUUsRUFBRSxnQkFBZ0IsQ0FBQyxTQUFTLENBQUUsQ0FBQyxDQUFDO1FBQ2pELEVBQUUsQ0FBQztJQUVKLE9BQU8sSUFBSSxjQUFjLENBQ3hCLElBQUksRUFDSixRQUFRLEVBQ1IsUUFBUSxFQUNSLG9CQUFvQixFQUVwQixLQUFLLEVBQ0wsTUFBTSxDQUNOLENBQUM7QUFFSCxDQUFDLENBQUM7QUFHSyxNQUFNLE1BQU0sR0FBUSxVQUFzQixRQUFhLEVBQUUsY0FBNEIsRUFBRSx3QkFBNkIsRUFBRSxNQUFjO0lBRTFJLElBQUssT0FBTyxjQUFjLEtBQUssVUFBVSxFQUFHLENBQUM7UUFDNUMsSUFBSyxjQUFjLENBQUMsSUFBSSxFQUFHLENBQUM7WUFDM0IsT0FBTyxjQUFNLENBQUMsSUFBSSxDQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsY0FBYyxDQUFDLElBQUksRUFBRSxjQUFjLEVBQUUsTUFBTSxDQUFFLENBQUM7UUFDbkYsQ0FBQzthQUFNLENBQUM7WUFDUCxPQUFPLGVBQWUsQ0FBQyxJQUFJLENBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxjQUFjLEVBQUUsd0JBQXdCLENBQUUsQ0FBQztRQUN6RixDQUFDO0lBQ0YsQ0FBQztJQUVELElBQUssT0FBTyxjQUFjLEtBQUssUUFBUSxFQUFHLENBQUM7UUFFMUMsYUFBYSxDQUFFLGNBQWMsQ0FBRSxDQUFDO1FBRWhDLE1BQU0sS0FBSyxHQUFHLGdCQUFnQixDQUFFLGNBQWMsQ0FBRSxDQUFDO1FBRWpELE1BQU0sSUFBSSxHQUFHLGNBQU0sQ0FBQyxJQUFJLENBQUUsUUFBUSxFQUFFLEtBQUssQ0FBRSxDQUFDLENBQUUsQ0FBRSxDQUFDO1FBRWpELElBQUssQ0FBQyxJQUFJLEVBQUcsQ0FBQztZQUViLElBQUssS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUcsQ0FBQztnQkFDMUIsT0FBTyxtQkFBbUIsQ0FBQyxJQUFJLENBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxjQUFjLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxDQUFFLENBQUM7WUFDckcsQ0FBQztZQUVELE1BQU0sSUFBSSxxQkFBcUIsQ0FBRSxHQUFHLEtBQUssQ0FBRSxDQUFDLENBQUUsK0JBQStCLENBQUUsQ0FBQztRQUNqRixDQUFDO1FBRUQsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBRSxDQUFDLENBQUUsQ0FBQyxJQUFJLENBQUUsR0FBRyxDQUFFLENBQUM7UUFFOUMsSUFBSyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRyxDQUFDO1lBQ3hCLE9BQU8sY0FBTSxDQUFDLElBQUksQ0FBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxDQUFFLENBQUM7UUFDdkYsQ0FBQztRQUtELE9BQU8sY0FBTSxDQUFDLElBQUksQ0FBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSx3QkFBd0IsRUFBRSxNQUFNLENBQUUsQ0FBQztJQUU3RSxDQUFDO0lBRUQsTUFBTSxJQUFJLHFCQUFxQixDQUFFLDRCQUE0QixDQUFFLENBQUM7QUFFakUsQ0FBQyxDQUFDO0FBMUNXLFFBQUEsTUFBTSxVQTBDakI7QUFFSyxNQUFNLE1BQU0sR0FBUSxVQUFzQixjQUFzQjtJQUV0RSxJQUFLLE9BQU8sY0FBYyxLQUFLLFFBQVEsRUFBRyxDQUFDO1FBQzFDLE1BQU0sSUFBSSxxQkFBcUIsQ0FBRSx5Q0FBeUMsQ0FBRSxDQUFDO0lBQzlFLENBQUM7SUFFRCxJQUFLLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRyxDQUFDO1FBQzlCLE1BQU0sSUFBSSxxQkFBcUIsQ0FBRSxvQ0FBb0MsQ0FBRSxDQUFDO0lBQ3pFLENBQUM7SUFFRCxNQUFNLEtBQUssR0FBRyxnQkFBZ0IsQ0FBRSxjQUFjLENBQUUsQ0FBQztJQUVqRCxNQUFNLENBQUUsSUFBSSxDQUFFLEdBQUcsS0FBSyxDQUFDO0lBQ3ZCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUUsSUFBSSxDQUFFLENBQUM7SUFDOUIsSUFBSyxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRyxDQUFDO1FBQzFCLE9BQU8sSUFBSSxDQUFDO0lBQ2IsQ0FBQztJQUVELE1BQU0sY0FBYyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUUsQ0FBQyxDQUFFLENBQUMsSUFBSSxDQUFFLEdBQUcsQ0FBRSxDQUFDO0lBQ3BELE9BQU8sY0FBTSxDQUFDLElBQUksQ0FBRSxJQUFJLENBQUMsUUFBUSxFQUFFLGNBQWMsQ0FBRSxDQUFDO0FBRXJELENBQUMsQ0FBQztBQXJCVyxRQUFBLE1BQU0sVUFxQmpCIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBDb25zdHJ1Y3RvckZ1bmN0aW9uLCBUeXBlRGVzY3JpcHRvckluc3RhbmNlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBob3AgfSBmcm9tICcuLi8uLi91dGlscy9ob3AnO1xuXG5pbXBvcnQgeyBjb25zdGFudHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuY29uc3Qge1xuXHRvZHAsXG5cdFN5bWJvbFBhcmVudFR5cGUsXG5cdFN5bWJvbENvbnN0cnVjdG9yTmFtZSxcblx0U3ltYm9sQ29uZmlnLFxuXG5cdFRZUEVfVElUTEVfUFJFRklYLFxuXHRNTkVNT1NZTkUsXG5cbn0gPSBjb25zdGFudHM7XG5cbmltcG9ydCB7IEVycm9yc1R5cGVzIH0gZnJvbSAnLi4vLi4vZGVzY3JpcHRvcnMvZXJyb3JzJztcbi8vIGltcG9ydCB7IGRlc2NyaXB0b3JzIH0gZnJvbSAnLi4vLi4vZGVzY3JpcHRvcnMnO1xuXG5jb25zdCB7XG5cdEFMUkVBRFlfREVDTEFSRUQsXG5cdFdST05HX1RZUEVfREVGSU5JVElPTixcblx0VFlQRU5BTUVfTVVTVF9CRV9BX1NUUklORyxcblx0SEFORExFUl9NVVNUX0JFX0FfRlVOQ1RJT04sXG59ID0gRXJyb3JzVHlwZXM7XG5cbi8vIGludm9rZUhvb2tcbi8vIHJlZ2lzdGVySG9va1xuLy8gcmVnaXN0ZXJGbG93Q2hlY2tlclxuaW1wb3J0ICogYXMgaG9va3NBcGkgZnJvbSAnLi4vaG9va3MnO1xuaW1wb3J0IHsgVHlwZVByb3h5IH0gZnJvbSAnLi9UeXBlUHJveHknO1xuXG5pbXBvcnQgY29tcGlsZU5ld01vZGlmaWNhdG9yRnVuY3Rpb25Cb2R5IGZyb20gJy4vY29tcGlsZU5ld01vZGlmaWNhdG9yRnVuY3Rpb25Cb2R5JztcblxuaW1wb3J0IFR5cGVzVXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuY29uc3Qge1xuXHRnZXRUeXBlQ2hlY2tlcixcblx0Q3JlYXRpb25IYW5kbGVyLFxuXHRnZXRUeXBlU3BsaXRQYXRoLFxuXHRjaGVja1R5cGVOYW1lLFxuXHRpc0NsYXNzLFxufSA9IFR5cGVzVXRpbHM7XG5cbmltcG9ydCB7IGdldFN0YWNrIH0gZnJvbSAnLi4vZXJyb3JzJztcblxuY29uc3QgVHlwZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAoXG5cdHRoaXM6IGFueSxcblx0ZGVmaW5lT3JpZ2luOiBDYWxsYWJsZUZ1bmN0aW9uLFxuXHR0eXBlczogYW55LFxuXHRUeXBlTmFtZTogc3RyaW5nLFxuXHRjb25zdHJ1Y3RIYW5kbGVyOiBDYWxsYWJsZUZ1bmN0aW9uLFxuXHRwcm90bzogeyBbIGluZGV4OiBzdHJpbmcgXTogdW5rbm93biB9LFxuXHRjb25maWc6IHsgWyBpbmRleDogc3RyaW5nIF06IHVua25vd24gfSxcbikge1xuXG5cdC8vIGhlcmUgXCJ0eXBlc1wiIHJlZmVycyB0byBzdWJ0eXBlcyBvZiB0eXBlIG9yIGNvbGxlY3Rpb24gb2JqZWN0IHt9XG5cblx0Y29uc3QgcGFyZW50VHlwZSA9IHR5cGVzWyBTeW1ib2xQYXJlbnRUeXBlIF0gfHwgbnVsbDtcblxuXHRjb25zdCBpc1N1YlR5cGUgPSBwYXJlbnRUeXBlID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdGNvbnN0IGNvbGxlY3Rpb24gPSBpc1N1YlR5cGUgPyBwYXJlbnRUeXBlLmNvbGxlY3Rpb24gOiB0eXBlc1sgTU5FTU9TWU5FIF07XG5cblx0aWYgKCB0eXBlcy5oYXMoIFR5cGVOYW1lICkgKSB7XG5cdFx0dGhyb3cgbmV3IEFMUkVBRFlfREVDTEFSRUQ7XG5cdH1cblxuXHQvLyBjb25zdCBzdWJ0eXBlcyA9IGRlc2NyaXB0b3JzLmNyZWF0ZVR5cGVzQ29sbGVjdGlvbigpO1xuXHRjb25zdCBzdWJ0eXBlcyA9IG5ldyBNYXAoKTtcblxuXHRjb25zdCB0aXRsZSA9IGAke1RZUEVfVElUTEVfUFJFRklYfSR7VHlwZU5hbWV9YDtcblxuXHRjb25maWcgPSBPYmplY3QuYXNzaWduKCB7fSwgY29sbGVjdGlvblsgU3ltYm9sQ29uZmlnIF0sIGNvbmZpZyApO1xuXG5cdGNvbnN0IHR5cGUgPSBPYmplY3QuYXNzaWduKCB0aGlzLCB7XG5cblx0XHRnZXQgY29uc3RydWN0SGFuZGxlciAoKSB7XG5cdFx0XHRyZXR1cm4gY29uc3RydWN0SGFuZGxlcjtcblx0XHR9LFxuXG5cblx0XHRUeXBlTmFtZSxcblx0XHRwcm90byxcblxuXHRcdGlzU3ViVHlwZSxcblx0XHRzdWJ0eXBlcyxcblx0XHRwYXJlbnRUeXBlLFxuXG5cdFx0Y29sbGVjdGlvbixcblxuXHRcdHRpdGxlLFxuXG5cdFx0Y29uZmlnLFxuXG5cdFx0aG9va3MgOiBPYmplY3QuY3JlYXRlKCBudWxsIClcblxuXHR9ICk7XG5cblx0Z2V0U3RhY2suY2FsbCggdGhpcywgYERlZmluaXRpb24gb2YgWyAke1R5cGVOYW1lfSBdIG1hZGUgYXQ6YCwgW10sIGRlZmluZU9yaWdpbiApO1xuXG5cdG9kcCggc3VidHlwZXMsIFN5bWJvbFBhcmVudFR5cGUsIHtcblx0XHRnZXQgKCkge1xuXHRcdFx0cmV0dXJuIHR5cGU7XG5cdFx0fVxuXHR9ICk7XG5cblx0dHlwZXMuc2V0KCBUeXBlTmFtZSwgbmV3IFR5cGVQcm94eSggdHlwZSApICk7XG5cblx0cmV0dXJuIHR5cGVzLmdldCggVHlwZU5hbWUgKTtcblxufSBhcyBDb25zdHJ1Y3RvckZ1bmN0aW9uPFR5cGVEZXNjcmlwdG9ySW5zdGFuY2U+O1xuXG5PYmplY3QuYXNzaWduKCBUeXBlRGVzY3JpcHRvci5wcm90b3R5cGUsIGhvb2tzQXBpICk7XG5cblR5cGVEZXNjcmlwdG9yLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbiAoIC4uLmFyZ3M6IGFueVtdICkge1xuXHRyZXR1cm4gZGVmaW5lLmNhbGwoIGRlZmluZSwgdGhpcy5zdWJ0eXBlcywgLi4uYXJncyApO1xufTtcblxuVHlwZURlc2NyaXB0b3IucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uICggLi4uYXJnczogYW55W10gKSB7XG5cdHJldHVybiBsb29rdXAuY2FsbCggdGhpcy5zdWJ0eXBlcywgLi4uYXJncyApO1xufTtcblxub2RwKCBUeXBlRGVzY3JpcHRvci5wcm90b3R5cGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuXHRnZXQgKCkge1xuXHRcdHJldHVybiBnZXRUeXBlQ2hlY2tlciggdGhpcy5UeXBlTmFtZSApO1xuXHR9XG59ICk7XG5cbmNvbnN0IGRlZmluZVVzaW5nVHlwZSA9IGZ1bmN0aW9uICggdGhpczogYW55LCBzdWJ0eXBlczogYW55LCBjb25zdHJ1Y3RIYW5kbGVyR2V0dGVyOiBDYWxsYWJsZUZ1bmN0aW9uLCBjb25maWc6IGFueSApIHtcblx0Ly8gd2UgbmVlZCB0aGlzIHRvIGV4dHJhY3QgVHlwZU5hbWVcblx0Y29uc3QgdHlwZSA9IGNvbnN0cnVjdEhhbmRsZXJHZXR0ZXIoKTtcblxuXHRpZiAoIHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdHRocm93IG5ldyBIQU5ETEVSX01VU1RfQkVfQV9GVU5DVElPTjtcblx0fVxuXG5cdGNvbnN0IFR5cGVOYW1lID0gdHlwZS5uYW1lO1xuXG5cdGlmICggIVR5cGVOYW1lICkge1xuXHRcdHRocm93IG5ldyBUWVBFTkFNRV9NVVNUX0JFX0FfU1RSSU5HO1xuXHR9XG5cblx0Y29uc3QgYXNDbGFzcyA9IGlzQ2xhc3MoIHR5cGUgKTtcblxuXHRjb25zdCBtYWtlQ29uc3RydWN0SGFuZGxlciA9ICgpID0+IHtcblx0XHRjb25zdCBjb25zdHJ1Y3RIYW5kbGVyID0gY29uc3RydWN0SGFuZGxlckdldHRlcigpO1xuXHRcdC8vIGNvbnN0cnVjdEhhbmRsZXJbU3ltYm9sQ29uc3RydWN0b3JOYW1lXSA9IFR5cGVOYW1lO1xuXHRcdG9kcCggY29uc3RydWN0SGFuZGxlciwgU3ltYm9sQ29uc3RydWN0b3JOYW1lLCB7XG5cdFx0XHRnZXQgKCkge1xuXHRcdFx0XHRyZXR1cm4gVHlwZU5hbWU7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdGNvbnN0IHByb3RvRGVzYzogYW55ID0gT2JqZWN0XG5cdFx0XHQuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCBjb25zdHJ1Y3RIYW5kbGVyLCAncHJvdG90eXBlJyApO1xuXHRcdGlmICggcHJvdG9EZXNjLndyaXRhYmxlICkge1xuXHRcdFx0Y29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUgPSB7fTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvbnN0cnVjdEhhbmRsZXI7XG5cdH07XG5cblx0aWYgKCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyApIHtcblx0XHRjb25maWcgPSBPYmplY3QuYXNzaWduKCB7fSwgY29uZmlnICk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uZmlnID0ge307XG5cdH1cblxuXHRjb25maWcuYXNDbGFzcyA9IGFzQ2xhc3M7XG5cblx0cmV0dXJuIG5ldyBUeXBlRGVzY3JpcHRvcihcblx0XHR0aGlzLFxuXHRcdHN1YnR5cGVzLFxuXHRcdFR5cGVOYW1lLFxuXHRcdG1ha2VDb25zdHJ1Y3RIYW5kbGVyLFxuXHRcdHR5cGUucHJvdG90eXBlLFxuXHRcdGNvbmZpZ1xuXHQpO1xufTtcblxuY29uc3QgZGVmaW5lVXNpbmdGdW5jdGlvbiA9IGZ1bmN0aW9uIChcblx0dGhpczogYW55LFxuXHRzdWJ0eXBlczogYW55LFxuXHRUeXBlTmFtZTogc3RyaW5nLFxuXHRjb25zdHJ1Y3RIYW5kbGVyID0gZnVuY3Rpb24gKCkgeyB9LFxuXHRjb25maWc6IGFueSA9IHt9XG4pIHtcblxuXHRpZiAoIHR5cGVvZiBjb25zdHJ1Y3RIYW5kbGVyICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdHRocm93IG5ldyBIQU5ETEVSX01VU1RfQkVfQV9GVU5DVElPTjtcblx0fVxuXG5cdGNvbnN0IGFzQ2xhc3MgPSBpc0NsYXNzKCBjb25zdHJ1Y3RIYW5kbGVyICk7XG5cdGNvbnN0IG1vZGlmaWNhdG9yQm9keSA9IGNvbXBpbGVOZXdNb2RpZmljYXRvckZ1bmN0aW9uQm9keSggVHlwZU5hbWUsIGFzQ2xhc3MgKTtcblxuXHRjb25zdCBtYWtlQ29uc3RydWN0SGFuZGxlciA9IG1vZGlmaWNhdG9yQm9keShcblx0XHRjb25zdHJ1Y3RIYW5kbGVyLFxuXHRcdENyZWF0aW9uSGFuZGxlcixcblx0XHRTeW1ib2xDb25zdHJ1Y3Rvck5hbWVcblx0KTtcblxuXHRpZiAoIGNvbmZpZyBpbnN0YW5jZW9mIEZ1bmN0aW9uICkge1xuXHRcdGNvbmZpZyA9IHtcblx0XHRcdE1vZGlmaWNhdGlvbkNvbnN0cnVjdG9yIDogY29uZmlnXG5cdFx0fTtcblx0fVxuXG5cdGlmICggdHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcgKSB7XG5cdFx0Y29uZmlnID0ge307XG5cdH1cblxuXG5cdGNvbmZpZy5hc0NsYXNzID0gYXNDbGFzcztcblxuXHRjb25zdCBwcm90byA9IGhvcCggY29uc3RydWN0SGFuZGxlciwgJ3Byb3RvdHlwZScgKSAmJlxuXHRcdCggY29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBPYmplY3QgKSA/XG5cdFx0T2JqZWN0LmFzc2lnbigge30sIGNvbnN0cnVjdEhhbmRsZXIucHJvdG90eXBlICkgOlxuXHRcdHt9O1xuXG5cdHJldHVybiBuZXcgVHlwZURlc2NyaXB0b3IoXG5cdFx0dGhpcyxcblx0XHRzdWJ0eXBlcyxcblx0XHRUeXBlTmFtZSxcblx0XHRtYWtlQ29uc3RydWN0SGFuZGxlcixcblx0XHQvLyBwcm90byBwcm9wIGZvciBUeXBlRGVzY3JpcHRvclxuXHRcdHByb3RvLFxuXHRcdGNvbmZpZ1xuXHQpO1xuXG59O1xuXG5cbmV4cG9ydCBjb25zdCBkZWZpbmU6IGFueSA9IGZ1bmN0aW9uICggdGhpczogYW55LCBzdWJ0eXBlczogYW55LCBUeXBlT3JUeXBlTmFtZTogc3RyaW5nIHwgYW55LCBjb25zdHJ1Y3RIYW5kbGVyT3JDb25maWc6IGFueSwgY29uZmlnOiBvYmplY3QgKSB7XG5cblx0aWYgKCB0eXBlb2YgVHlwZU9yVHlwZU5hbWUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0aWYgKCBUeXBlT3JUeXBlTmFtZS5uYW1lICkge1xuXHRcdFx0cmV0dXJuIGRlZmluZS5jYWxsKCB0aGlzLCBzdWJ0eXBlcywgVHlwZU9yVHlwZU5hbWUubmFtZSwgVHlwZU9yVHlwZU5hbWUsIGNvbmZpZyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZGVmaW5lVXNpbmdUeXBlLmNhbGwoIHRoaXMsIHN1YnR5cGVzLCBUeXBlT3JUeXBlTmFtZSwgY29uc3RydWN0SGFuZGxlck9yQ29uZmlnICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCB0eXBlb2YgVHlwZU9yVHlwZU5hbWUgPT09ICdzdHJpbmcnICkge1xuXG5cdFx0Y2hlY2tUeXBlTmFtZSggVHlwZU9yVHlwZU5hbWUgKTtcblxuXHRcdGNvbnN0IHNwbGl0ID0gZ2V0VHlwZVNwbGl0UGF0aCggVHlwZU9yVHlwZU5hbWUgKTtcblxuXHRcdGNvbnN0IFR5cGUgPSBsb29rdXAuY2FsbCggc3VidHlwZXMsIHNwbGl0WyAwIF0gKTtcblxuXHRcdGlmICggIVR5cGUgKSB7XG5cblx0XHRcdGlmICggc3BsaXQubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZGVmaW5lVXNpbmdGdW5jdGlvbi5jYWxsKCB0aGlzLCBzdWJ0eXBlcywgVHlwZU9yVHlwZU5hbWUsIGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZywgY29uZmlnICk7XG5cdFx0XHR9XG5cblx0XHRcdHRocm93IG5ldyBXUk9OR19UWVBFX0RFRklOSVRJT04oIGAke3NwbGl0WyAwIF19IGRlZmluaXRpb24gaXMgbm90IHlldCBleGlzdHNgICk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgVHlwZU5hbWUgPSBzcGxpdC5zbGljZSggMSApLmpvaW4oICcuJyApO1xuXG5cdFx0aWYgKCBzcGxpdC5sZW5ndGggPiAxICkge1xuXHRcdFx0cmV0dXJuIGRlZmluZS5jYWxsKCB0aGlzLCBUeXBlLnN1YnR5cGVzLCBUeXBlTmFtZSwgY29uc3RydWN0SGFuZGxlck9yQ29uZmlnLCBjb25maWcgKTtcblx0XHR9XG5cblx0XHQvLyBzbywgaGVyZSB3ZSBnbyB3aXRoXG5cdFx0Ly8gZGVmaW5lVXNpbmdUeXBlLmNhbGxcblx0XHQvLyBmcm9tIHRoZSBuZXh0IHN0ZXBcblx0XHRyZXR1cm4gZGVmaW5lLmNhbGwoIHRoaXMsIFR5cGUuc3VidHlwZXMsIGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZywgY29uZmlnICk7XG5cblx0fVxuXG5cdHRocm93IG5ldyBXUk9OR19UWVBFX0RFRklOSVRJT04oICdkZWZpbml0aW9uIGlzIG5vdCBwcm92aWRlZCcgKTtcblxufTtcblxuZXhwb3J0IGNvbnN0IGxvb2t1cDogYW55ID0gZnVuY3Rpb24gKCB0aGlzOiBhbnksIFR5cGVOZXN0ZWRQYXRoOiBzdHJpbmcgKSB7XG5cblx0aWYgKCB0eXBlb2YgVHlwZU5lc3RlZFBhdGggIT09ICdzdHJpbmcnICkge1xuXHRcdHRocm93IG5ldyBXUk9OR19UWVBFX0RFRklOSVRJT04oICdhcmcgOiB0eXBlIG5lc3RlZCBwYXRoIG11c3QgYmUgYSBzdHJpbmcnICk7XG5cdH1cblxuXHRpZiAoICFUeXBlTmVzdGVkUGF0aC5sZW5ndGggKSB7XG5cdFx0dGhyb3cgbmV3IFdST05HX1RZUEVfREVGSU5JVElPTiggJ2FyZyA6IHR5cGUgbmVzdGVkIHBhdGggaGFzIG5vIHBhdGgnICk7XG5cdH1cblxuXHRjb25zdCBzcGxpdCA9IGdldFR5cGVTcGxpdFBhdGgoIFR5cGVOZXN0ZWRQYXRoICk7XG5cblx0Y29uc3QgWyBuYW1lIF0gPSBzcGxpdDtcblx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0KCBuYW1lICk7XG5cdGlmICggc3BsaXQubGVuZ3RoID09PSAxICkge1xuXHRcdHJldHVybiB0eXBlO1xuXHR9XG5cblx0Y29uc3QgTmV4dE5lc3RlZFBhdGggPSBzcGxpdC5zbGljZSggMSApLmpvaW4oICcuJyApO1xuXHRyZXR1cm4gbG9va3VwLmNhbGwoIHR5cGUuc3VidHlwZXMsIE5leHROZXN0ZWRQYXRoICk7XG5cbn07XG5cblxuXG4iXX0=