'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.lookup = exports.define = void 0;
const hop_1 = require("../../utils/hop");
const constants_1 = require("../../constants");
const { odp, SymbolParentType, SymbolConstructorName, SymbolConfig, TYPE_TITLE_PREFIX, MNEMOSYNE, } = constants_1.constants;
const errors_1 = require("../../descriptors/errors");
const { ALREADY_DECLARED, WRONG_TYPE_DEFINITION, TYPENAME_MUST_BE_A_STRING, HANDLER_MUST_BE_A_FUNCTION, } = errors_1.ErrorsTypes;
const hooksApi = require("../hooks");
const TypeProxy_1 = require("./TypeProxy");
const compileNewModificatorFunctionBody_1 = require("./compileNewModificatorFunctionBody");
const utils_1 = require("../utils");
const { getTypeChecker, CreationHandler, getTypeSplitPath, checkTypeName, isClass, } = utils_1.default;
const errors_2 = require("../errors");
const TypeDescriptor = function (defineOrigin, types, TypeName, constructHandler, proto, config) {
    const parentType = types[SymbolParentType] || null;
    const isSubType = parentType ? true : false;
    const collection = isSubType ? parentType.collection : types[MNEMOSYNE];
    if (types.has(TypeName)) {
        throw new ALREADY_DECLARED;
    }
    const subtypes = new Map();
    const title = `${TYPE_TITLE_PREFIX}${TypeName}`;
    config = Object.assign({}, collection[SymbolConfig], config);
    const type = Object.assign(this, {
        get constructHandler() {
            return constructHandler;
        },
        TypeName,
        proto,
        isSubType,
        subtypes,
        parentType,
        collection,
        title,
        config,
        hooks: Object.create(null)
    });
    errors_2.getStack.call(this, `Definition of [ ${TypeName} ] made at:`, [], defineOrigin);
    odp(subtypes, SymbolParentType, {
        get() {
            return type;
        }
    });
    types.set(TypeName, new TypeProxy_1.TypeProxy(type));
    return types.get(TypeName);
};
Object.assign(TypeDescriptor.prototype, hooksApi);
TypeDescriptor.prototype.define = function (...args) {
    return exports.define.call(exports.define, this.subtypes, ...args);
};
TypeDescriptor.prototype.lookup = function (...args) {
    return exports.lookup.call(this.subtypes, ...args);
};
odp(TypeDescriptor.prototype, Symbol.hasInstance, {
    get() {
        return getTypeChecker(this.TypeName);
    }
});
const defineUsingType = function (subtypes, constructHandlerGetter, config) {
    const type = constructHandlerGetter();
    if (typeof type !== 'function') {
        throw new HANDLER_MUST_BE_A_FUNCTION;
    }
    const TypeName = type.name;
    if (!TypeName) {
        throw new TYPENAME_MUST_BE_A_STRING;
    }
    const asClass = isClass(type);
    const makeConstructHandler = () => {
        const constructHandler = constructHandlerGetter();
        odp(constructHandler, SymbolConstructorName, {
            get() {
                return TypeName;
            }
        });
        const protoDesc = Object
            .getOwnPropertyDescriptor(constructHandler, 'prototype');
        if (protoDesc.writable) {
            constructHandler.prototype = {};
        }
        return constructHandler;
    };
    if (typeof config === 'object') {
        config = Object.assign({}, config);
    }
    else {
        config = {};
    }
    config.asClass = asClass;
    return new TypeDescriptor(this, subtypes, TypeName, makeConstructHandler, type.prototype, config);
};
const defineUsingFunction = function (subtypes, TypeName, constructHandler = function () { }, config = {}) {
    if (typeof constructHandler !== 'function') {
        throw new HANDLER_MUST_BE_A_FUNCTION;
    }
    const asClass = isClass(constructHandler);
    const modificatorBody = (0, compileNewModificatorFunctionBody_1.default)(TypeName, asClass);
    const makeConstructHandler = modificatorBody(constructHandler, CreationHandler, SymbolConstructorName);
    if (config instanceof Function) {
        config = {
            ModificationConstructor: config
        };
    }
    if (typeof config !== 'object') {
        config = {};
    }
    config.asClass = asClass;
    const proto = (0, hop_1.hop)(constructHandler, 'prototype') &&
        (constructHandler.prototype instanceof Object) ?
        Object.assign({}, constructHandler.prototype) :
        {};
    return new TypeDescriptor(this, subtypes, TypeName, makeConstructHandler, proto, config);
};
const define = function (subtypes, TypeOrTypeName, constructHandlerOrConfig, config) {
    if (typeof TypeOrTypeName === 'function') {
        if (TypeOrTypeName.name) {
            return exports.define.call(this, subtypes, TypeOrTypeName.name, TypeOrTypeName, constructHandlerOrConfig || TypeOrTypeName.prototype, config);
        }
        else {
            return defineUsingType.call(this, subtypes, TypeOrTypeName, constructHandlerOrConfig);
        }
    }
    if (typeof TypeOrTypeName === 'string') {
        checkTypeName(TypeOrTypeName);
        const split = getTypeSplitPath(TypeOrTypeName);
        const Type = exports.lookup.call(subtypes, split[0]);
        if (!Type) {
            if (split.length === 1) {
                return defineUsingFunction.call(this, subtypes, TypeOrTypeName, constructHandlerOrConfig, config);
            }
            throw new WRONG_TYPE_DEFINITION(`${split[0]} definition is not yet exists`);
        }
        const TypeName = split.slice(1).join('.');
        if (split.length > 1) {
            return exports.define.call(this, Type.subtypes, TypeName, constructHandlerOrConfig, config);
        }
        return exports.define.call(this, Type.subtypes, constructHandlerOrConfig, config);
    }
    throw new WRONG_TYPE_DEFINITION('definition is not provided');
};
exports.define = define;
const lookup = function (TypeNestedPath) {
    if (typeof TypeNestedPath !== 'string') {
        throw new WRONG_TYPE_DEFINITION('arg : type nested path must be a string');
    }
    if (!TypeNestedPath.length) {
        throw new WRONG_TYPE_DEFINITION('arg : type nested path has no path');
    }
    const split = getTypeSplitPath(TypeNestedPath);
    const [name] = split;
    const type = this.get(name);
    if (split.length === 1) {
        return type;
    }
    const NextNestedPath = split.slice(1).join('.');
    return exports.lookup.call(type.subtypes, NextNestedPath);
};
exports.lookup = lookup;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYXBpL3R5cGVzL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7O0FBSWIseUNBQXNDO0FBRXRDLCtDQUE0QztBQUM1QyxNQUFNLEVBQ0wsR0FBRyxFQUNILGdCQUFnQixFQUNoQixxQkFBcUIsRUFDckIsWUFBWSxFQUVaLGlCQUFpQixFQUNqQixTQUFTLEdBRVQsR0FBRyxxQkFBUyxDQUFDO0FBRWQscURBQXVEO0FBR3ZELE1BQU0sRUFDTCxnQkFBZ0IsRUFDaEIscUJBQXFCLEVBQ3JCLHlCQUF5QixFQUN6QiwwQkFBMEIsR0FDMUIsR0FBRyxvQkFBVyxDQUFDO0FBS2hCLHFDQUFxQztBQUNyQywyQ0FBd0M7QUFFeEMsMkZBQW9GO0FBRXBGLG9DQUFrQztBQUNsQyxNQUFNLEVBQ0wsY0FBYyxFQUNkLGVBQWUsRUFDZixnQkFBZ0IsRUFDaEIsYUFBYSxFQUNiLE9BQU8sR0FDUCxHQUFHLGVBQVUsQ0FBQztBQUVmLHNDQUFxQztBQUVyQyxNQUFNLGNBQWMsR0FBRyxVQUV0QixZQUE4QixFQUM5QixLQUFVLEVBQ1YsUUFBZ0IsRUFDaEIsZ0JBQWtDLEVBQ2xDLEtBQXFDLEVBQ3JDLE1BQXNDO0lBS3RDLE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBRSxnQkFBZ0IsQ0FBRSxJQUFJLElBQUksQ0FBQztJQUVyRCxNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBRTVDLE1BQU0sVUFBVSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFFLFNBQVMsQ0FBRSxDQUFDO0lBRTFFLElBQUssS0FBSyxDQUFDLEdBQUcsQ0FBRSxRQUFRLENBQUUsRUFBRyxDQUFDO1FBQzdCLE1BQU0sSUFBSSxnQkFBZ0IsQ0FBQztJ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QUFjLENBQUMsTUFBTSxFQUFHLENBQUM7UUFDOUIsTUFBTSxJQUFJLHFCQUFxQixDQUFFLG9DQUFvQyxDQUFFLENBQUM7SUFDekUsQ0FBQztJQUVELE1BQU0sS0FBSyxHQUFHLGdCQUFnQixDQUFFLGNBQWMsQ0FBRSxDQUFDO0lBRWpELE1BQU0sQ0FBRSxJQUFJLENBQUUsR0FBRyxLQUFLLENBQUM7SUFDdkIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBRSxJQUFJLENBQUUsQ0FBQztJQUM5QixJQUFLLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFHLENBQUM7UUFDMUIsT0FBTyxJQUFJLENBQUM7SUFDYixDQUFDO0lBRUQsTUFBTSxjQUFjLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBRSxDQUFDLENBQUUsQ0FBQyxJQUFJLENBQUUsR0FBRyxDQUFFLENBQUM7SUFDcEQsT0FBTyxjQUFNLENBQUMsSUFBSSxDQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsY0FBYyxDQUFFLENBQUM7QUFFckQsQ0FBQyxDQUFDO0FBckJXLFFBQUEsTUFBTSxVQXFCakIiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IENvbnN0cnVjdG9yRnVuY3Rpb24sIFR5cGVEZXNjcmlwdG9ySW5zdGFuY2UgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5cbmltcG9ydCB7IGhvcCB9IGZyb20gJy4uLy4uL3V0aWxzL2hvcCc7XG5cbmltcG9ydCB7IGNvbnN0YW50cyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5jb25zdCB7XG5cdG9kcCxcblx0U3ltYm9sUGFyZW50VHlwZSxcblx0U3ltYm9sQ29uc3RydWN0b3JOYW1lLFxuXHRTeW1ib2xDb25maWcsXG5cblx0VFlQRV9USVRMRV9QUkVGSVgsXG5cdE1ORU1PU1lORSxcblxufSA9IGNvbnN0YW50cztcblxuaW1wb3J0IHsgRXJyb3JzVHlwZXMgfSBmcm9tICcuLi8uLi9kZXNjcmlwdG9ycy9lcnJvcnMnO1xuLy8gaW1wb3J0IHsgZGVzY3JpcHRvcnMgfSBmcm9tICcuLi8uLi9kZXNjcmlwdG9ycyc7XG5cbmNvbnN0IHtcblx0QUxSRUFEWV9ERUNMQVJFRCxcblx0V1JPTkdfVFlQRV9ERUZJTklUSU9OLFxuXHRUWVBFTkFNRV9NVVNUX0JFX0FfU1RSSU5HLFxuXHRIQU5ETEVSX01VU1RfQkVfQV9GVU5DVElPTixcbn0gPSBFcnJvcnNUeXBlcztcblxuLy8gaW52b2tlSG9va1xuLy8gcmVnaXN0ZXJIb29rXG4vLyByZWdpc3RlckZsb3dDaGVja2VyXG5pbXBvcnQgKiBhcyBob29rc0FwaSBmcm9tICcuLi9ob29rcyc7XG5pbXBvcnQgeyBUeXBlUHJveHkgfSBmcm9tICcuL1R5cGVQcm94eSc7XG5cbmltcG9ydCBjb21waWxlTmV3TW9kaWZpY2F0b3JGdW5jdGlvbkJvZHkgZnJvbSAnLi9jb21waWxlTmV3TW9kaWZpY2F0b3JGdW5jdGlvbkJvZHknO1xuXG5pbXBvcnQgVHlwZXNVdGlscyBmcm9tICcuLi91dGlscyc7XG5jb25zdCB7XG5cdGdldFR5cGVDaGVja2VyLFxuXHRDcmVhdGlvbkhhbmRsZXIsXG5cdGdldFR5cGVTcGxpdFBhdGgsXG5cdGNoZWNrVHlwZU5hbWUsXG5cdGlzQ2xhc3MsXG59ID0gVHlwZXNVdGlscztcblxuaW1wb3J0IHsgZ2V0U3RhY2sgfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5jb25zdCBUeXBlRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChcblx0dGhpczogYW55LFxuXHRkZWZpbmVPcmlnaW46IENhbGxhYmxlRnVuY3Rpb24sXG5cdHR5cGVzOiBhbnksXG5cdFR5cGVOYW1lOiBzdHJpbmcsXG5cdGNvbnN0cnVjdEhhbmRsZXI6IENhbGxhYmxlRnVuY3Rpb24sXG5cdHByb3RvOiB7IFsgaW5kZXg6IHN0cmluZyBdOiB1bmtub3duIH0sXG5cdGNvbmZpZzogeyBbIGluZGV4OiBzdHJpbmcgXTogdW5rbm93biB9LFxuKSB7XG5cblx0Ly8gaGVyZSBcInR5cGVzXCIgcmVmZXJzIHRvIHN1YnR5cGVzIG9mIHR5cGUgb3IgY29sbGVjdGlvbiBvYmplY3Qge31cblxuXHRjb25zdCBwYXJlbnRUeXBlID0gdHlwZXNbIFN5bWJvbFBhcmVudFR5cGUgXSB8fCBudWxsO1xuXG5cdGNvbnN0IGlzU3ViVHlwZSA9IHBhcmVudFR5cGUgPyB0cnVlIDogZmFsc2U7XG5cblx0Y29uc3QgY29sbGVjdGlvbiA9IGlzU3ViVHlwZSA/IHBhcmVudFR5cGUuY29sbGVjdGlvbiA6IHR5cGVzWyBNTkVNT1NZTkUgXTtcblxuXHRpZiAoIHR5cGVzLmhhcyggVHlwZU5hbWUgKSApIHtcblx0XHR0aHJvdyBuZXcgQUxSRUFEWV9ERUNMQVJFRDtcblx0fVxuXG5cdC8vIGNvbnN0IHN1YnR5cGVzID0gZGVzY3JpcHRvcnMuY3JlYXRlVHlwZXNDb2xsZWN0aW9uKCk7XG5cdGNvbnN0IHN1YnR5cGVzID0gbmV3IE1hcCgpO1xuXG5cdGNvbnN0IHRpdGxlID0gYCR7VFlQRV9USVRMRV9QUkVGSVh9JHtUeXBlTmFtZX1gO1xuXG5cdGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oIHt9LCBjb2xsZWN0aW9uWyBTeW1ib2xDb25maWcgXSwgY29uZmlnICk7XG5cblx0Y29uc3QgdHlwZSA9IE9iamVjdC5hc3NpZ24oIHRoaXMsIHtcblxuXHRcdGdldCBjb25zdHJ1Y3RIYW5kbGVyICgpIHtcblx0XHRcdHJldHVybiBjb25zdHJ1Y3RIYW5kbGVyO1xuXHRcdH0sXG5cblxuXHRcdFR5cGVOYW1lLFxuXHRcdHByb3RvLFxuXG5cdFx0aXNTdWJUeXBlLFxuXHRcdHN1YnR5cGVzLFxuXHRcdHBhcmVudFR5cGUsXG5cblx0XHRjb2xsZWN0aW9uLFxuXG5cdFx0dGl0bGUsXG5cblx0XHRjb25maWcsXG5cblx0XHRob29rcyA6IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXG5cdH0gKTtcblxuXHRnZXRTdGFjay5jYWxsKCB0aGlzLCBgRGVmaW5pdGlvbiBvZiBbICR7VHlwZU5hbWV9IF0gbWFkZSBhdDpgLCBbXSwgZGVmaW5lT3JpZ2luICk7XG5cblx0b2RwKCBzdWJ0eXBlcywgU3ltYm9sUGFyZW50VHlwZSwge1xuXHRcdGdldCAoKSB7XG5cdFx0XHRyZXR1cm4gdHlwZTtcblx0XHR9XG5cdH0gKTtcblxuXHR0eXBlcy5zZXQoIFR5cGVOYW1lLCBuZXcgVHlwZVByb3h5KCB0eXBlICkgKTtcblxuXHRyZXR1cm4gdHlwZXMuZ2V0KCBUeXBlTmFtZSApO1xuXG59IGFzIENvbnN0cnVjdG9yRnVuY3Rpb248VHlwZURlc2NyaXB0b3JJbnN0YW5jZT47XG5cbk9iamVjdC5hc3NpZ24oIFR5cGVEZXNjcmlwdG9yLnByb3RvdHlwZSwgaG9va3NBcGkgKTtcblxuVHlwZURlc2NyaXB0b3IucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uICggLi4uYXJnczogYW55W10gKSB7XG5cdHJldHVybiBkZWZpbmUuY2FsbCggZGVmaW5lLCB0aGlzLnN1YnR5cGVzLCAuLi5hcmdzICk7XG59O1xuXG5UeXBlRGVzY3JpcHRvci5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gKCAuLi5hcmdzOiBhbnlbXSApIHtcblx0cmV0dXJuIGxvb2t1cC5jYWxsKCB0aGlzLnN1YnR5cGVzLCAuLi5hcmdzICk7XG59O1xuXG5vZHAoIFR5cGVEZXNjcmlwdG9yLnByb3RvdHlwZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG5cdGdldCAoKSB7XG5cdFx0cmV0dXJuIGdldFR5cGVDaGVja2VyKCB0aGlzLlR5cGVOYW1lICk7XG5cdH1cbn0gKTtcblxuY29uc3QgZGVmaW5lVXNpbmdUeXBlID0gZnVuY3Rpb24gKCB0aGlzOiBhbnksIHN1YnR5cGVzOiBhbnksIGNvbnN0cnVjdEhhbmRsZXJHZXR0ZXI6IENhbGxhYmxlRnVuY3Rpb24sIGNvbmZpZzogYW55ICkge1xuXHQvLyB3ZSBuZWVkIHRoaXMgdG8gZXh0cmFjdCBUeXBlTmFtZVxuXHRjb25zdCB0eXBlID0gY29uc3RydWN0SGFuZGxlckdldHRlcigpO1xuXG5cdGlmICggdHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0dGhyb3cgbmV3IEhBTkRMRVJfTVVTVF9CRV9BX0ZVTkNUSU9OO1xuXHR9XG5cblx0Y29uc3QgVHlwZU5hbWUgPSB0eXBlLm5hbWU7XG5cblx0aWYgKCAhVHlwZU5hbWUgKSB7XG5cdFx0dGhyb3cgbmV3IFRZUEVOQU1FX01VU1RfQkVfQV9TVFJJTkc7XG5cdH1cblxuXHRjb25zdCBhc0NsYXNzID0gaXNDbGFzcyggdHlwZSApO1xuXG5cdGNvbnN0IG1ha2VDb25zdHJ1Y3RIYW5kbGVyID0gKCkgPT4ge1xuXHRcdGNvbnN0IGNvbnN0cnVjdEhhbmRsZXIgPSBjb25zdHJ1Y3RIYW5kbGVyR2V0dGVyKCk7XG5cdFx0Ly8gY29uc3RydWN0SGFuZGxlcltTeW1ib2xDb25zdHJ1Y3Rvck5hbWVdID0gVHlwZU5hbWU7XG5cdFx0b2RwKCBjb25zdHJ1Y3RIYW5kbGVyLCBTeW1ib2xDb25zdHJ1Y3Rvck5hbWUsIHtcblx0XHRcdGdldCAoKSB7XG5cdFx0XHRcdHJldHVybiBUeXBlTmFtZTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0Y29uc3QgcHJvdG9EZXNjOiBhbnkgPSBPYmplY3Rcblx0XHRcdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIGNvbnN0cnVjdEhhbmRsZXIsICdwcm90b3R5cGUnICk7XG5cdFx0aWYgKCBwcm90b0Rlc2Mud3JpdGFibGUgKSB7XG5cdFx0XHRjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSA9IHt9O1xuXHRcdH1cblx0XHRyZXR1cm4gY29uc3RydWN0SGFuZGxlcjtcblx0fTtcblxuXHRpZiAoIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICkge1xuXHRcdGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oIHt9LCBjb25maWcgKTtcblx0fSBlbHNlIHtcblx0XHRjb25maWcgPSB7fTtcblx0fVxuXG5cdGNvbmZpZy5hc0NsYXNzID0gYXNDbGFzcztcblxuXHRyZXR1cm4gbmV3IFR5cGVEZXNjcmlwdG9yKFxuXHRcdHRoaXMsXG5cdFx0c3VidHlwZXMsXG5cdFx0VHlwZU5hbWUsXG5cdFx0bWFrZUNvbnN0cnVjdEhhbmRsZXIsXG5cdFx0dHlwZS5wcm90b3R5cGUsXG5cdFx0Y29uZmlnXG5cdCk7XG59O1xuXG5jb25zdCBkZWZpbmVVc2luZ0Z1bmN0aW9uID0gZnVuY3Rpb24gKFxuXHR0aGlzOiBhbnksXG5cdHN1YnR5cGVzOiBhbnksXG5cdFR5cGVOYW1lOiBzdHJpbmcsXG5cdGNvbnN0cnVjdEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7IH0sXG5cdGNvbmZpZzogYW55ID0ge31cbikge1xuXG5cdGlmICggdHlwZW9mIGNvbnN0cnVjdEhhbmRsZXIgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0dGhyb3cgbmV3IEhBTkRMRVJfTVVTVF9CRV9BX0ZVTkNUSU9OO1xuXHR9XG5cblx0Y29uc3QgYXNDbGFzcyA9IGlzQ2xhc3MoIGNvbnN0cnVjdEhhbmRsZXIgKTtcblx0Y29uc3QgbW9kaWZpY2F0b3JCb2R5ID0gY29tcGlsZU5ld01vZGlmaWNhdG9yRnVuY3Rpb25Cb2R5KCBUeXBlTmFtZSwgYXNDbGFzcyApO1xuXG5cdGNvbnN0IG1ha2VDb25zdHJ1Y3RIYW5kbGVyID0gbW9kaWZpY2F0b3JCb2R5KFxuXHRcdGNvbnN0cnVjdEhhbmRsZXIsXG5cdFx0Q3JlYXRpb25IYW5kbGVyLFxuXHRcdFN5bWJvbENvbnN0cnVjdG9yTmFtZVxuXHQpO1xuXG5cdGlmICggY29uZmlnIGluc3RhbmNlb2YgRnVuY3Rpb24gKSB7XG5cdFx0Y29uZmlnID0ge1xuXHRcdFx0TW9kaWZpY2F0aW9uQ29uc3RydWN0b3IgOiBjb25maWdcblx0XHR9O1xuXHR9XG5cblx0aWYgKCB0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0JyApIHtcblx0XHRjb25maWcgPSB7fTtcblx0fVxuXG5cblx0Y29uZmlnLmFzQ2xhc3MgPSBhc0NsYXNzO1xuXG5cdGNvbnN0IHByb3RvID0gaG9wKCBjb25zdHJ1Y3RIYW5kbGVyLCAncHJvdG90eXBlJyApICYmXG5cdFx0KCBjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIE9iamVjdCApID9cblx0XHRPYmplY3QuYXNzaWduKCB7fSwgY29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUgKSA6XG5cdFx0e307XG5cblx0cmV0dXJuIG5ldyBUeXBlRGVzY3JpcHRvcihcblx0XHR0aGlzLFxuXHRcdHN1YnR5cGVzLFxuXHRcdFR5cGVOYW1lLFxuXHRcdG1ha2VDb25zdHJ1Y3RIYW5kbGVyLFxuXHRcdC8vIHByb3RvIHByb3AgZm9yIFR5cGVEZXNjcmlwdG9yXG5cdFx0cHJvdG8sXG5cdFx0Y29uZmlnXG5cdCk7XG5cbn07XG5cblxuZXhwb3J0IGNvbnN0IGRlZmluZTogYW55ID0gZnVuY3Rpb24gKCB0aGlzOiBhbnksIHN1YnR5cGVzOiBhbnksIFR5cGVPclR5cGVOYW1lOiBzdHJpbmcgfCBhbnksIGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZzogYW55LCBjb25maWc6IG9iamVjdCApIHtcblxuXHRpZiAoIHR5cGVvZiBUeXBlT3JUeXBlTmFtZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRpZiAoIFR5cGVPclR5cGVOYW1lLm5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gZGVmaW5lLmNhbGwoIHRoaXMsIHN1YnR5cGVzLCBUeXBlT3JUeXBlTmFtZS5uYW1lLCBUeXBlT3JUeXBlTmFtZSwgY29uc3RydWN0SGFuZGxlck9yQ29uZmlnIHx8IFR5cGVPclR5cGVOYW1lLnByb3RvdHlwZSwgY29uZmlnICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBkZWZpbmVVc2luZ1R5cGUuY2FsbCggdGhpcywgc3VidHlwZXMsIFR5cGVPclR5cGVOYW1lLCBjb25zdHJ1Y3RIYW5kbGVyT3JDb25maWcgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIHR5cGVvZiBUeXBlT3JUeXBlTmFtZSA9PT0gJ3N0cmluZycgKSB7XG5cblx0XHRjaGVja1R5cGVOYW1lKCBUeXBlT3JUeXBlTmFtZSApO1xuXG5cdFx0Y29uc3Qgc3BsaXQgPSBnZXRUeXBlU3BsaXRQYXRoKCBUeXBlT3JUeXBlTmFtZSApO1xuXG5cdFx0Y29uc3QgVHlwZSA9IGxvb2t1cC5jYWxsKCBzdWJ0eXBlcywgc3BsaXRbIDAgXSApO1xuXG5cdFx0aWYgKCAhVHlwZSApIHtcblxuXHRcdFx0aWYgKCBzcGxpdC5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBkZWZpbmVVc2luZ0Z1bmN0aW9uLmNhbGwoIHRoaXMsIHN1YnR5cGVzLCBUeXBlT3JUeXBlTmFtZSwgY29uc3RydWN0SGFuZGxlck9yQ29uZmlnLCBjb25maWcgKTtcblx0XHRcdH1cblxuXHRcdFx0dGhyb3cgbmV3IFdST05HX1RZUEVfREVGSU5JVElPTiggYCR7c3BsaXRbIDAgXX0gZGVmaW5pdGlvbiBpcyBub3QgeWV0IGV4aXN0c2AgKTtcblx0XHR9XG5cblx0XHRjb25zdCBUeXBlTmFtZSA9IHNwbGl0LnNsaWNlKCAxICkuam9pbiggJy4nICk7XG5cblx0XHRpZiAoIHNwbGl0Lmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRyZXR1cm4gZGVmaW5lLmNhbGwoIHRoaXMsIFR5cGUuc3VidHlwZXMsIFR5cGVOYW1lLCBjb25zdHJ1Y3RIYW5kbGVyT3JDb25maWcsIGNvbmZpZyApO1xuXHRcdH1cblxuXHRcdC8vIHNvLCBoZXJlIHdlIGdvIHdpdGhcblx0XHQvLyBkZWZpbmVVc2luZ1R5cGUuY2FsbFxuXHRcdC8vIGZyb20gdGhlIG5leHQgc3RlcFxuXHRcdHJldHVybiBkZWZpbmUuY2FsbCggdGhpcywgVHlwZS5zdWJ0eXBlcywgY29uc3RydWN0SGFuZGxlck9yQ29uZmlnLCBjb25maWcgKTtcblxuXHR9XG5cblx0dGhyb3cgbmV3IFdST05HX1RZUEVfREVGSU5JVElPTiggJ2RlZmluaXRpb24gaXMgbm90IHByb3ZpZGVkJyApO1xuXG59O1xuXG5leHBvcnQgY29uc3QgbG9va3VwOiBhbnkgPSBmdW5jdGlvbiAoIHRoaXM6IGFueSwgVHlwZU5lc3RlZFBhdGg6IHN0cmluZyApIHtcblxuXHRpZiAoIHR5cGVvZiBUeXBlTmVzdGVkUGF0aCAhPT0gJ3N0cmluZycgKSB7XG5cdFx0dGhyb3cgbmV3IFdST05HX1RZUEVfREVGSU5JVElPTiggJ2FyZyA6IHR5cGUgbmVzdGVkIHBhdGggbXVzdCBiZSBhIHN0cmluZycgKTtcblx0fVxuXG5cdGlmICggIVR5cGVOZXN0ZWRQYXRoLmxlbmd0aCApIHtcblx0XHR0aHJvdyBuZXcgV1JPTkdfVFlQRV9ERUZJTklUSU9OKCAnYXJnIDogdHlwZSBuZXN0ZWQgcGF0aCBoYXMgbm8gcGF0aCcgKTtcblx0fVxuXG5cdGNvbnN0IHNwbGl0ID0gZ2V0VHlwZVNwbGl0UGF0aCggVHlwZU5lc3RlZFBhdGggKTtcblxuXHRjb25zdCBbIG5hbWUgXSA9IHNwbGl0O1xuXHRjb25zdCB0eXBlID0gdGhpcy5nZXQoIG5hbWUgKTtcblx0aWYgKCBzcGxpdC5sZW5ndGggPT09IDEgKSB7XG5cdFx0cmV0dXJuIHR5cGU7XG5cdH1cblxuXHRjb25zdCBOZXh0TmVzdGVkUGF0aCA9IHNwbGl0LnNsaWNlKCAxICkuam9pbiggJy4nICk7XG5cdHJldHVybiBsb29rdXAuY2FsbCggdHlwZS5zdWJ0eXBlcywgTmV4dE5lc3RlZFBhdGggKTtcblxufTtcblxuXG5cbiJdfQ==