'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.lookup = exports.define = void 0;
const hop_1 = require("../../utils/hop");
const constants_1 = require("../../constants");
const { odp, SymbolParentType, SymbolConstructorName, SymbolConfig, TYPE_TITLE_PREFIX, MNEMOSYNE, } = constants_1.constants;
const errors_1 = require("../../descriptors/errors");
const Mnemosyne_1 = require("./Mnemosyne");
const { getDefaultPrototype } = Mnemosyne_1.default;
const { ALREADY_DECLARED, WRONG_TYPE_DEFINITION, TYPENAME_MUST_BE_A_STRING, HANDLER_MUST_BE_A_FUNCTION, } = errors_1.ErrorsTypes;
const hooksApi = require("../hooks");
const TypeProxy_1 = require("./TypeProxy");
const compileNewModificatorFunctionBody_1 = require("./compileNewModificatorFunctionBody");
const utils_1 = require("../utils");
const { getTypeChecker, CreationHandler, getTypeSplitPath, checkTypeName, isClass, } = utils_1.default;
const errors_2 = require("../errors");
const TypeDescriptor = function (defineOrigin, types, TypeName, constructHandler, proto, config) {
    const parentType = types[SymbolParentType] || null;
    const isSubType = parentType ? true : false;
    const collection = isSubType ? parentType.collection : types[MNEMOSYNE];
    if (types.has(TypeName)) {
        throw new ALREADY_DECLARED;
    }
    const subtypes = new Map();
    const title = `${TYPE_TITLE_PREFIX}${TypeName}`;
    config = Object.assign({}, collection[SymbolConfig], config);
    const type = Object.assign(this, {
        get constructHandler() {
            return constructHandler;
        },
        TypeName,
        proto,
        isSubType,
        subtypes,
        parentType,
        collection,
        title,
        config,
        hooks: Object.create(null)
    });
    errors_2.getStack.call(this, `Definition of [ ${TypeName} ] made at:`, [], defineOrigin);
    odp(subtypes, SymbolParentType, {
        get() {
            return type;
        }
    });
    const Uranus = isSubType ? undefined : proto;
    types.set(TypeName, new TypeProxy_1.TypeProxy(type, Uranus));
    return types.get(TypeName);
};
Object.assign(TypeDescriptor.prototype, hooksApi);
TypeDescriptor.prototype.define = function (...args) {
    return exports.define.call(exports.define, this.subtypes, ...args);
};
TypeDescriptor.prototype.lookup = function (...args) {
    return exports.lookup.call(this.subtypes, ...args);
};
odp(TypeDescriptor.prototype, Symbol.hasInstance, {
    get() {
        return getTypeChecker(this.TypeName);
    }
});
const defineUsingType = function (subtypes, constructHandlerGetter, config) {
    const type = constructHandlerGetter();
    if (typeof type !== 'function') {
        throw new HANDLER_MUST_BE_A_FUNCTION;
    }
    const TypeName = type.name;
    if (!TypeName) {
        throw new TYPENAME_MUST_BE_A_STRING;
    }
    const asClass = isClass(type);
    const makeConstructHandler = () => {
        const constructHandler = constructHandlerGetter();
        odp(constructHandler, SymbolConstructorName, {
            get() {
                return TypeName;
            }
        });
        const protoDesc = Object
            .getOwnPropertyDescriptor(constructHandler, 'prototype');
        if (protoDesc.writable) {
            constructHandler.prototype = getDefaultPrototype();
        }
        return constructHandler;
    };
    if (typeof config === 'object') {
        config = Object.assign({}, config);
    }
    else {
        config = {};
    }
    config.asClass = asClass;
    return new TypeDescriptor(this, subtypes, TypeName, makeConstructHandler, type.prototype, config);
};
const defineUsingFunction = function (subtypes, TypeName, constructHandler = function () { }, config = {}) {
    if (typeof constructHandler !== 'function') {
        throw new HANDLER_MUST_BE_A_FUNCTION;
    }
    const asClass = isClass(constructHandler);
    const modificatorBody = (0, compileNewModificatorFunctionBody_1.default)(TypeName, asClass);
    const makeConstructHandler = modificatorBody(constructHandler, CreationHandler, SymbolConstructorName);
    if (config instanceof Function) {
        config = {
            ModificationConstructor: config
        };
    }
    if (typeof config !== 'object') {
        config = {};
    }
    config.asClass = asClass;
    const proto = ((0, hop_1.hop)(constructHandler, 'prototype') &&
        (constructHandler.prototype instanceof Object)) ? constructHandler.prototype : getDefaultPrototype();
    return new TypeDescriptor(this, subtypes, TypeName, makeConstructHandler, proto, config);
};
const define = function (subtypes, TypeOrTypeName, constructHandlerOrConfig, config) {
    if (typeof TypeOrTypeName === 'function') {
        if (TypeOrTypeName.name) {
            return exports.define.call(this, subtypes, TypeOrTypeName.name, TypeOrTypeName, config);
        }
        else {
            return defineUsingType.call(this, subtypes, TypeOrTypeName, constructHandlerOrConfig);
        }
    }
    if (typeof TypeOrTypeName === 'string') {
        checkTypeName(TypeOrTypeName);
        const split = getTypeSplitPath(TypeOrTypeName);
        const Type = exports.lookup.call(subtypes, split[0]);
        if (!Type) {
            if (split.length === 1) {
                return defineUsingFunction.call(this, subtypes, TypeOrTypeName, constructHandlerOrConfig, config);
            }
            throw new WRONG_TYPE_DEFINITION(`${split[0]} definition is not yet exists`);
        }
        const TypeName = split.slice(1).join('.');
        if (split.length > 1) {
            return exports.define.call(this, Type.subtypes, TypeName, constructHandlerOrConfig, config);
        }
        return exports.define.call(this, Type.subtypes, constructHandlerOrConfig, config);
    }
    throw new WRONG_TYPE_DEFINITION('definition is not provided');
};
exports.define = define;
const lookup = function (TypeNestedPath) {
    if (typeof TypeNestedPath !== 'string') {
        throw new WRONG_TYPE_DEFINITION('arg : type nested path must be a string');
    }
    if (!TypeNestedPath.length) {
        throw new WRONG_TYPE_DEFINITION('arg : type nested path has no path');
    }
    const split = getTypeSplitPath(TypeNestedPath);
    const [name] = split;
    const type = this.get(name);
    if (split.length === 1) {
        return type;
    }
    const NextNestedPath = split.slice(1).join('.');
    return exports.lookup.call(type.subtypes, NextNestedPath);
};
exports.lookup = lookup;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYXBpL3R5cGVzL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7O0FBSWIseUNBQXNDO0FBRXRDLCtDQUE0QztBQUM1QyxNQUFNLEVBQ0wsR0FBRyxFQUNILGdCQUFnQixFQUNoQixxQkFBcUIsRUFDckIsWUFBWSxFQUVaLGlCQUFpQixFQUNqQixTQUFTLEdBRVQsR0FBRyxxQkFBUyxDQUFDO0FBRWQscURBQXVEO0FBR3ZELDJDQUFxQztBQUNyQyxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsR0FBRyxtQkFBVSxDQUFDO0FBRTNDLE1BQU0sRUFDTCxnQkFBZ0IsRUFDaEIscUJBQXFCLEVBQ3JCLHlCQUF5QixFQUN6QiwwQkFBMEIsR0FDMUIsR0FBRyxvQkFBVyxDQUFDO0FBS2hCLHFDQUFxQztBQUNyQywyQ0FBd0M7QUFFeEMsMkZBQW9GO0FBRXBGLG9DQUFrQztBQUNsQyxNQUFNLEVBQ0wsY0FBYyxFQUNkLGVBQWUsRUFDZixnQkFBZ0IsRUFDaEIsYUFBYSxFQUNiLE9BQU8sR0FDUCxHQUFHLGVBQVUsQ0FBQztBQUVmLHNDQUFxQztBQUVyQyxNQUFNLGNBQWMsR0FBRyxVQUV0QixZQUE4QixFQUM5QixLQUFVLEVBQ1YsUUFBZ0IsRUFDaEIsZ0JBQWtDLEVBQ2xDLEtBQXFDLEVBQ3JDLE1BQXNDO0lBS3RDLE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBRSxnQkFBZ0IsQ0FBRSxJQUFJLElBQUksQ0FBQztJQUVyRCxNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBRTVDLE1BQU0sVUFBVSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFFLFNBQVMsQ0FBRSxDQUFDO0lBRTFFLElBQUssS0FBSyxDQUFDLEdB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QWMsS0FBSyxRQUFRLEVBQUcsQ0FBQztRQUMxQyxNQUFNLElBQUkscUJBQXFCLENBQUUseUNBQXlDLENBQUUsQ0FBQztJQUM5RSxDQUFDO0lBRUQsSUFBSyxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUcsQ0FBQztRQUM5QixNQUFNLElBQUkscUJBQXFCLENBQUUsb0NBQW9DLENBQUUsQ0FBQztJQUN6RSxDQUFDO0lBRUQsTUFBTSxLQUFLLEdBQUcsZ0JBQWdCLENBQUUsY0FBYyxDQUFFLENBQUM7SUFFakQsTUFBTSxDQUFFLElBQUksQ0FBRSxHQUFHLEtBQUssQ0FBQztJQUN2QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFFLElBQUksQ0FBRSxDQUFDO0lBQzlCLElBQUssS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUcsQ0FBQztRQUMxQixPQUFPLElBQUksQ0FBQztJQUNiLENBQUM7SUFFRCxNQUFNLGNBQWMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFFLENBQUMsQ0FBRSxDQUFDLElBQUksQ0FBRSxHQUFHLENBQUUsQ0FBQztJQUNwRCxPQUFPLGNBQU0sQ0FBQyxJQUFJLENBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxjQUFjLENBQUUsQ0FBQztBQUVyRCxDQUFDLENBQUM7QUFyQlcsUUFBQSxNQUFNLFVBcUJqQiIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgQ29uc3RydWN0b3JGdW5jdGlvbiwgVHlwZURlc2NyaXB0b3JJbnN0YW5jZSB9IGZyb20gJy4uLy4uL3R5cGVzJztcblxuaW1wb3J0IHsgaG9wIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9wJztcblxuaW1wb3J0IHsgY29uc3RhbnRzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmNvbnN0IHtcblx0b2RwLFxuXHRTeW1ib2xQYXJlbnRUeXBlLFxuXHRTeW1ib2xDb25zdHJ1Y3Rvck5hbWUsXG5cdFN5bWJvbENvbmZpZyxcblxuXHRUWVBFX1RJVExFX1BSRUZJWCxcblx0TU5FTU9TWU5FLFxuXG59ID0gY29uc3RhbnRzO1xuXG5pbXBvcnQgeyBFcnJvcnNUeXBlcyB9IGZyb20gJy4uLy4uL2Rlc2NyaXB0b3JzL2Vycm9ycyc7XG4vLyBpbXBvcnQgeyBkZXNjcmlwdG9ycyB9IGZyb20gJy4uLy4uL2Rlc2NyaXB0b3JzJztcblxuaW1wb3J0IG1uZW1vc3luZXMgZnJvbSAnLi9NbmVtb3N5bmUnO1xuY29uc3QgeyBnZXREZWZhdWx0UHJvdG90eXBlIH0gPSBtbmVtb3N5bmVzO1xuXG5jb25zdCB7XG5cdEFMUkVBRFlfREVDTEFSRUQsXG5cdFdST05HX1RZUEVfREVGSU5JVElPTixcblx0VFlQRU5BTUVfTVVTVF9CRV9BX1NUUklORyxcblx0SEFORExFUl9NVVNUX0JFX0FfRlVOQ1RJT04sXG59ID0gRXJyb3JzVHlwZXM7XG5cbi8vIGludm9rZUhvb2tcbi8vIHJlZ2lzdGVySG9va1xuLy8gcmVnaXN0ZXJGbG93Q2hlY2tlclxuaW1wb3J0ICogYXMgaG9va3NBcGkgZnJvbSAnLi4vaG9va3MnO1xuaW1wb3J0IHsgVHlwZVByb3h5IH0gZnJvbSAnLi9UeXBlUHJveHknO1xuXG5pbXBvcnQgY29tcGlsZU5ld01vZGlmaWNhdG9yRnVuY3Rpb25Cb2R5IGZyb20gJy4vY29tcGlsZU5ld01vZGlmaWNhdG9yRnVuY3Rpb25Cb2R5JztcblxuaW1wb3J0IFR5cGVzVXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuY29uc3Qge1xuXHRnZXRUeXBlQ2hlY2tlcixcblx0Q3JlYXRpb25IYW5kbGVyLFxuXHRnZXRUeXBlU3BsaXRQYXRoLFxuXHRjaGVja1R5cGVOYW1lLFxuXHRpc0NsYXNzLFxufSA9IFR5cGVzVXRpbHM7XG5cbmltcG9ydCB7IGdldFN0YWNrIH0gZnJvbSAnLi4vZXJyb3JzJztcblxuY29uc3QgVHlwZURlc2NyaXB0b3IgPSBmdW5jdGlvbiAoXG5cdHRoaXM6IGFueSxcblx0ZGVmaW5lT3JpZ2luOiBDYWxsYWJsZUZ1bmN0aW9uLFxuXHR0eXBlczogYW55LFxuXHRUeXBlTmFtZTogc3RyaW5nLFxuXHRjb25zdHJ1Y3RIYW5kbGVyOiBDYWxsYWJsZUZ1bmN0aW9uLFxuXHRwcm90bzogeyBbIGluZGV4OiBzdHJpbmcgXTogdW5rbm93biB9LFxuXHRjb25maWc6IHsgWyBpbmRleDogc3RyaW5nIF06IHVua25vd24gfSxcbikge1xuXG5cdC8vIGhlcmUgXCJ0eXBlc1wiIHJlZmVycyB0byBzdWJ0eXBlcyBvZiB0eXBlIG9yIGNvbGxlY3Rpb24gb2JqZWN0IHt9XG5cblx0Y29uc3QgcGFyZW50VHlwZSA9IHR5cGVzWyBTeW1ib2xQYXJlbnRUeXBlIF0gfHwgbnVsbDtcblxuXHRjb25zdCBpc1N1YlR5cGUgPSBwYXJlbnRUeXBlID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdGNvbnN0IGNvbGxlY3Rpb24gPSBpc1N1YlR5cGUgPyBwYXJlbnRUeXBlLmNvbGxlY3Rpb24gOiB0eXBlc1sgTU5FTU9TWU5FIF07XG5cblx0aWYgKCB0eXBlcy5oYXMoIFR5cGVOYW1lICkgKSB7XG5cdFx0dGhyb3cgbmV3IEFMUkVBRFlfREVDTEFSRUQ7XG5cdH1cblxuXHQvLyBjb25zdCBzdWJ0eXBlcyA9IGRlc2NyaXB0b3JzLmNyZWF0ZVR5cGVzQ29sbGVjdGlvbigpO1xuXHRjb25zdCBzdWJ0eXBlcyA9IG5ldyBNYXAoKTtcblxuXHRjb25zdCB0aXRsZSA9IGAke1RZUEVfVElUTEVfUFJFRklYfSR7VHlwZU5hbWV9YDtcblxuXHRjb25maWcgPSBPYmplY3QuYXNzaWduKCB7fSwgY29sbGVjdGlvblsgU3ltYm9sQ29uZmlnIF0sIGNvbmZpZyApO1xuXG5cdGNvbnN0IHR5cGUgPSBPYmplY3QuYXNzaWduKCB0aGlzLCB7XG5cblx0XHRnZXQgY29uc3RydWN0SGFuZGxlciAoKSB7XG5cdFx0XHRyZXR1cm4gY29uc3RydWN0SGFuZGxlcjtcblx0XHR9LFxuXG5cblx0XHRUeXBlTmFtZSxcblx0XHRwcm90byxcblxuXHRcdGlzU3ViVHlwZSxcblx0XHRzdWJ0eXBlcyxcblx0XHRwYXJlbnRUeXBlLFxuXG5cdFx0Y29sbGVjdGlvbixcblxuXHRcdHRpdGxlLFxuXG5cdFx0Y29uZmlnLFxuXG5cdFx0aG9va3MgOiBPYmplY3QuY3JlYXRlKCBudWxsIClcblxuXHR9ICk7XG5cblx0Z2V0U3RhY2suY2FsbCggdGhpcywgYERlZmluaXRpb24gb2YgWyAke1R5cGVOYW1lfSBdIG1hZGUgYXQ6YCwgW10sIGRlZmluZU9yaWdpbiApO1xuXG5cdG9kcCggc3VidHlwZXMsIFN5bWJvbFBhcmVudFR5cGUsIHtcblx0XHRnZXQgKCkge1xuXHRcdFx0cmV0dXJuIHR5cGU7XG5cdFx0fVxuXHR9ICk7XG5cblx0Ly8gY29uc3QgVXJhbnVzID0gaXNTdWJUeXBlID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHByb3RvO1xuXHRjb25zdCBVcmFudXMgPSBpc1N1YlR5cGUgPyB1bmRlZmluZWQgOiBwcm90bztcblx0dHlwZXMuc2V0KCBUeXBlTmFtZSwgbmV3IFR5cGVQcm94eSggdHlwZSwgVXJhbnVzICkgKTtcblx0XG5cdC8vIHR5cGVzLnNldCggVHlwZU5hbWUsIG5ldyBUeXBlUHJveHkoIHR5cGUgKSApO1xuXG5cdHJldHVybiB0eXBlcy5nZXQoIFR5cGVOYW1lICk7XG5cbn0gYXMgQ29uc3RydWN0b3JGdW5jdGlvbjxUeXBlRGVzY3JpcHRvckluc3RhbmNlPjtcblxuT2JqZWN0LmFzc2lnbiggVHlwZURlc2NyaXB0b3IucHJvdG90eXBlLCBob29rc0FwaSApO1xuXG5UeXBlRGVzY3JpcHRvci5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24gKCAuLi5hcmdzOiBhbnlbXSApIHtcblx0cmV0dXJuIGRlZmluZS5jYWxsKCBkZWZpbmUsIHRoaXMuc3VidHlwZXMsIC4uLmFyZ3MgKTtcbn07XG5cblR5cGVEZXNjcmlwdG9yLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiAoIC4uLmFyZ3M6IGFueVtdICkge1xuXHRyZXR1cm4gbG9va3VwLmNhbGwoIHRoaXMuc3VidHlwZXMsIC4uLmFyZ3MgKTtcbn07XG5cbm9kcCggVHlwZURlc2NyaXB0b3IucHJvdG90eXBlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcblx0Z2V0ICgpIHtcblx0XHRyZXR1cm4gZ2V0VHlwZUNoZWNrZXIoIHRoaXMuVHlwZU5hbWUgKTtcblx0fVxufSApO1xuXG4vKlxuaGVyZSB3ZSB1c2UgZnVuY3Rpb24gdG8gcmV0cmVpdmUgYSBjb250cnVjdG9yXG5hbmQgY29uc3RydWN0SGFuZGxlckdldHRlciBpcyB0aGF0IGZ1bmN0aW9uXG4qL1xuY29uc3QgZGVmaW5lVXNpbmdUeXBlID0gZnVuY3Rpb24gKCB0aGlzOiBhbnksIHN1YnR5cGVzOiBhbnksIGNvbnN0cnVjdEhhbmRsZXJHZXR0ZXI6IENhbGxhYmxlRnVuY3Rpb24sIGNvbmZpZzogYW55ICkge1xuXHQvLyB3ZSBuZWVkIHRoaXMgdG8gZXh0cmFjdCBUeXBlTmFtZVxuXHRjb25zdCB0eXBlID0gY29uc3RydWN0SGFuZGxlckdldHRlcigpO1xuXG5cdGlmICggdHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0dGhyb3cgbmV3IEhBTkRMRVJfTVVTVF9CRV9BX0ZVTkNUSU9OO1xuXHR9XG5cblx0Y29uc3QgVHlwZU5hbWUgPSB0eXBlLm5hbWU7XG5cblx0aWYgKCAhVHlwZU5hbWUgKSB7XG5cdFx0dGhyb3cgbmV3IFRZUEVOQU1FX01VU1RfQkVfQV9TVFJJTkc7XG5cdH1cblxuXHRjb25zdCBhc0NsYXNzID0gaXNDbGFzcyggdHlwZSApO1xuXG5cdGNvbnN0IG1ha2VDb25zdHJ1Y3RIYW5kbGVyID0gKCkgPT4ge1xuXHRcdGNvbnN0IGNvbnN0cnVjdEhhbmRsZXIgPSBjb25zdHJ1Y3RIYW5kbGVyR2V0dGVyKCk7XG5cdFx0Ly8gY29uc3RydWN0SGFuZGxlcltTeW1ib2xDb25zdHJ1Y3Rvck5hbWVdID0gVHlwZU5hbWU7XG5cdFx0b2RwKCBjb25zdHJ1Y3RIYW5kbGVyLCBTeW1ib2xDb25zdHJ1Y3Rvck5hbWUsIHtcblx0XHRcdGdldCAoKSB7XG5cdFx0XHRcdHJldHVybiBUeXBlTmFtZTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0XG5cdFx0Ly8gdGhpcyB3YXMgY2hlY2tpbmcgZm9yIGNsYXNzIC8gZnVuY3Rpb25cblx0XHQvLyBmdW5jdGlvbnMgaGFzIC53cml0YWJsZSBwcm90b3R5cGVcblx0XHQvLyBhbmQgY2xhc3NlcyBhcmUgaGFzIG5vdFxuXHRcdGNvbnN0IHByb3RvRGVzYzogYW55ID0gT2JqZWN0XG5cdFx0XHQuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCBjb25zdHJ1Y3RIYW5kbGVyLCAncHJvdG90eXBlJyApO1xuXHRcdGlmICggcHJvdG9EZXNjLndyaXRhYmxlICkge1xuXHRcdFx0Ly8gY29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUgPSB7fTtcblx0XHRcdGNvbnN0cnVjdEhhbmRsZXIucHJvdG90eXBlID0gZ2V0RGVmYXVsdFByb3RvdHlwZSgpO1xuXHRcdH1cblx0XHRcblx0XHQvLyBUT0RPOlxuXHRcdC8vIHNpZGUtd2F5LCBub24gY29ycmVjdGx5IHdvcmtpbmdcblx0XHQvLyB3aXRoIGNyZWF0ZUluc3RhbmNlTW9kaWZpY2F0b3IgZm9yIGxpbmVcblx0XHQvLyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhNb2RpZmljYXRvclR5cGUucHJvdG90eXBlLCBwcm9wcyk7XG5cdFx0Ly8gZm9yIHJlcGVhdGFibGUgaW5zdGFuY2UgY3JlYXRpb25zXG5cdFx0Ly8g4oaT4oaT4oaTIOKGk+KGk+KGkyDihpPihpPihpNcblx0XHQvLyBlbHNlIHtcblx0XHQvLyBcdC8vIHNvIGxldCB1c2UgT2JqZWN0LnNldFByb3RvdHlwZU9mIGluc3RlYWRcblx0XHQvLyBcdC8vIE9iamVjdC5zZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUpLCBnZXREZWZhdWx0UHJvdG90eXBlKCkpO1xuXHRcdC8vIFx0T2JqZWN0LnNldFByb3RvdHlwZU9mKGNvbnN0cnVjdEhhbmRsZXIucHJvdG90eXBlLCBnZXREZWZhdWx0UHJvdG90eXBlKCkpO1xuXHRcdC8vIH1cblxuXHRcdHJldHVybiBjb25zdHJ1Y3RIYW5kbGVyO1xuXHR9O1xuXG5cdGlmICggdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgKSB7XG5cdFx0Y29uZmlnID0gT2JqZWN0LmFzc2lnbigge30sIGNvbmZpZyApO1xuXHR9IGVsc2Uge1xuXHRcdGNvbmZpZyA9IHt9O1xuXHR9XG5cblx0Y29uZmlnLmFzQ2xhc3MgPSBhc0NsYXNzO1xuXG5cdHJldHVybiBuZXcgVHlwZURlc2NyaXB0b3IoXG5cdFx0dGhpcyxcblx0XHRzdWJ0eXBlcyxcblx0XHRUeXBlTmFtZSxcblx0XHRtYWtlQ29uc3RydWN0SGFuZGxlcixcblx0XHR0eXBlLnByb3RvdHlwZSxcblx0XHRjb25maWdcblx0KTtcbn07XG5cblxuLypcbmhlcmUgd2UgZGlyZWN0bHkgcGFzc2luZyBjb25zdHJ1Y3RIYW5kbGVyXG5hcyBhIGNvbnN0cnVjdG9yIGZvciBpbnN0YW5jZXMgY3JlYXRpb25zXG4qL1xuY29uc3QgZGVmaW5lVXNpbmdGdW5jdGlvbiA9IGZ1bmN0aW9uIChcblx0dGhpczogYW55LFxuXHRzdWJ0eXBlczogYW55LFxuXHRUeXBlTmFtZTogc3RyaW5nLFxuXHRjb25zdHJ1Y3RIYW5kbGVyID0gZnVuY3Rpb24gKCkgeyB9LFxuXHRjb25maWc6IGFueSA9IHt9XG4pIHtcblxuXHRpZiAoIHR5cGVvZiBjb25zdHJ1Y3RIYW5kbGVyICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdHRocm93IG5ldyBIQU5ETEVSX01VU1RfQkVfQV9GVU5DVElPTjtcblx0fVxuXG5cdGNvbnN0IGFzQ2xhc3MgPSBpc0NsYXNzKCBjb25zdHJ1Y3RIYW5kbGVyICk7XG5cdGNvbnN0IG1vZGlmaWNhdG9yQm9keSA9IGNvbXBpbGVOZXdNb2RpZmljYXRvckZ1bmN0aW9uQm9keSggVHlwZU5hbWUsIGFzQ2xhc3MgKTtcblxuXHRjb25zdCBtYWtlQ29uc3RydWN0SGFuZGxlciA9IG1vZGlmaWNhdG9yQm9keShcblx0XHRjb25zdHJ1Y3RIYW5kbGVyLFxuXHRcdENyZWF0aW9uSGFuZGxlcixcblx0XHRTeW1ib2xDb25zdHJ1Y3Rvck5hbWVcblx0KTtcblxuXHRpZiAoIGNvbmZpZyBpbnN0YW5jZW9mIEZ1bmN0aW9uICkge1xuXHRcdGNvbmZpZyA9IHtcblx0XHRcdE1vZGlmaWNhdGlvbkNvbnN0cnVjdG9yIDogY29uZmlnXG5cdFx0fTtcblx0fVxuXG5cdGlmICggdHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcgKSB7XG5cdFx0Y29uZmlnID0ge307XG5cdH1cblxuXG5cdGNvbmZpZy5hc0NsYXNzID0gYXNDbGFzcztcblxuXHRjb25zdCBwcm90byA9IChcblx0XHRob3AoIGNvbnN0cnVjdEhhbmRsZXIsICdwcm90b3R5cGUnICkgJiZcblx0XHQoIGNvbnN0cnVjdEhhbmRsZXIucHJvdG90eXBlIGluc3RhbmNlb2YgT2JqZWN0ICApXG5cdC8vICkgPyBjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdCkgPyBjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSA6IGdldERlZmF1bHRQcm90b3R5cGUoKTtcblx0XG5cdC8vIGxldCBwcm90byA9IHt9O1xuXHQvLyBpZiAoIGhvcCggY29uc3RydWN0SGFuZGxlciwgJ3Byb3RvdHlwZScgKSAmJiAoIGNvbnN0cnVjdEhhbmRsZXIucHJvdG90eXBlIGluc3RhbmNlb2YgT2JqZWN0ICkgKSB7XG5cdC8vIFx0cHJvdG8gPSBPYmplY3QuYXNzaWduKCB7fSwgY29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUgKTtcblx0Ly8gXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoIHByb3RvLCBjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSApO1xuXHQvLyB9XG5cblx0cmV0dXJuIG5ldyBUeXBlRGVzY3JpcHRvcihcblx0XHR0aGlzLFxuXHRcdHN1YnR5cGVzLFxuXHRcdFR5cGVOYW1lLFxuXHRcdG1ha2VDb25zdHJ1Y3RIYW5kbGVyLFxuXHRcdC8vIHByb3RvIHByb3AgZm9yIFR5cGVEZXNjcmlwdG9yXG5cdFx0cHJvdG8sXG5cdFx0Y29uZmlnXG5cdCk7XG5cbn07XG5cblxuZXhwb3J0IGNvbnN0IGRlZmluZTogYW55ID0gZnVuY3Rpb24gKCB0aGlzOiBhbnksIHN1YnR5cGVzOiBhbnksIFR5cGVPclR5cGVOYW1lOiBzdHJpbmcgfCBhbnksIGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZzogYW55LCBjb25maWc6IG9iamVjdCApIHtcblxuXHRpZiAoIHR5cGVvZiBUeXBlT3JUeXBlTmFtZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHQvLyBUT0RPOiBpZiAoIGhvcCggVHlwZU9yVHlwZU5hbWUsICduYW1lJyApICkge1xuXHRcdC8vIFRPRE86IGlmICggaG9wKCBUeXBlT3JUeXBlTmFtZS5jb25zdHJ1Y3RvciwgJ25hbWUnICkgKSB7XG5cdFx0aWYgKCBUeXBlT3JUeXBlTmFtZS5uYW1lICkge1xuXHRcdFx0cmV0dXJuIGRlZmluZS5jYWxsKCB0aGlzLCBzdWJ0eXBlcywgVHlwZU9yVHlwZU5hbWUubmFtZSwgVHlwZU9yVHlwZU5hbWUsIGNvbmZpZyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZGVmaW5lVXNpbmdUeXBlLmNhbGwoIHRoaXMsIHN1YnR5cGVzLCBUeXBlT3JUeXBlTmFtZSwgY29uc3RydWN0SGFuZGxlck9yQ29uZmlnICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCB0eXBlb2YgVHlwZU9yVHlwZU5hbWUgPT09ICdzdHJpbmcnICkge1xuXG5cdFx0Y2hlY2tUeXBlTmFtZSggVHlwZU9yVHlwZU5hbWUgKTtcblxuXHRcdGNvbnN0IHNwbGl0ID0gZ2V0VHlwZVNwbGl0UGF0aCggVHlwZU9yVHlwZU5hbWUgKTtcblxuXHRcdGNvbnN0IFR5cGUgPSBsb29rdXAuY2FsbCggc3VidHlwZXMsIHNwbGl0WyAwIF0gKTtcblxuXHRcdGlmICggIVR5cGUgKSB7XG5cblx0XHRcdGlmICggc3BsaXQubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZGVmaW5lVXNpbmdGdW5jdGlvbi5jYWxsKCB0aGlzLCBzdWJ0eXBlcywgVHlwZU9yVHlwZU5hbWUsIGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZywgY29uZmlnICk7XG5cdFx0XHR9XG5cblx0XHRcdHRocm93IG5ldyBXUk9OR19UWVBFX0RFRklOSVRJT04oIGAke3NwbGl0WyAwIF19IGRlZmluaXRpb24gaXMgbm90IHlldCBleGlzdHNgICk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgVHlwZU5hbWUgPSBzcGxpdC5zbGljZSggMSApLmpvaW4oICcuJyApO1xuXG5cdFx0aWYgKCBzcGxpdC5sZW5ndGggPiAxICkge1xuXHRcdFx0cmV0dXJuIGRlZmluZS5jYWxsKCB0aGlzLCBUeXBlLnN1YnR5cGVzLCBUeXBlTmFtZSwgY29uc3RydWN0SGFuZGxlck9yQ29uZmlnLCBjb25maWcgKTtcblx0XHR9XG5cblx0XHQvLyBzbywgaGVyZSB3ZSBnbyB3aXRoXG5cdFx0Ly8gZGVmaW5lVXNpbmdUeXBlLmNhbGxcblx0XHQvLyBmcm9tIHRoZSBuZXh0IHN0ZXBcblx0XHRyZXR1cm4gZGVmaW5lLmNhbGwoIHRoaXMsIFR5cGUuc3VidHlwZXMsIGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZywgY29uZmlnICk7XG5cblx0fVxuXG5cdHRocm93IG5ldyBXUk9OR19UWVBFX0RFRklOSVRJT04oICdkZWZpbml0aW9uIGlzIG5vdCBwcm92aWRlZCcgKTtcblxufTtcblxuZXhwb3J0IGNvbnN0IGxvb2t1cDogYW55ID0gZnVuY3Rpb24gKCB0aGlzOiBhbnksIFR5cGVOZXN0ZWRQYXRoOiBzdHJpbmcgKSB7XG5cblx0aWYgKCB0eXBlb2YgVHlwZU5lc3RlZFBhdGggIT09ICdzdHJpbmcnICkge1xuXHRcdHRocm93IG5ldyBXUk9OR19UWVBFX0RFRklOSVRJT04oICdhcmcgOiB0eXBlIG5lc3RlZCBwYXRoIG11c3QgYmUgYSBzdHJpbmcnICk7XG5cdH1cblxuXHRpZiAoICFUeXBlTmVzdGVkUGF0aC5sZW5ndGggKSB7XG5cdFx0dGhyb3cgbmV3IFdST05HX1RZUEVfREVGSU5JVElPTiggJ2FyZyA6IHR5cGUgbmVzdGVkIHBhdGggaGFzIG5vIHBhdGgnICk7XG5cdH1cblxuXHRjb25zdCBzcGxpdCA9IGdldFR5cGVTcGxpdFBhdGgoIFR5cGVOZXN0ZWRQYXRoICk7XG5cblx0Y29uc3QgWyBuYW1lIF0gPSBzcGxpdDtcblx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0KCBuYW1lICk7XG5cdGlmICggc3BsaXQubGVuZ3RoID09PSAxICkge1xuXHRcdHJldHVybiB0eXBlO1xuXHR9XG5cblx0Y29uc3QgTmV4dE5lc3RlZFBhdGggPSBzcGxpdC5zbGljZSggMSApLmpvaW4oICcuJyApO1xuXHRyZXR1cm4gbG9va3VwLmNhbGwoIHR5cGUuc3VidHlwZXMsIE5leHROZXN0ZWRQYXRoICk7XG5cbn07XG5cblxuXG4iXX0=