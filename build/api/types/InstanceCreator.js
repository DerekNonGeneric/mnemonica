'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstanceCreator = void 0;
const constants_1 = require("../../constants");
const { odp, SymbolConstructorName } = constants_1.constants;
const errors_1 = require("../../descriptors/errors");
const { WRONG_MODIFICATION_PATTERN, } = errors_1.ErrorsTypes;
const utils_1 = require("../utils");
const { getExistentAsyncStack, makeFakeModificatorType, } = utils_1.default;
const errors_2 = require("../errors");
const throwModificationError_1 = require("../errors/throwModificationError");
const Props_1 = require("./Props");
const InstanceModificator_1 = require("./InstanceModificator");
const invokePreHooks = function () {
    const { type, existentInstance, args, InstanceModificator } = this;
    const { collection, } = type;
    const hookData = {
        type,
        existentInstance,
        args,
        InstanceModificator
    };
    collection.invokeHook('preCreation', hookData);
    type.invokeHook('preCreation', hookData);
};
const invokePostHooks = function () {
    const creator = this;
    const { inheritedInstance, } = creator;
    const props = (0, Props_1._getProps)(inheritedInstance);
    const { __type__: type, __parent__: existentInstance, __args__: args, } = props;
    const { collection, } = type;
    const hookType = inheritedInstance instanceof Error ?
        'creationError' : 'postCreation';
    const hookData = {
        type,
        existentInstance,
        inheritedInstance,
        args,
        creator
    };
    return {
        type: type.invokeHook(hookType, hookData),
        collection: collection.invokeHook(hookType, hookData),
    };
};
const postProcessing = function (continuationOf) {
    const self = this;
    const { stack, } = self;
    if (!self.inheritedInstance.constructor) {
        const msg = 'should inherit from mnemonica instance';
        self.throwModificationError(new WRONG_MODIFICATION_PATTERN(msg, stack));
    }
    if (!self.inheritedInstance.constructor[SymbolConstructorName]) {
        const msg = 'should inherit from mnemonica instance';
        self.throwModificationError(new WRONG_MODIFICATION_PATTERN(msg, stack));
    }
    if (continuationOf && !(self.inheritedInstance instanceof continuationOf)) {
        const icn = self.inheritedInstance.constructor.name;
        const msg = `should inherit from ${continuationOf.TypeName} but got ${icn}`;
        self.throwModificationError(new WRONG_MODIFICATION_PATTERN(msg, stack));
    }
    (0, Props_1._setSelf)(self.inheritedInstance);
    self.invokePostHooks();
};
const addThen = function (then) {
    const self = this;
    self.inheritedInstance = self.inheritedInstance
        .then(() => {
        self.inheritedInstance =
            new exports.InstanceCreator(then.subtype, self.inheritedInstance, then.args, true);
        return self.inheritedInstance;
    });
};
const makeAwaiter = function (type, then) {
    const self = this;
    self.inheritedInstance = self.inheritedInstance
        .then((instance) => {
        if (typeof instance !== 'object') {
            if (self.config.awaitReturn) {
                const msg = `should inherit from ${type.TypeName}: seems async ${type.TypeName} has no return statement`;
                throw new WRONG_MODIFICATION_PATTERN(msg, self.stack);
            }
            else {
                return instance;
            }
        }
        if (!(instance instanceof self.type)) {
            const icn = instance.constructor.name;
            const msg = `should inherit from ${type.TypeName} but got ${icn}`;
            throw new WRONG_MODIFICATION_PATTERN(msg, self.stack);
        }
        self.inheritedInstance = instance;
        const props = (0, Props_1._getProps)(self.inheritedInstance);
        if (props.__self__ !== self.inheritedInstance) {
            self.postProcessing(type);
        }
        return self.inheritedInstance;
    })
        .catch((error) => {
        if (self.config.blockErrors) {
            self.throwModificationError(error);
        }
        else {
            throw error;
        }
    });
    if (then) {
        self.addThen(then);
    }
    type.subtypes.forEach((subtype, name) => {
        self.inheritedInstance[name] = (...args) => {
            self.inheritedInstance = self.makeAwaiter(subtype, {
                name,
                subtype,
                args,
            });
            return self.inheritedInstance;
        };
    });
    return self.inheritedInstance;
};
const InstanceCreatorPrototype = {
    getExistentAsyncStack,
    postProcessing,
    makeAwaiter,
    addThen,
    invokePreHooks,
    invokePostHooks,
    throwModificationError: throwModificationError_1.throwModificationError
};
exports.InstanceCreator = function (type, existentInstance, args, chained) {
    const { constructHandler, proto, config, TypeName } = type;
    const { ModificationConstructor, blockErrors, submitStack } = config;
    const mc = ModificationConstructor();
    const self = this;
    const ModificatorType = constructHandler();
    Object.assign(self, {
        type,
        TypeName,
        existentInstance,
        get args() {
            return args;
        },
        ModificationConstructor: mc,
        ModificatorType,
        config,
        proto
    });
    if (submitStack || chained) {
        const stackAddition = chained ? self.getExistentAsyncStack(existentInstance) : [];
        const title = `\n<-- creation of [ ${TypeName} ] traced -->`;
        if (submitStack) {
            errors_2.getStack.call(self, title, stackAddition);
        }
        else {
            self.stack = title;
        }
    }
    if (blockErrors) {
        if (existentInstance instanceof Error) {
            self.ModificatorType = makeFakeModificatorType(TypeName);
            self.InstanceModificator = (0, InstanceModificator_1.makeInstanceModificator)(self);
            throw new self.InstanceModificator(...args);
        }
    }
    self.invokePreHooks();
    self.InstanceModificator = (0, InstanceModificator_1.makeInstanceModificator)(self);
    if (blockErrors) {
        try {
            const answer = new self.InstanceModificator(...args);
            self.inheritedInstance = answer;
        }
        catch (error) {
            self.throwModificationError(error);
        }
    }
    else {
        const answer = new self.InstanceModificator(...args);
        self.inheritedInstance = answer;
    }
    if (self.inheritedInstance instanceof Promise) {
        const waiter = self.makeAwaiter(type);
        odp(waiter, SymbolConstructorName, {
            get() {
                return TypeName;
            }
        });
        return waiter;
    }
    self.postProcessing(type);
    return self.inheritedInstance;
};
Object.assign(exports.InstanceCreator.prototype, InstanceCreatorPrototype);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5zdGFuY2VDcmVhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2FwaS90eXBlcy9JbnN0YW5jZUNyZWF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsWUFBWSxDQUFDOzs7QUFJYiwrQ0FFeUI7QUFFekIsTUFBTSxFQUNMLEdBQUcsRUFDSCxxQkFBcUIsRUFDckIsR0FBRyxxQkFBUyxDQUFDO0FBRWQscURBQXVEO0FBQ3ZELE1BQU0sRUFDTCwwQkFBMEIsR0FDMUIsR0FBRyxvQkFBVyxDQUFDO0FBRWhCLG9DQUFrQztBQUNsQyxNQUFNLEVBQ0wscUJBQXFCLEVBQ3JCLHVCQUF1QixHQUN2QixHQUFHLGVBQVUsQ0FBQztBQUVmLHNDQUFxQztBQUNyQyw2RUFBMEU7QUFFMUUsbUNBQXFEO0FBRXJELCtEQUFnRTtBQUVoRSxNQUFNLGNBQWMsR0FBRztJQUV0QixNQUFNLEVBQ0wsSUFBSSxFQUNKLGdCQUFnQixFQUNoQixJQUFJLEVBQ0osbUJBQW1CLEVBQ25CLEdBQUcsSUFBSSxDQUFDO0lBRVQsTUFBTSxFQUNMLFVBQVUsR0FDVixHQUFHLElBQUksQ0FBQztJQUVULE1BQU0sUUFBUSxHQUFHO1FBQ2hCLElBQUk7UUFDSixnQkFBZ0I7UUFDaEIsSUFBSTtRQUNKLG1CQUFtQjtLQUNuQixDQUFDO0lBRUYsVUFBVSxDQUFDLFVBQVUsQ0FBRSxhQUFhLEVBQUUsUUFBUSxDQUFFLENBQUM7SUFFakQsSUFBSSxDQUFDLFVBQVUsQ0FBRSxhQUFhLEVBQUUsUUFBUSxDQUFFLENBQUM7QUFFNUMsQ0FBQyxDQUFDO0FBR0YsTUFBTSxlQUFlLEdBQUc7SUFHdkIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDO0lBQ3JCLE1BQU0sRUFDTCxpQkFBaUIsR0FDakIsR0FBRyxPQUFPLENBQUM7SUFFWixNQUFNLEtBQUssR0FBRyxJQUFBLGlCQUFTLEVBQUMsaUJBQWlCLENBQVUsQ0FBQztJQUVwRCxNQUFNLEVBQ0wsUUFBUSxF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QztRQUVuQixJQUFJLENBQUM7WUFFSixNQUFNLE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQyxtQkFBbUIsQ0FBRSxHQUFHLElBQUksQ0FBRSxDQUFDO1lBRXZELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxNQUFNLENBQUM7UUFFakMsQ0FBQztRQUFDLE9BQVEsS0FBSyxFQUFHLENBQUM7WUFFbEIsSUFBSSxDQUFDLHNCQUFzQixDQUFFLEtBQUssQ0FBRSxDQUFDO1FBRXRDLENBQUM7SUFFRixDQUFDO1NBQU0sQ0FBQztRQUdQLE1BQU0sTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDLG1CQUFtQixDQUFFLEdBQUcsSUFBSSxDQUFFLENBQUM7UUFFdkQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLE1BQU0sQ0FBQztJQUVqQyxDQUFDO0lBR0QsSUFBSyxJQUFJLENBQUMsaUJBQWlCLFlBQVksT0FBTyxFQUFHLENBQUM7UUFFakQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBRSxJQUFJLENBQUUsQ0FBQztRQUV4QyxHQUFHLENBQUUsTUFBTSxFQUFFLHFCQUFxQixFQUFFO1lBQ25DLEdBQUc7Z0JBQ0YsT0FBTyxRQUFRLENBQUM7WUFDakIsQ0FBQztTQUNELENBQUUsQ0FBQztRQUVKLE9BQU8sTUFBTSxDQUFDO0lBRWYsQ0FBQztJQUVELElBQUksQ0FBQyxjQUFjLENBQUUsSUFBSSxDQUFFLENBQUM7SUFFNUIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUM7QUFFL0IsQ0FBeUQsQ0FBQztBQUUxRCxNQUFNLENBQUMsTUFBTSxDQUFFLHVCQUFlLENBQUMsU0FBUyxFQUFFLHdCQUF3QixDQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IENvbnN0cnVjdG9yRnVuY3Rpb24gfSBmcm9tICcuLi8uLi90eXBlcyc7XG5cbmltcG9ydCB7XG5cdGNvbnN0YW50c1xufSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuXG5jb25zdCB7XG5cdG9kcCxcblx0U3ltYm9sQ29uc3RydWN0b3JOYW1lXG59ID0gY29uc3RhbnRzO1xuXG5pbXBvcnQgeyBFcnJvcnNUeXBlcyB9IGZyb20gJy4uLy4uL2Rlc2NyaXB0b3JzL2Vycm9ycyc7XG5jb25zdCB7XG5cdFdST05HX01PRElGSUNBVElPTl9QQVRURVJOLFxufSA9IEVycm9yc1R5cGVzO1xuXG5pbXBvcnQgVHlwZXNVdGlscyBmcm9tICcuLi91dGlscyc7XG5jb25zdCB7XG5cdGdldEV4aXN0ZW50QXN5bmNTdGFjayxcblx0bWFrZUZha2VNb2RpZmljYXRvclR5cGUsXG59ID0gVHlwZXNVdGlscztcblxuaW1wb3J0IHsgZ2V0U3RhY2sgfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHsgdGhyb3dNb2RpZmljYXRpb25FcnJvciB9IGZyb20gJy4uL2Vycm9ycy90aHJvd01vZGlmaWNhdGlvbkVycm9yJztcblxuaW1wb3J0IHsgX2dldFByb3BzLCBfc2V0U2VsZiwgUHJvcHMgfSBmcm9tICcuL1Byb3BzJztcblxuaW1wb3J0IHsgbWFrZUluc3RhbmNlTW9kaWZpY2F0b3IgfSBmcm9tICcuL0luc3RhbmNlTW9kaWZpY2F0b3InO1xuXG5jb25zdCBpbnZva2VQcmVIb29rcyA9IGZ1bmN0aW9uICggdGhpczogYW55ICkge1xuXG5cdGNvbnN0IHtcblx0XHR0eXBlLFxuXHRcdGV4aXN0ZW50SW5zdGFuY2UsXG5cdFx0YXJncyxcblx0XHRJbnN0YW5jZU1vZGlmaWNhdG9yXG5cdH0gPSB0aGlzO1xuXG5cdGNvbnN0IHtcblx0XHRjb2xsZWN0aW9uLFxuXHR9ID0gdHlwZTtcblxuXHRjb25zdCBob29rRGF0YSA9IHtcblx0XHR0eXBlLFxuXHRcdGV4aXN0ZW50SW5zdGFuY2UsXG5cdFx0YXJncyxcblx0XHRJbnN0YW5jZU1vZGlmaWNhdG9yXG5cdH07XG5cblx0Y29sbGVjdGlvbi5pbnZva2VIb29rKCAncHJlQ3JlYXRpb24nLCBob29rRGF0YSApO1xuXG5cdHR5cGUuaW52b2tlSG9vayggJ3ByZUNyZWF0aW9uJywgaG9va0RhdGEgKTtcblxufTtcblxuXG5jb25zdCBpbnZva2VQb3N0SG9va3MgPSBmdW5jdGlvbiAoIHRoaXM6IGFueSApIHtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcblx0Y29uc3QgY3JlYXRvciA9IHRoaXM7XG5cdGNvbnN0IHtcblx0XHRpbmhlcml0ZWRJbnN0YW5jZSxcblx0fSA9IGNyZWF0b3I7XG5cblx0Y29uc3QgcHJvcHMgPSBfZ2V0UHJvcHMoaW5oZXJpdGVkSW5zdGFuY2UpIGFzIFByb3BzO1xuXG5cdGNvbnN0IHtcblx0XHRfX3R5cGVfXzogdHlwZSxcblx0XHRfX3BhcmVudF9fOiBleGlzdGVudEluc3RhbmNlLFxuXHRcdF9fYXJnc19fOiBhcmdzLFxuXHR9ID0gcHJvcHM7XG5cblx0Y29uc3Qge1xuXHRcdGNvbGxlY3Rpb24sXG5cdH0gPSB0eXBlO1xuXG5cdGNvbnN0IGhvb2tUeXBlID0gaW5oZXJpdGVkSW5zdGFuY2UgaW5zdGFuY2VvZiBFcnJvciA/XG5cdFx0J2NyZWF0aW9uRXJyb3InIDogJ3Bvc3RDcmVhdGlvbic7XG5cblx0Y29uc3QgaG9va0RhdGEgPSB7XG5cdFx0dHlwZSxcblx0XHRleGlzdGVudEluc3RhbmNlLFxuXHRcdGluaGVyaXRlZEluc3RhbmNlLFxuXHRcdGFyZ3MsXG5cdFx0Y3JlYXRvclxuXHR9O1xuXG5cdHJldHVybiB7XG5cblx0XHR0eXBlIDogdHlwZS5pbnZva2VIb29rKCBob29rVHlwZSwgaG9va0RhdGEgKSxcblxuXHRcdGNvbGxlY3Rpb24gOiBjb2xsZWN0aW9uLmludm9rZUhvb2soIGhvb2tUeXBlLCBob29rRGF0YSApLFxuXG5cdH07XG5cbn07XG5cbmNvbnN0IHBvc3RQcm9jZXNzaW5nID0gZnVuY3Rpb24gKCB0aGlzOiBhbnksIGNvbnRpbnVhdGlvbk9mOiBhbnkgKSB7XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG5cdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRjb25zdCB7XG5cdFx0c3RhY2ssXG5cdH0gPSBzZWxmO1xuXG5cdGlmICggIXNlbGYuaW5oZXJpdGVkSW5zdGFuY2UuY29uc3RydWN0b3IgKSB7XG5cdFx0Y29uc3QgbXNnID0gJ3Nob3VsZCBpbmhlcml0IGZyb20gbW5lbW9uaWNhIGluc3RhbmNlJztcblx0XHRzZWxmLnRocm93TW9kaWZpY2F0aW9uRXJyb3IoIG5ldyBXUk9OR19NT0RJRklDQVRJT05fUEFUVEVSTiggbXNnLCBzdGFjayApICk7XG5cdH1cblxuXHRpZiAoICFzZWxmLmluaGVyaXRlZEluc3RhbmNlLmNvbnN0cnVjdG9yWyBTeW1ib2xDb25zdHJ1Y3Rvck5hbWUgXSApIHtcblx0XHRjb25zdCBtc2cgPSAnc2hvdWxkIGluaGVyaXQgZnJvbSBtbmVtb25pY2EgaW5zdGFuY2UnO1xuXHRcdHNlbGYudGhyb3dNb2RpZmljYXRpb25FcnJvciggbmV3IFdST05HX01PRElGSUNBVElPTl9QQVRURVJOKCBtc2csIHN0YWNrICkgKTtcblx0fVxuXG5cdGlmICggY29udGludWF0aW9uT2YgJiYgISggc2VsZi5pbmhlcml0ZWRJbnN0YW5jZSBpbnN0YW5jZW9mIGNvbnRpbnVhdGlvbk9mICkgKSB7XG5cdFx0Ly8gZGVidWdnZXI7XG5cdFx0Y29uc3QgaWNuID0gc2VsZi5pbmhlcml0ZWRJbnN0YW5jZS5jb25zdHJ1Y3Rvci5uYW1lO1xuXHRcdGNvbnN0IG1zZyA9IGBzaG91bGQgaW5oZXJpdCBmcm9tICR7Y29udGludWF0aW9uT2YuVHlwZU5hbWV9IGJ1dCBnb3QgJHtpY259YDtcblx0XHRzZWxmLnRocm93TW9kaWZpY2F0aW9uRXJyb3IoIG5ldyBXUk9OR19NT0RJRklDQVRJT05fUEFUVEVSTiggbXNnLCBzdGFjayApICk7XG5cdFx0Ly8gdGhyb3cgbmV3IFdST05HX01PRElGSUNBVElPTl9QQVRURVJOKG1zZywgc2VsZi5zdGFjayk7XG5cdH1cblxuXHRfc2V0U2VsZihzZWxmLmluaGVyaXRlZEluc3RhbmNlKTtcblxuXHRzZWxmLmludm9rZVBvc3RIb29rcygpO1xuXG59O1xuXG5jb25zdCBhZGRUaGVuID0gZnVuY3Rpb24gKCB0aGlzOiBhbnksIHRoZW46IGFueSApIHtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcblx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0c2VsZi5pbmhlcml0ZWRJbnN0YW5jZSA9IHNlbGYuaW5oZXJpdGVkSW5zdGFuY2Vcblx0XHQvLyAudGhlbiggKCBpbnN0YW5jZTogYW55ICkgPT4ge1xuXHRcdC50aGVuKCAoKSA9PiB7XG5cdFx0XHQvLyBzZWxmLmluaGVyaXRlZEluc3RhbmNlID0gaW5zdGFuY2U7XG5cdFx0XHRzZWxmLmluaGVyaXRlZEluc3RhbmNlID1cblx0XHRcdFx0bmV3IEluc3RhbmNlQ3JlYXRvcihcblx0XHRcdFx0XHR0aGVuLnN1YnR5cGUsXG5cdFx0XHRcdFx0c2VsZi5pbmhlcml0ZWRJbnN0YW5jZSxcblx0XHRcdFx0XHR0aGVuLmFyZ3MsXG5cdFx0XHRcdFx0Ly8gd2FzIGNoYWluZWQgOlxuXHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQvLyBzZWxmLmV4aXN0ZW50SW5zdGFuY2Vcblx0XHRcdFx0KTtcblx0XHRcdHJldHVybiBzZWxmLmluaGVyaXRlZEluc3RhbmNlO1xuXHRcdH0gKTtcblxufTtcblxuXG5jb25zdCBtYWtlQXdhaXRlciA9IGZ1bmN0aW9uICggdGhpczogYW55LCB0eXBlOiBhbnksIHRoZW46IGFueSApIHtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcblx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0c2VsZi5pbmhlcml0ZWRJbnN0YW5jZSA9IHNlbGYuaW5oZXJpdGVkSW5zdGFuY2Vcblx0XHQudGhlbiggKCBpbnN0YW5jZTogYW55ICkgPT4ge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBpbnN0YW5jZSAhPT0gJ29iamVjdCcgKSB7XG5cdFx0XHRcdGlmICggc2VsZi5jb25maWcuYXdhaXRSZXR1cm4gKSB7XG5cdFx0XHRcdFx0Y29uc3QgbXNnID0gYHNob3VsZCBpbmhlcml0IGZyb20gJHt0eXBlLlR5cGVOYW1lfTogc2VlbXMgYXN5bmMgJHt0eXBlLlR5cGVOYW1lfSBoYXMgbm8gcmV0dXJuIHN0YXRlbWVudGA7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFdST05HX01PRElGSUNBVElPTl9QQVRURVJOKCBtc2csIHNlbGYuc3RhY2sgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhKCBpbnN0YW5jZSBpbnN0YW5jZW9mIHNlbGYudHlwZSApICkge1xuXHRcdFx0XHRjb25zdCBpY24gPSBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5uYW1lO1xuXHRcdFx0XHRjb25zdCBtc2cgPSBgc2hvdWxkIGluaGVyaXQgZnJvbSAke3R5cGUuVHlwZU5hbWV9IGJ1dCBnb3QgJHtpY259YDtcblx0XHRcdFx0Ly8gc2VsZi50aHJvd01vZGlmaWNhdGlvbkVycm9yKG5ldyBXUk9OR19NT0RJRklDQVRJT05fUEFUVEVSTihtc2csIHNlbGYuc3RhY2spKTtcblx0XHRcdFx0dGhyb3cgbmV3IFdST05HX01PRElGSUNBVElPTl9QQVRURVJOKCBtc2csIHNlbGYuc3RhY2sgKTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZi5pbmhlcml0ZWRJbnN0YW5jZSA9IGluc3RhbmNlO1xuXG5cdFx0XHRjb25zdCBwcm9wcyA9IF9nZXRQcm9wcyhzZWxmLmluaGVyaXRlZEluc3RhbmNlKSBhcyBQcm9wcztcblxuXHRcdFx0aWYgKCBwcm9wcy5fX3NlbGZfXyAhPT0gc2VsZi5pbmhlcml0ZWRJbnN0YW5jZSApIHtcblx0XHRcdFx0Ly8gaXQgd2FzIGFzeW5jIGluc3RhbmNlLFxuXHRcdFx0XHQvLyBzbyB3ZSBoYXZlIHRvIGFkZCBhbGwgdGhlIHN0dWZmXG5cdFx0XHRcdC8vIGZvciBzeW5jIGluc3RhbmNlcyBpdCB3YXMgZG9uZSBhbHJlYWR5XG5cdFx0XHRcdHNlbGYucG9zdFByb2Nlc3NpbmcoIHR5cGUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNlbGYuaW5oZXJpdGVkSW5zdGFuY2U7XG5cblx0XHR9IClcblx0XHQuY2F0Y2goICggZXJyb3I6IEVycm9yICkgPT4ge1xuXHRcdFx0aWYgKCBzZWxmLmNvbmZpZy5ibG9ja0Vycm9ycyApIHtcblx0XHRcdFx0c2VsZi50aHJvd01vZGlmaWNhdGlvbkVycm9yKCBlcnJvciApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdGlmICggdGhlbiApIHtcblx0XHRzZWxmLmFkZFRoZW4oIHRoZW4gKTtcblx0fVxuXG5cdHR5cGUuc3VidHlwZXMuZm9yRWFjaCggKCBzdWJ0eXBlOiBhbnksIG5hbWU6IHN0cmluZyApID0+IHtcblx0XHRzZWxmLmluaGVyaXRlZEluc3RhbmNlWyBuYW1lIF0gPSAoIC4uLmFyZ3M6IGFueVtdICkgPT4ge1xuXHRcdFx0c2VsZi5pbmhlcml0ZWRJbnN0YW5jZSA9IHNlbGYubWFrZUF3YWl0ZXIoIHN1YnR5cGUsIHtcblx0XHRcdFx0bmFtZSxcblx0XHRcdFx0c3VidHlwZSxcblx0XHRcdFx0YXJncyxcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBzZWxmLmluaGVyaXRlZEluc3RhbmNlO1xuXHRcdH07XG5cdH0gKTtcblxuXHRyZXR1cm4gc2VsZi5pbmhlcml0ZWRJbnN0YW5jZTtcblxufTtcblxuY29uc3QgSW5zdGFuY2VDcmVhdG9yUHJvdG90eXBlID0ge1xuXHRnZXRFeGlzdGVudEFzeW5jU3RhY2ssXG5cdHBvc3RQcm9jZXNzaW5nLFxuXHRtYWtlQXdhaXRlcixcblx0YWRkVGhlbixcblx0aW52b2tlUHJlSG9va3MsXG5cdGludm9rZVBvc3RIb29rcyxcblx0dGhyb3dNb2RpZmljYXRpb25FcnJvclxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuLy8gQHRzLWlnbm9yZVxuZXhwb3J0IGNvbnN0IEluc3RhbmNlQ3JlYXRvciA9IGZ1bmN0aW9uICggdGhpczogYW55LCB0eXBlOiBhbnksIGV4aXN0ZW50SW5zdGFuY2U6IGFueSwgYXJnczogYW55W10sIGNoYWluZWQ6IGJvb2xlYW4gKSB7XG5cblx0Y29uc3Qge1xuXHRcdGNvbnN0cnVjdEhhbmRsZXIsXG5cdFx0cHJvdG8sXG5cdFx0Y29uZmlnLFxuXHRcdFR5cGVOYW1lXG5cdH0gPSB0eXBlO1xuXG5cdGNvbnN0IHtcblx0XHRNb2RpZmljYXRpb25Db25zdHJ1Y3Rvcixcblx0XHRibG9ja0Vycm9ycyxcblx0XHRzdWJtaXRTdGFja1xuXHR9ID0gY29uZmlnO1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG5cdGNvbnN0IG1jID0gTW9kaWZpY2F0aW9uQ29uc3RydWN0b3IoKTtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcblx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0Y29uc3QgTW9kaWZpY2F0b3JUeXBlID0gY29uc3RydWN0SGFuZGxlcigpO1xuXG5cdE9iamVjdC5hc3NpZ24oIHNlbGYsIHtcblxuXHRcdHR5cGUsXG5cdFx0VHlwZU5hbWUsXG5cblx0XHRleGlzdGVudEluc3RhbmNlLFxuXG5cdFx0Z2V0IGFyZ3MgKCkge1xuXHRcdFx0cmV0dXJuIGFyZ3M7XG5cdFx0fSxcblxuXHRcdE1vZGlmaWNhdGlvbkNvbnN0cnVjdG9yIDogbWMsXG5cdFx0TW9kaWZpY2F0b3JUeXBlLFxuXG5cdFx0Y29uZmlnLFxuXG5cdFx0cHJvdG9cblxuXHR9ICk7XG5cblx0aWYgKCBzdWJtaXRTdGFjayB8fCBjaGFpbmVkICkge1xuXHRcdGNvbnN0IHN0YWNrQWRkaXRpb246IHN0cmluZ1tdID0gY2hhaW5lZCA/IHNlbGYuZ2V0RXhpc3RlbnRBc3luY1N0YWNrKCBleGlzdGVudEluc3RhbmNlICkgOiBbXTtcblx0XHRjb25zdCB0aXRsZSA9IGBcXG48LS0gY3JlYXRpb24gb2YgWyAke1R5cGVOYW1lfSBdIHRyYWNlZCAtLT5gO1xuXHRcdGlmICggc3VibWl0U3RhY2sgKSB7XG5cdFx0XHRnZXRTdGFjay5jYWxsKCBzZWxmLCB0aXRsZSwgc3RhY2tBZGRpdGlvbiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZWxmLnN0YWNrID0gdGl0bGU7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBibG9ja0Vycm9ycyApIHtcblxuXHRcdGlmICggZXhpc3RlbnRJbnN0YW5jZSBpbnN0YW5jZW9mIEVycm9yICkge1xuXG5cdFx0XHRzZWxmLk1vZGlmaWNhdG9yVHlwZSA9IG1ha2VGYWtlTW9kaWZpY2F0b3JUeXBlKCBUeXBlTmFtZSApO1xuXG5cdFx0XHRzZWxmLkluc3RhbmNlTW9kaWZpY2F0b3IgPSBtYWtlSW5zdGFuY2VNb2RpZmljYXRvciggc2VsZiApO1xuXG5cdFx0XHR0aHJvdyBuZXcgc2VsZi5JbnN0YW5jZU1vZGlmaWNhdG9yKCAuLi5hcmdzICk7XG5cblx0XHR9XG5cdH1cblxuXHRzZWxmLmludm9rZVByZUhvb2tzKCk7XG5cblx0c2VsZi5JbnN0YW5jZU1vZGlmaWNhdG9yID0gbWFrZUluc3RhbmNlTW9kaWZpY2F0b3IoIHNlbGYgKTtcblxuXHRpZiAoIGJsb2NrRXJyb3JzICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIENvbnN0cnVjdG9yIEludm9jYXRpb24gSXRzZWxmXG5cdFx0XHRjb25zdCBhbnN3ZXIgPSBuZXcgc2VsZi5JbnN0YW5jZU1vZGlmaWNhdG9yKCAuLi5hcmdzICk7XG5cdFx0XHQvLyBkZWJ1Z2dlcjtcblx0XHRcdHNlbGYuaW5oZXJpdGVkSW5zdGFuY2UgPSBhbnN3ZXI7XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdHNlbGYudGhyb3dNb2RpZmljYXRpb25FcnJvciggZXJyb3IgKTtcblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQ29uc3RydWN0b3IgSW52b2NhdGlvbiBJdHNlbGZcblx0XHRjb25zdCBhbnN3ZXIgPSBuZXcgc2VsZi5JbnN0YW5jZU1vZGlmaWNhdG9yKCAuLi5hcmdzICk7XG5cdFx0Ly8gZGVidWdnZXI7XG5cdFx0c2VsZi5pbmhlcml0ZWRJbnN0YW5jZSA9IGFuc3dlcjtcblxuXHR9XG5cblxuXHRpZiAoIHNlbGYuaW5oZXJpdGVkSW5zdGFuY2UgaW5zdGFuY2VvZiBQcm9taXNlICkge1xuXG5cdFx0Y29uc3Qgd2FpdGVyID0gc2VsZi5tYWtlQXdhaXRlciggdHlwZSApO1xuXG5cdFx0b2RwKCB3YWl0ZXIsIFN5bWJvbENvbnN0cnVjdG9yTmFtZSwge1xuXHRcdFx0Z2V0ICgpIHtcblx0XHRcdFx0cmV0dXJuIFR5cGVOYW1lO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdHJldHVybiB3YWl0ZXI7XG5cblx0fVxuXG5cdHNlbGYucG9zdFByb2Nlc3NpbmcoIHR5cGUgKTtcblxuXHRyZXR1cm4gc2VsZi5pbmhlcml0ZWRJbnN0YW5jZTtcblxufSBhcyBDb25zdHJ1Y3RvckZ1bmN0aW9uPHR5cGVvZiBJbnN0YW5jZUNyZWF0b3JQcm90b3R5cGU+O1xuXG5PYmplY3QuYXNzaWduKCBJbnN0YW5jZUNyZWF0b3IucHJvdG90eXBlLCBJbnN0YW5jZUNyZWF0b3JQcm90b3R5cGUgKTtcbiJdfQ==