'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstanceCreator = void 0;
const constants_1 = require("../../constants");
const { odp, SymbolConstructorName } = constants_1.constants;
const errors_1 = require("../../descriptors/errors");
const { WRONG_MODIFICATION_PATTERN, } = errors_1.ErrorsTypes;
const utils_1 = require("../utils");
const { getExistentAsyncStack, makeFakeModificatorType, } = utils_1.default;
const errors_2 = require("../errors");
const throwModificationError_1 = require("../errors/throwModificationError");
const addProps_1 = require("./addProps");
const InstanceModificator_1 = require("./InstanceModificator");
const obeyConstructor_1 = require("./obeyConstructor");
const invokePreHooks = function () {
    const { type, existentInstance, args, InstanceModificator } = this;
    const { collection, } = type;
    const hookData = {
        type,
        existentInstance,
        args,
        InstanceModificator
    };
    collection.invokeHook('preCreation', hookData);
    type.invokeHook('preCreation', hookData);
};
const invokePostHooks = function () {
    const creator = this;
    const { inheritedInstance, } = creator;
    const props = (0, addProps_1.getProps)(inheritedInstance);
    const { __type__: type, __parent__: existentInstance, __args__: args, } = props;
    const { collection, } = type;
    const hookType = inheritedInstance instanceof Error ?
        'creationError' : 'postCreation';
    const hookData = {
        type,
        existentInstance,
        inheritedInstance,
        args,
        creator
    };
    return {
        type: type.invokeHook(hookType, hookData),
        collection: collection.invokeHook(hookType, hookData),
    };
};
const postProcessing = function (continuationOf) {
    const self = this;
    const { stack, } = self;
    if (!self.inheritedInstance.constructor) {
        const msg = 'should inherit from mnemonica instance';
        self.throwModificationError(new WRONG_MODIFICATION_PATTERN(msg, stack));
    }
    if (!self.inheritedInstance.constructor[SymbolConstructorName]) {
        const msg = 'should inherit from mnemonica instance';
        self.throwModificationError(new WRONG_MODIFICATION_PATTERN(msg, stack));
    }
    if (continuationOf && !(self.inheritedInstance instanceof continuationOf)) {
        const icn = self.inheritedInstance.constructor.name;
        const msg = `should inherit from ${continuationOf.TypeName} but got ${icn}`;
        self.throwModificationError(new WRONG_MODIFICATION_PATTERN(msg, stack));
    }
    odp(self.inheritedInstance, '__self__', {
        get() {
            return self.inheritedInstance;
        }
    });
    self.invokePostHooks();
};
const addThen = function (then) {
    const self = this;
    self.inheritedInstance = self.inheritedInstance
        .then(() => {
        self.inheritedInstance =
            new exports.InstanceCreator(then.subtype, self.inheritedInstance, then.args, true);
        return self.inheritedInstance;
    });
};
const makeAwaiter = function (type, then) {
    const self = this;
    self.inheritedInstance = self.inheritedInstance
        .then((instance) => {
        if (typeof instance !== 'object') {
            if (self.config.awaitReturn) {
                const msg = `should inherit from ${type.TypeName}: seems async ${type.TypeName} has no return statement`;
                throw new WRONG_MODIFICATION_PATTERN(msg, self.stack);
            }
            else {
                return instance;
            }
        }
        if (!(instance instanceof self.type)) {
            const icn = instance.constructor.name;
            const msg = `should inherit from ${type.TypeName} but got ${icn}`;
            throw new WRONG_MODIFICATION_PATTERN(msg, self.stack);
        }
        self.inheritedInstance = instance;
        if (self.inheritedInstance.__self__ !== self.inheritedInstance) {
            self.postProcessing(type);
        }
        return self.inheritedInstance;
    })
        .catch((error) => {
        if (self.config.blockErrors) {
            self.throwModificationError(error);
        }
        else {
            throw error;
        }
    });
    if (then) {
        self.addThen(then);
    }
    type.subtypes.forEach((subtype, name) => {
        self.inheritedInstance[name] = (...args) => {
            self.inheritedInstance = self.makeAwaiter(subtype, {
                name,
                subtype,
                args,
            });
            return self.inheritedInstance;
        };
    });
    return self.inheritedInstance;
};
const InstanceCreatorPrototype = {
    getExistentAsyncStack,
    postProcessing,
    makeAwaiter,
    addProps: addProps_1.addProps,
    addThen,
    invokePreHooks,
    invokePostHooks,
    throwModificationError: throwModificationError_1.throwModificationError
};
exports.InstanceCreator = function (type, existentInstance, args, chained) {
    const { constructHandler, proto, config, TypeName } = type;
    const { ModificationConstructor, blockErrors, submitStack } = config;
    const mc = ModificationConstructor(obeyConstructor_1.obey);
    const self = this;
    const ModificatorType = constructHandler();
    Object.assign(self, {
        type,
        TypeName,
        existentInstance,
        get args() {
            return args;
        },
        ModificationConstructor: mc,
        ModificatorType,
        config,
        proto
    });
    if (submitStack || chained) {
        const stackAddition = chained ? self.getExistentAsyncStack(existentInstance) : [];
        const title = `\n<-- creation of [ ${TypeName} ] traced -->`;
        if (submitStack) {
            errors_2.getStack.call(self, title, stackAddition);
        }
        else {
            self.stack = title;
        }
    }
    if (blockErrors && existentInstance instanceof Error) {
        self.ModificatorType = makeFakeModificatorType(TypeName);
        self.InstanceModificator = (0, InstanceModificator_1.makeInstanceModificator)(self);
        throw new self.InstanceModificator(...args);
    }
    self.invokePreHooks();
    self.InstanceModificator = (0, InstanceModificator_1.makeInstanceModificator)(self);
    if (blockErrors) {
        try {
            const answer = new self.InstanceModificator(...args);
            self.inheritedInstance = answer;
        }
        catch (error) {
            self.throwModificationError(error);
        }
    }
    else {
        const answer = new self.InstanceModificator(...args);
        self.inheritedInstance = answer;
    }
    if (self.inheritedInstance instanceof Promise) {
        const waiter = self.makeAwaiter(type);
        odp(waiter, SymbolConstructorName, {
            get() {
                return TypeName;
            }
        });
        return waiter;
    }
    self.postProcessing(type);
    return self.inheritedInstance;
};
Object.assign(exports.InstanceCreator.prototype, InstanceCreatorPrototype);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5zdGFuY2VDcmVhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2FwaS90eXBlcy9JbnN0YW5jZUNyZWF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsWUFBWSxDQUFDOzs7QUFJYiwrQ0FFeUI7QUFFekIsTUFBTSxFQUNMLEdBQUcsRUFDSCxxQkFBcUIsRUFDckIsR0FBRyxxQkFBUyxDQUFDO0FBRWQscURBQXVEO0FBQ3ZELE1BQU0sRUFDTCwwQkFBMEIsR0FDMUIsR0FBRyxvQkFBVyxDQUFDO0FBRWhCLG9DQUFrQztBQUNsQyxNQUFNLEVBQ0wscUJBQXFCLEVBQ3JCLHVCQUF1QixHQUN2QixHQUFHLGVBQVUsQ0FBQztBQUVmLHNDQUFxQztBQUNyQyw2RUFBMEU7QUFFMUUseUNBQXVEO0FBRXZELCtEQUFnRTtBQUVoRSx1REFBeUM7QUFFekMsTUFBTSxjQUFjLEdBQUc7SUFFdEIsTUFBTSxFQUNMLElBQUksRUFDSixnQkFBZ0IsRUFDaEIsSUFBSSxFQUNKLG1CQUFtQixFQUNuQixHQUFHLElBQUksQ0FBQztJQUVULE1BQU0sRUFDTCxVQUFVLEdBQ1YsR0FBRyxJQUFJLENBQUM7SUFFVCxNQUFNLFFBQVEsR0FBRztRQUNoQixJQUFJO1FBQ0osZ0JBQWdCO1FBQ2hCLElBQUk7UUFDSixtQkFBbUI7S0FDbkIsQ0FBQztJQUVGLFVBQVUsQ0FBQyxVQUFVLENBQUUsYUFBYSxFQUFFLFFBQVEsQ0FBRSxDQUFDO0lBRWpELElBQUksQ0FBQyxVQUFVLENBQUUsYUFBYSxFQUFFLFFBQVEsQ0FBRSxDQUFDO0FBRTVDLENBQUMsQ0FBQztBQUdGLE1BQU0sZUFBZSxHQUFHO0lBR3ZCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQztJQUNyQixNQUFNLEVBQ0wsaUJBQWlCLEdBQ2pCLEdBQUcsT0FBTyxDQUFDO0lBRVosTUFBTSxLQUFLLEdBQUcsSUFBQSxtQkFBUSxFQUFDLGlCQUFpQixDQUFVLENBQUM7SUFFbkQsTUFB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Q0FBRSxDQUFDO0lBRTNELElBQUssV0FBVyxFQUFHLENBQUM7UUFFbkIsSUFBSSxDQUFDO1lBRUosTUFBTSxNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUMsbUJBQW1CLENBQUUsR0FBRyxJQUFJLENBQUUsQ0FBQztZQUV2RCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsTUFBTSxDQUFDO1FBRWpDLENBQUM7UUFBQyxPQUFRLEtBQUssRUFBRyxDQUFDO1lBRWxCLElBQUksQ0FBQyxzQkFBc0IsQ0FBRSxLQUFLLENBQUUsQ0FBQztRQUV0QyxDQUFDO0lBRUYsQ0FBQztTQUFNLENBQUM7UUFHUCxNQUFNLE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQyxtQkFBbUIsQ0FBRSxHQUFHLElBQUksQ0FBRSxDQUFDO1FBRXZELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxNQUFNLENBQUM7SUFFakMsQ0FBQztJQUdELElBQUssSUFBSSxDQUFDLGlCQUFpQixZQUFZLE9BQU8sRUFBRyxDQUFDO1FBRWpELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUUsSUFBSSxDQUFFLENBQUM7UUFFeEMsR0FBRyxDQUFFLE1BQU0sRUFBRSxxQkFBcUIsRUFBRTtZQUNuQyxHQUFHO2dCQUNGLE9BQU8sUUFBUSxDQUFDO1lBQ2pCLENBQUM7U0FDRCxDQUFFLENBQUM7UUFFSixPQUFPLE1BQU0sQ0FBQztJQUVmLENBQUM7SUFFRCxJQUFJLENBQUMsY0FBYyxDQUFFLElBQUksQ0FBRSxDQUFDO0lBRTVCLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDO0FBRS9CLENBQXlELENBQUM7QUFFMUQsTUFBTSxDQUFDLE1BQU0sQ0FBRSx1QkFBZSxDQUFDLFNBQVMsRUFBRSx3QkFBd0IsQ0FBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBDb25zdHJ1Y3RvckZ1bmN0aW9uIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuXHRjb25zdGFudHNcbn0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcblxuY29uc3Qge1xuXHRvZHAsXG5cdFN5bWJvbENvbnN0cnVjdG9yTmFtZVxufSA9IGNvbnN0YW50cztcblxuaW1wb3J0IHsgRXJyb3JzVHlwZXMgfSBmcm9tICcuLi8uLi9kZXNjcmlwdG9ycy9lcnJvcnMnO1xuY29uc3Qge1xuXHRXUk9OR19NT0RJRklDQVRJT05fUEFUVEVSTixcbn0gPSBFcnJvcnNUeXBlcztcblxuaW1wb3J0IFR5cGVzVXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuY29uc3Qge1xuXHRnZXRFeGlzdGVudEFzeW5jU3RhY2ssXG5cdG1ha2VGYWtlTW9kaWZpY2F0b3JUeXBlLFxufSA9IFR5cGVzVXRpbHM7XG5cbmltcG9ydCB7IGdldFN0YWNrIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IHRocm93TW9kaWZpY2F0aW9uRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvdGhyb3dNb2RpZmljYXRpb25FcnJvcic7XG5cbmltcG9ydCB7IGFkZFByb3BzLCBnZXRQcm9wcywgUHJvcHMgfSBmcm9tICcuL2FkZFByb3BzJztcblxuaW1wb3J0IHsgbWFrZUluc3RhbmNlTW9kaWZpY2F0b3IgfSBmcm9tICcuL0luc3RhbmNlTW9kaWZpY2F0b3InO1xuXG5pbXBvcnQgeyBvYmV5IH0gZnJvbSAnLi9vYmV5Q29uc3RydWN0b3InO1xuXG5jb25zdCBpbnZva2VQcmVIb29rcyA9IGZ1bmN0aW9uICggdGhpczogYW55ICkge1xuXG5cdGNvbnN0IHtcblx0XHR0eXBlLFxuXHRcdGV4aXN0ZW50SW5zdGFuY2UsXG5cdFx0YXJncyxcblx0XHRJbnN0YW5jZU1vZGlmaWNhdG9yXG5cdH0gPSB0aGlzO1xuXG5cdGNvbnN0IHtcblx0XHRjb2xsZWN0aW9uLFxuXHR9ID0gdHlwZTtcblxuXHRjb25zdCBob29rRGF0YSA9IHtcblx0XHR0eXBlLFxuXHRcdGV4aXN0ZW50SW5zdGFuY2UsXG5cdFx0YXJncyxcblx0XHRJbnN0YW5jZU1vZGlmaWNhdG9yXG5cdH07XG5cblx0Y29sbGVjdGlvbi5pbnZva2VIb29rKCAncHJlQ3JlYXRpb24nLCBob29rRGF0YSApO1xuXG5cdHR5cGUuaW52b2tlSG9vayggJ3ByZUNyZWF0aW9uJywgaG9va0RhdGEgKTtcblxufTtcblxuXG5jb25zdCBpbnZva2VQb3N0SG9va3MgPSBmdW5jdGlvbiAoIHRoaXM6IGFueSApIHtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcblx0Y29uc3QgY3JlYXRvciA9IHRoaXM7XG5cdGNvbnN0IHtcblx0XHRpbmhlcml0ZWRJbnN0YW5jZSxcblx0fSA9IGNyZWF0b3I7XG5cblx0Y29uc3QgcHJvcHMgPSBnZXRQcm9wcyhpbmhlcml0ZWRJbnN0YW5jZSkgYXMgUHJvcHM7XG5cblx0Y29uc3Qge1xuXHRcdF9fdHlwZV9fOiB0eXBlLFxuXHRcdF9fcGFyZW50X186IGV4aXN0ZW50SW5zdGFuY2UsXG5cdFx0X19hcmdzX186IGFyZ3MsXG5cdH0gPSBwcm9wcztcblxuXHRjb25zdCB7XG5cdFx0Y29sbGVjdGlvbixcblx0fSA9IHR5cGU7XG5cblx0Y29uc3QgaG9va1R5cGUgPSBpbmhlcml0ZWRJbnN0YW5jZSBpbnN0YW5jZW9mIEVycm9yID9cblx0XHQnY3JlYXRpb25FcnJvcicgOiAncG9zdENyZWF0aW9uJztcblxuXHRjb25zdCBob29rRGF0YSA9IHtcblx0XHR0eXBlLFxuXHRcdGV4aXN0ZW50SW5zdGFuY2UsXG5cdFx0aW5oZXJpdGVkSW5zdGFuY2UsXG5cdFx0YXJncyxcblx0XHRjcmVhdG9yXG5cdH07XG5cblx0cmV0dXJuIHtcblxuXHRcdHR5cGUgOiB0eXBlLmludm9rZUhvb2soIGhvb2tUeXBlLCBob29rRGF0YSApLFxuXG5cdFx0Y29sbGVjdGlvbiA6IGNvbGxlY3Rpb24uaW52b2tlSG9vayggaG9va1R5cGUsIGhvb2tEYXRhICksXG5cblx0fTtcblxufTtcblxuY29uc3QgcG9zdFByb2Nlc3NpbmcgPSBmdW5jdGlvbiAoIHRoaXM6IGFueSwgY29udGludWF0aW9uT2Y6IGFueSApIHtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcblx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdGNvbnN0IHtcblx0XHRzdGFjayxcblx0fSA9IHNlbGY7XG5cblx0aWYgKCAhc2VsZi5pbmhlcml0ZWRJbnN0YW5jZS5jb25zdHJ1Y3RvciApIHtcblx0XHRjb25zdCBtc2cgPSAnc2hvdWxkIGluaGVyaXQgZnJvbSBtbmVtb25pY2EgaW5zdGFuY2UnO1xuXHRcdHNlbGYudGhyb3dNb2RpZmljYXRpb25FcnJvciggbmV3IFdST05HX01PRElGSUNBVElPTl9QQVRURVJOKCBtc2csIHN0YWNrICkgKTtcblx0fVxuXG5cdGlmICggIXNlbGYuaW5oZXJpdGVkSW5zdGFuY2UuY29uc3RydWN0b3JbIFN5bWJvbENvbnN0cnVjdG9yTmFtZSBdICkge1xuXHRcdGNvbnN0IG1zZyA9ICdzaG91bGQgaW5oZXJpdCBmcm9tIG1uZW1vbmljYSBpbnN0YW5jZSc7XG5cdFx0c2VsZi50aHJvd01vZGlmaWNhdGlvbkVycm9yKCBuZXcgV1JPTkdfTU9ESUZJQ0FUSU9OX1BBVFRFUk4oIG1zZywgc3RhY2sgKSApO1xuXHR9XG5cblx0aWYgKCBjb250aW51YXRpb25PZiAmJiAhKCBzZWxmLmluaGVyaXRlZEluc3RhbmNlIGluc3RhbmNlb2YgY29udGludWF0aW9uT2YgKSApIHtcblx0XHQvLyBkZWJ1Z2dlcjtcblx0XHRjb25zdCBpY24gPSBzZWxmLmluaGVyaXRlZEluc3RhbmNlLmNvbnN0cnVjdG9yLm5hbWU7XG5cdFx0Y29uc3QgbXNnID0gYHNob3VsZCBpbmhlcml0IGZyb20gJHtjb250aW51YXRpb25PZi5UeXBlTmFtZX0gYnV0IGdvdCAke2ljbn1gO1xuXHRcdHNlbGYudGhyb3dNb2RpZmljYXRpb25FcnJvciggbmV3IFdST05HX01PRElGSUNBVElPTl9QQVRURVJOKCBtc2csIHN0YWNrICkgKTtcblx0XHQvLyB0aHJvdyBuZXcgV1JPTkdfTU9ESUZJQ0FUSU9OX1BBVFRFUk4obXNnLCBzZWxmLnN0YWNrKTtcblx0fVxuXG5cdG9kcCggc2VsZi5pbmhlcml0ZWRJbnN0YW5jZSwgJ19fc2VsZl9fJywge1xuXHRcdGdldCAoKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5pbmhlcml0ZWRJbnN0YW5jZTtcblx0XHR9XG5cdH0gKTtcblxuXHRzZWxmLmludm9rZVBvc3RIb29rcygpO1xuXG59O1xuXG5jb25zdCBhZGRUaGVuID0gZnVuY3Rpb24gKCB0aGlzOiBhbnksIHRoZW46IGFueSApIHtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcblx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0c2VsZi5pbmhlcml0ZWRJbnN0YW5jZSA9IHNlbGYuaW5oZXJpdGVkSW5zdGFuY2Vcblx0XHQvLyAudGhlbiggKCBpbnN0YW5jZTogYW55ICkgPT4ge1xuXHRcdC50aGVuKCAoKSA9PiB7XG5cdFx0XHQvLyBzZWxmLmluaGVyaXRlZEluc3RhbmNlID0gaW5zdGFuY2U7XG5cdFx0XHRzZWxmLmluaGVyaXRlZEluc3RhbmNlID1cblx0XHRcdFx0bmV3IEluc3RhbmNlQ3JlYXRvcihcblx0XHRcdFx0XHR0aGVuLnN1YnR5cGUsXG5cdFx0XHRcdFx0c2VsZi5pbmhlcml0ZWRJbnN0YW5jZSxcblx0XHRcdFx0XHR0aGVuLmFyZ3MsXG5cdFx0XHRcdFx0Ly8gd2FzIGNoYWluZWQgOlxuXHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQvLyBzZWxmLmV4aXN0ZW50SW5zdGFuY2Vcblx0XHRcdFx0KTtcblx0XHRcdHJldHVybiBzZWxmLmluaGVyaXRlZEluc3RhbmNlO1xuXHRcdH0gKTtcblxufTtcblxuXG5jb25zdCBtYWtlQXdhaXRlciA9IGZ1bmN0aW9uICggdGhpczogYW55LCB0eXBlOiBhbnksIHRoZW46IGFueSApIHtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcblx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0c2VsZi5pbmhlcml0ZWRJbnN0YW5jZSA9IHNlbGYuaW5oZXJpdGVkSW5zdGFuY2Vcblx0XHQudGhlbiggKCBpbnN0YW5jZTogYW55ICkgPT4ge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBpbnN0YW5jZSAhPT0gJ29iamVjdCcgKSB7XG5cdFx0XHRcdGlmICggc2VsZi5jb25maWcuYXdhaXRSZXR1cm4gKSB7XG5cdFx0XHRcdFx0Y29uc3QgbXNnID0gYHNob3VsZCBpbmhlcml0IGZyb20gJHt0eXBlLlR5cGVOYW1lfTogc2VlbXMgYXN5bmMgJHt0eXBlLlR5cGVOYW1lfSBoYXMgbm8gcmV0dXJuIHN0YXRlbWVudGA7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFdST05HX01PRElGSUNBVElPTl9QQVRURVJOKCBtc2csIHNlbGYuc3RhY2sgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhKCBpbnN0YW5jZSBpbnN0YW5jZW9mIHNlbGYudHlwZSApICkge1xuXHRcdFx0XHRjb25zdCBpY24gPSBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5uYW1lO1xuXHRcdFx0XHRjb25zdCBtc2cgPSBgc2hvdWxkIGluaGVyaXQgZnJvbSAke3R5cGUuVHlwZU5hbWV9IGJ1dCBnb3QgJHtpY259YDtcblx0XHRcdFx0Ly8gc2VsZi50aHJvd01vZGlmaWNhdGlvbkVycm9yKG5ldyBXUk9OR19NT0RJRklDQVRJT05fUEFUVEVSTihtc2csIHNlbGYuc3RhY2spKTtcblx0XHRcdFx0dGhyb3cgbmV3IFdST05HX01PRElGSUNBVElPTl9QQVRURVJOKCBtc2csIHNlbGYuc3RhY2sgKTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZi5pbmhlcml0ZWRJbnN0YW5jZSA9IGluc3RhbmNlO1xuXG5cdFx0XHRpZiAoIHNlbGYuaW5oZXJpdGVkSW5zdGFuY2UuX19zZWxmX18gIT09IHNlbGYuaW5oZXJpdGVkSW5zdGFuY2UgKSB7XG5cdFx0XHRcdC8vIGl0IHdhcyBhc3luYyBpbnN0YW5jZSxcblx0XHRcdFx0Ly8gc28gd2UgaGF2ZSB0byBhZGQgYWxsIHRoZSBzdHVmZlxuXHRcdFx0XHQvLyBmb3Igc3luYyBpbnN0YW5jZXMgaXQgd2FzIGRvbmUgYWxyZWFkeVxuXHRcdFx0XHRzZWxmLnBvc3RQcm9jZXNzaW5nKCB0eXBlICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZWxmLmluaGVyaXRlZEluc3RhbmNlO1xuXG5cdFx0fSApXG5cdFx0LmNhdGNoKCAoIGVycm9yOiBFcnJvciApID0+IHtcblx0XHRcdGlmICggc2VsZi5jb25maWcuYmxvY2tFcnJvcnMgKSB7XG5cdFx0XHRcdHNlbGYudGhyb3dNb2RpZmljYXRpb25FcnJvciggZXJyb3IgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRpZiAoIHRoZW4gKSB7XG5cdFx0c2VsZi5hZGRUaGVuKCB0aGVuICk7XG5cdH1cblxuXHR0eXBlLnN1YnR5cGVzLmZvckVhY2goICggc3VidHlwZTogYW55LCBuYW1lOiBzdHJpbmcgKSA9PiB7XG5cdFx0c2VsZi5pbmhlcml0ZWRJbnN0YW5jZVsgbmFtZSBdID0gKCAuLi5hcmdzOiBhbnlbXSApID0+IHtcblx0XHRcdHNlbGYuaW5oZXJpdGVkSW5zdGFuY2UgPSBzZWxmLm1ha2VBd2FpdGVyKCBzdWJ0eXBlLCB7XG5cdFx0XHRcdG5hbWUsXG5cdFx0XHRcdHN1YnR5cGUsXG5cdFx0XHRcdGFyZ3MsXG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gc2VsZi5pbmhlcml0ZWRJbnN0YW5jZTtcblx0XHR9O1xuXHR9ICk7XG5cblx0cmV0dXJuIHNlbGYuaW5oZXJpdGVkSW5zdGFuY2U7XG5cbn07XG5cbmNvbnN0IEluc3RhbmNlQ3JlYXRvclByb3RvdHlwZSA9IHtcblx0Z2V0RXhpc3RlbnRBc3luY1N0YWNrLFxuXHRwb3N0UHJvY2Vzc2luZyxcblx0bWFrZUF3YWl0ZXIsXG5cdGFkZFByb3BzLFxuXHRhZGRUaGVuLFxuXHRpbnZva2VQcmVIb29rcyxcblx0aW52b2tlUG9zdEhvb2tzLFxuXHR0aHJvd01vZGlmaWNhdGlvbkVycm9yXG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlXG5leHBvcnQgY29uc3QgSW5zdGFuY2VDcmVhdG9yID0gZnVuY3Rpb24gKCB0aGlzOiBhbnksIHR5cGU6IGFueSwgZXhpc3RlbnRJbnN0YW5jZTogYW55LCBhcmdzOiBhbnlbXSwgY2hhaW5lZDogYm9vbGVhbiApIHtcblxuXHRjb25zdCB7XG5cdFx0Y29uc3RydWN0SGFuZGxlcixcblx0XHRwcm90byxcblx0XHRjb25maWcsXG5cdFx0VHlwZU5hbWVcblx0fSA9IHR5cGU7XG5cblx0Y29uc3Qge1xuXHRcdE1vZGlmaWNhdGlvbkNvbnN0cnVjdG9yLFxuXHRcdGJsb2NrRXJyb3JzLFxuXHRcdHN1Ym1pdFN0YWNrXG5cdH0gPSBjb25maWc7XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcblx0Y29uc3QgbWMgPSBNb2RpZmljYXRpb25Db25zdHJ1Y3Rvciggb2JleSApO1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuXHRjb25zdCBzZWxmID0gdGhpcztcblxuXHRjb25zdCBNb2RpZmljYXRvclR5cGUgPSBjb25zdHJ1Y3RIYW5kbGVyKCk7XG5cblx0T2JqZWN0LmFzc2lnbiggc2VsZiwge1xuXG5cdFx0dHlwZSxcblx0XHRUeXBlTmFtZSxcblxuXHRcdGV4aXN0ZW50SW5zdGFuY2UsXG5cblx0XHRnZXQgYXJncyAoKSB7XG5cdFx0XHRyZXR1cm4gYXJncztcblx0XHR9LFxuXG5cdFx0TW9kaWZpY2F0aW9uQ29uc3RydWN0b3IgOiBtYyxcblx0XHRNb2RpZmljYXRvclR5cGUsXG5cblx0XHRjb25maWcsXG5cblx0XHRwcm90b1xuXG5cdH0gKTtcblxuXHRpZiAoIHN1Ym1pdFN0YWNrIHx8IGNoYWluZWQgKSB7XG5cdFx0Y29uc3Qgc3RhY2tBZGRpdGlvbjogc3RyaW5nW10gPSBjaGFpbmVkID8gc2VsZi5nZXRFeGlzdGVudEFzeW5jU3RhY2soIGV4aXN0ZW50SW5zdGFuY2UgKSA6IFtdO1xuXHRcdGNvbnN0IHRpdGxlID0gYFxcbjwtLSBjcmVhdGlvbiBvZiBbICR7VHlwZU5hbWV9IF0gdHJhY2VkIC0tPmA7XG5cdFx0aWYgKCBzdWJtaXRTdGFjayApIHtcblx0XHRcdGdldFN0YWNrLmNhbGwoIHNlbGYsIHRpdGxlLCBzdGFja0FkZGl0aW9uICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlbGYuc3RhY2sgPSB0aXRsZTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIGJsb2NrRXJyb3JzICYmIGV4aXN0ZW50SW5zdGFuY2UgaW5zdGFuY2VvZiBFcnJvciApIHtcblxuXHRcdHNlbGYuTW9kaWZpY2F0b3JUeXBlID0gbWFrZUZha2VNb2RpZmljYXRvclR5cGUoIFR5cGVOYW1lICk7XG5cblx0XHRzZWxmLkluc3RhbmNlTW9kaWZpY2F0b3IgPSBtYWtlSW5zdGFuY2VNb2RpZmljYXRvciggc2VsZiApO1xuXG5cdFx0dGhyb3cgbmV3IHNlbGYuSW5zdGFuY2VNb2RpZmljYXRvciggLi4uYXJncyApO1xuXG5cdH1cblxuXHRzZWxmLmludm9rZVByZUhvb2tzKCk7XG5cblx0c2VsZi5JbnN0YW5jZU1vZGlmaWNhdG9yID0gbWFrZUluc3RhbmNlTW9kaWZpY2F0b3IoIHNlbGYgKTtcblxuXHRpZiAoIGJsb2NrRXJyb3JzICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIENvbnN0cnVjdG9yIEludm9jYXRpb24gSXRzZWxmXG5cdFx0XHRjb25zdCBhbnN3ZXIgPSBuZXcgc2VsZi5JbnN0YW5jZU1vZGlmaWNhdG9yKCAuLi5hcmdzICk7XG5cdFx0XHQvLyBkZWJ1Z2dlcjtcblx0XHRcdHNlbGYuaW5oZXJpdGVkSW5zdGFuY2UgPSBhbnN3ZXI7XG5cblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XG5cblx0XHRcdHNlbGYudGhyb3dNb2RpZmljYXRpb25FcnJvciggZXJyb3IgKTtcblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQ29uc3RydWN0b3IgSW52b2NhdGlvbiBJdHNlbGZcblx0XHRjb25zdCBhbnN3ZXIgPSBuZXcgc2VsZi5JbnN0YW5jZU1vZGlmaWNhdG9yKCAuLi5hcmdzICk7XG5cdFx0Ly8gZGVidWdnZXI7XG5cdFx0c2VsZi5pbmhlcml0ZWRJbnN0YW5jZSA9IGFuc3dlcjtcblxuXHR9XG5cblxuXHRpZiAoIHNlbGYuaW5oZXJpdGVkSW5zdGFuY2UgaW5zdGFuY2VvZiBQcm9taXNlICkge1xuXG5cdFx0Y29uc3Qgd2FpdGVyID0gc2VsZi5tYWtlQXdhaXRlciggdHlwZSApO1xuXG5cdFx0b2RwKCB3YWl0ZXIsIFN5bWJvbENvbnN0cnVjdG9yTmFtZSwge1xuXHRcdFx0Z2V0ICgpIHtcblx0XHRcdFx0cmV0dXJuIFR5cGVOYW1lO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdHJldHVybiB3YWl0ZXI7XG5cblx0fVxuXG5cdHNlbGYucG9zdFByb2Nlc3NpbmcoIHR5cGUgKTtcblxuXHRyZXR1cm4gc2VsZi5pbmhlcml0ZWRJbnN0YW5jZTtcblxufSBhcyBDb25zdHJ1Y3RvckZ1bmN0aW9uPHR5cGVvZiBJbnN0YW5jZUNyZWF0b3JQcm90b3R5cGU+O1xuXG5PYmplY3QuYXNzaWduKCBJbnN0YW5jZUNyZWF0b3IucHJvdG90eXBlLCBJbnN0YW5jZUNyZWF0b3JQcm90b3R5cGUgKTtcbiJdfQ==