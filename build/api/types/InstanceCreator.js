'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstanceCreator = void 0;
const constants_1 = require("../../constants");
const { odp, SymbolConstructorName } = constants_1.constants;
const errors_1 = require("../../descriptors/errors");
const { WRONG_MODIFICATION_PATTERN, } = errors_1.ErrorsTypes;
const utils_1 = require("../utils");
const { getExistentAsyncStack, makeFakeModificatorType, } = utils_1.default;
const errors_2 = require("../errors");
const throwModificationError_1 = require("../errors/throwModificationError");
const addProps_1 = require("./addProps");
const InstanceModificator_1 = require("./InstanceModificator");
const obeyConstructor_1 = require("./obeyConstructor");
const invokePreHooks = function () {
    const { type, existentInstance, args, InstanceModificator } = this;
    const { collection, } = type;
    const hookData = {
        type,
        existentInstance,
        args,
        InstanceModificator
    };
    collection.invokeHook('preCreation', hookData);
    type.invokeHook('preCreation', hookData);
};
const invokePostHooks = function () {
    const creator = this;
    const { inheritedInstance, } = creator;
    const { __type__: type, __parent__: existentInstance, __args__: args, } = inheritedInstance;
    const { collection, } = type;
    const hookType = inheritedInstance instanceof Error ?
        'creationError' : 'postCreation';
    const hookData = {
        type,
        existentInstance,
        inheritedInstance,
        args,
        creator
    };
    return {
        type: type.invokeHook(hookType, hookData),
        collection: collection.invokeHook(hookType, hookData),
    };
};
const postProcessing = function (continuationOf) {
    const self = this;
    const { stack, } = self;
    if (!self.inheritedInstance.constructor) {
        const msg = 'should inherit from mnemonica instance';
        self.throwModificationError(new WRONG_MODIFICATION_PATTERN(msg, stack));
    }
    if (!self.inheritedInstance.constructor[SymbolConstructorName]) {
        const msg = 'should inherit from mnemonica instance';
        self.throwModificationError(new WRONG_MODIFICATION_PATTERN(msg, stack));
    }
    if (continuationOf && !(self.inheritedInstance instanceof continuationOf)) {
        const icn = self.inheritedInstance.constructor.name;
        const msg = `should inherit from ${continuationOf.TypeName} but got ${icn}`;
        self.throwModificationError(new WRONG_MODIFICATION_PATTERN(msg, stack));
    }
    odp(self.inheritedInstance, '__self__', {
        get() {
            return self.inheritedInstance;
        }
    });
    self.invokePostHooks();
};
const addThen = function (then) {
    const self = this;
    self.inheritedInstance = self.inheritedInstance
        .then(() => {
        self.inheritedInstance =
            new exports.InstanceCreator(then.subtype, self.inheritedInstance, then.args, true);
        return self.inheritedInstance;
    });
};
const makeAwaiter = function (type, then) {
    const self = this;
    self.inheritedInstance = self.inheritedInstance
        .then((instance) => {
        if (typeof instance !== 'object') {
            if (self.config.awaitReturn) {
                const msg = `should inherit from ${type.TypeName}: seems async ${type.TypeName} has no return statement`;
                throw new WRONG_MODIFICATION_PATTERN(msg, self.stack);
            }
            else {
                return instance;
            }
        }
        if (!(instance instanceof self.type)) {
            const icn = instance.constructor.name;
            const msg = `should inherit from ${type.TypeName} but got ${icn}`;
            throw new WRONG_MODIFICATION_PATTERN(msg, self.stack);
        }
        self.inheritedInstance = instance;
        if (self.inheritedInstance.__self__ !== self.inheritedInstance) {
            self.postProcessing(type);
        }
        return self.inheritedInstance;
    })
        .catch((error) => {
        if (self.config.blockErrors) {
            self.throwModificationError(error);
        }
        else {
            throw error;
        }
    });
    if (then) {
        self.addThen(then);
    }
    type.subtypes.forEach((subtype, name) => {
        self.inheritedInstance[name] = (...args) => {
            self.inheritedInstance = self.makeAwaiter(subtype, {
                name,
                subtype,
                args,
            });
            return self.inheritedInstance;
        };
    });
    return self.inheritedInstance;
};
const InstanceCreatorPrototype = {
    getExistentAsyncStack,
    postProcessing,
    makeAwaiter,
    addProps: addProps_1.addProps,
    addThen,
    invokePreHooks,
    invokePostHooks,
    throwModificationError: throwModificationError_1.throwModificationError
};
exports.InstanceCreator = function (type, existentInstance, args, chained) {
    const { constructHandler, proto, config, TypeName } = type;
    const { ModificationConstructor, blockErrors, submitStack } = config;
    const mc = ModificationConstructor(obeyConstructor_1.obey);
    const self = this;
    const ModificatorType = constructHandler();
    Object.assign(self, {
        type,
        TypeName,
        existentInstance,
        get args() {
            return args;
        },
        ModificationConstructor: mc,
        ModificatorType,
        config,
        proto
    });
    if (submitStack || chained) {
        const stackAddition = chained ? self.getExistentAsyncStack(existentInstance) : [];
        const title = `\n<-- creation of [ ${TypeName} ] traced -->`;
        if (submitStack) {
            errors_2.getStack.call(self, title, stackAddition);
        }
        else {
            self.stack = title;
        }
    }
    if (blockErrors && existentInstance instanceof Error) {
        self.ModificatorType = makeFakeModificatorType(TypeName);
        self.InstanceModificator = (0, InstanceModificator_1.makeInstanceModificator)(self);
        throw new self.InstanceModificator(...args);
    }
    self.invokePreHooks();
    self.InstanceModificator = (0, InstanceModificator_1.makeInstanceModificator)(self);
    if (blockErrors) {
        try {
            const answer = new self.InstanceModificator(...args);
            self.inheritedInstance = answer;
        }
        catch (error) {
            self.throwModificationError(error);
        }
    }
    else {
        const answer = new self.InstanceModificator(...args);
        self.inheritedInstance = answer;
    }
    if (self.inheritedInstance instanceof Promise) {
        const waiter = self.makeAwaiter(type);
        odp(waiter, SymbolConstructorName, {
            get() {
                return TypeName;
            }
        });
        return waiter;
    }
    self.postProcessing(type);
    return self.inheritedInstance;
};
Object.assign(exports.InstanceCreator.prototype, InstanceCreatorPrototype);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5zdGFuY2VDcmVhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2FwaS90eXBlcy9JbnN0YW5jZUNyZWF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsWUFBWSxDQUFDOzs7QUFJYiwrQ0FFeUI7QUFFekIsTUFBTSxFQUNMLEdBQUcsRUFDSCxxQkFBcUIsRUFDckIsR0FBRyxxQkFBUyxDQUFDO0FBRWQscURBQXVEO0FBQ3ZELE1BQU0sRUFDTCwwQkFBMEIsR0FDMUIsR0FBRyxvQkFBVyxDQUFDO0FBRWhCLG9DQUFrQztBQUNsQyxNQUFNLEVBQ0wscUJBQXFCLEVBQ3JCLHVCQUF1QixHQUN2QixHQUFHLGVBQVUsQ0FBQztBQUVmLHNDQUFxQztBQUNyQyw2RUFBMEU7QUFFMUUseUNBQXNDO0FBRXRDLCtEQUFnRTtBQUVoRSx1REFBeUM7QUFFekMsTUFBTSxjQUFjLEdBQUc7SUFFdEIsTUFBTSxFQUNMLElBQUksRUFDSixnQkFBZ0IsRUFDaEIsSUFBSSxFQUNKLG1CQUFtQixFQUNuQixHQUFHLElBQUksQ0FBQztJQUVULE1BQU0sRUFDTCxVQUFVLEdBQ1YsR0FBRyxJQUFJLENBQUM7SUFFVCxNQUFNLFFBQVEsR0FBRztRQUNoQixJQUFJO1FBQ0osZ0JBQWdCO1FBQ2hCLElBQUk7UUFDSixtQkFBbUI7S0FDbkIsQ0FBQztJQUVGLFVBQVUsQ0FBQyxVQUFVLENBQUUsYUFBYSxFQUFFLFFBQVEsQ0FBRSxDQUFDO0lBRWpELElBQUksQ0FBQyxVQUFVLENBQUUsYUFBYSxFQUFFLFFBQVEsQ0FBRSxDQUFDO0FBRTVDLENBQUMsQ0FBQztBQUdGLE1BQU0sZUFBZSxHQUFHO0lBR3ZCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQztJQUNyQixNQUFNLEVBQ0wsaUJBQWlCLEdBQ2pCLEdBQUcsT0FBTyxDQUFDO0lBRVosTUFBTSxFQUNMLFFBQVEsRUFBRSxJQUFJLEVBQ2QsVUFBVSxFQUFFLGdCQUFnQixFQUM1QixRQUFR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O1lBRUosTUFBTSxNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUMsbUJBQW1CLENBQUUsR0FBRyxJQUFJLENBQUUsQ0FBQztZQUV2RCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsTUFBTSxDQUFDO1FBRWpDLENBQUM7UUFBQyxPQUFRLEtBQUssRUFBRyxDQUFDO1lBRWxCLElBQUksQ0FBQyxzQkFBc0IsQ0FBRSxLQUFLLENBQUUsQ0FBQztRQUV0QyxDQUFDO0lBRUYsQ0FBQztTQUFNLENBQUM7UUFHUCxNQUFNLE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQyxtQkFBbUIsQ0FBRSxHQUFHLElBQUksQ0FBRSxDQUFDO1FBRXZELElBQUksQ0FBQyxpQkFBaUIsR0FBRyxNQUFNLENBQUM7SUFFakMsQ0FBQztJQUdELElBQUssSUFBSSxDQUFDLGlCQUFpQixZQUFZLE9BQU8sRUFBRyxDQUFDO1FBRWpELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUUsSUFBSSxDQUFFLENBQUM7UUFFeEMsR0FBRyxDQUFFLE1BQU0sRUFBRSxxQkFBcUIsRUFBRTtZQUNuQyxHQUFHO2dCQUNGLE9BQU8sUUFBUSxDQUFDO1lBQ2pCLENBQUM7U0FDRCxDQUFFLENBQUM7UUFFSixPQUFPLE1BQU0sQ0FBQztJQUVmLENBQUM7SUFFRCxJQUFJLENBQUMsY0FBYyxDQUFFLElBQUksQ0FBRSxDQUFDO0lBRTVCLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDO0FBRS9CLENBQXlELENBQUM7QUFFMUQsTUFBTSxDQUFDLE1BQU0sQ0FBRSx1QkFBZSxDQUFDLFNBQVMsRUFBRSx3QkFBd0IsQ0FBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBDb25zdHJ1Y3RvckZ1bmN0aW9uIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuXHRjb25zdGFudHNcbn0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcblxuY29uc3Qge1xuXHRvZHAsXG5cdFN5bWJvbENvbnN0cnVjdG9yTmFtZVxufSA9IGNvbnN0YW50cztcblxuaW1wb3J0IHsgRXJyb3JzVHlwZXMgfSBmcm9tICcuLi8uLi9kZXNjcmlwdG9ycy9lcnJvcnMnO1xuY29uc3Qge1xuXHRXUk9OR19NT0RJRklDQVRJT05fUEFUVEVSTixcbn0gPSBFcnJvcnNUeXBlcztcblxuaW1wb3J0IFR5cGVzVXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuY29uc3Qge1xuXHRnZXRFeGlzdGVudEFzeW5jU3RhY2ssXG5cdG1ha2VGYWtlTW9kaWZpY2F0b3JUeXBlLFxufSA9IFR5cGVzVXRpbHM7XG5cbmltcG9ydCB7IGdldFN0YWNrIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IHRocm93TW9kaWZpY2F0aW9uRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvdGhyb3dNb2RpZmljYXRpb25FcnJvcic7XG5cbmltcG9ydCB7IGFkZFByb3BzIH0gZnJvbSAnLi9hZGRQcm9wcyc7XG5cbmltcG9ydCB7IG1ha2VJbnN0YW5jZU1vZGlmaWNhdG9yIH0gZnJvbSAnLi9JbnN0YW5jZU1vZGlmaWNhdG9yJztcblxuaW1wb3J0IHsgb2JleSB9IGZyb20gJy4vb2JleUNvbnN0cnVjdG9yJztcblxuY29uc3QgaW52b2tlUHJlSG9va3MgPSBmdW5jdGlvbiAoIHRoaXM6IGFueSApIHtcblxuXHRjb25zdCB7XG5cdFx0dHlwZSxcblx0XHRleGlzdGVudEluc3RhbmNlLFxuXHRcdGFyZ3MsXG5cdFx0SW5zdGFuY2VNb2RpZmljYXRvclxuXHR9ID0gdGhpcztcblxuXHRjb25zdCB7XG5cdFx0Y29sbGVjdGlvbixcblx0fSA9IHR5cGU7XG5cblx0Y29uc3QgaG9va0RhdGEgPSB7XG5cdFx0dHlwZSxcblx0XHRleGlzdGVudEluc3RhbmNlLFxuXHRcdGFyZ3MsXG5cdFx0SW5zdGFuY2VNb2RpZmljYXRvclxuXHR9O1xuXG5cdGNvbGxlY3Rpb24uaW52b2tlSG9vayggJ3ByZUNyZWF0aW9uJywgaG9va0RhdGEgKTtcblxuXHR0eXBlLmludm9rZUhvb2soICdwcmVDcmVhdGlvbicsIGhvb2tEYXRhICk7XG5cbn07XG5cblxuY29uc3QgaW52b2tlUG9zdEhvb2tzID0gZnVuY3Rpb24gKCB0aGlzOiBhbnkgKSB7XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG5cdGNvbnN0IGNyZWF0b3IgPSB0aGlzO1xuXHRjb25zdCB7XG5cdFx0aW5oZXJpdGVkSW5zdGFuY2UsXG5cdH0gPSBjcmVhdG9yO1xuXG5cdGNvbnN0IHtcblx0XHRfX3R5cGVfXzogdHlwZSxcblx0XHRfX3BhcmVudF9fOiBleGlzdGVudEluc3RhbmNlLFxuXHRcdF9fYXJnc19fOiBhcmdzLFxuXHR9ID0gaW5oZXJpdGVkSW5zdGFuY2U7XG5cblx0Y29uc3Qge1xuXHRcdGNvbGxlY3Rpb24sXG5cdH0gPSB0eXBlO1xuXG5cdGNvbnN0IGhvb2tUeXBlID0gaW5oZXJpdGVkSW5zdGFuY2UgaW5zdGFuY2VvZiBFcnJvciA/XG5cdFx0J2NyZWF0aW9uRXJyb3InIDogJ3Bvc3RDcmVhdGlvbic7XG5cblx0Y29uc3QgaG9va0RhdGEgPSB7XG5cdFx0dHlwZSxcblx0XHRleGlzdGVudEluc3RhbmNlLFxuXHRcdGluaGVyaXRlZEluc3RhbmNlLFxuXHRcdGFyZ3MsXG5cdFx0Y3JlYXRvclxuXHR9O1xuXG5cdHJldHVybiB7XG5cblx0XHR0eXBlIDogdHlwZS5pbnZva2VIb29rKCBob29rVHlwZSwgaG9va0RhdGEgKSxcblxuXHRcdGNvbGxlY3Rpb24gOiBjb2xsZWN0aW9uLmludm9rZUhvb2soIGhvb2tUeXBlLCBob29rRGF0YSApLFxuXG5cdH07XG5cbn07XG5cbmNvbnN0IHBvc3RQcm9jZXNzaW5nID0gZnVuY3Rpb24gKCB0aGlzOiBhbnksIGNvbnRpbnVhdGlvbk9mOiBhbnkgKSB7XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG5cdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRjb25zdCB7XG5cdFx0c3RhY2ssXG5cdH0gPSBzZWxmO1xuXG5cdGlmICggIXNlbGYuaW5oZXJpdGVkSW5zdGFuY2UuY29uc3RydWN0b3IgKSB7XG5cdFx0Y29uc3QgbXNnID0gJ3Nob3VsZCBpbmhlcml0IGZyb20gbW5lbW9uaWNhIGluc3RhbmNlJztcblx0XHRzZWxmLnRocm93TW9kaWZpY2F0aW9uRXJyb3IoIG5ldyBXUk9OR19NT0RJRklDQVRJT05fUEFUVEVSTiggbXNnLCBzdGFjayApICk7XG5cdH1cblxuXHRpZiAoICFzZWxmLmluaGVyaXRlZEluc3RhbmNlLmNvbnN0cnVjdG9yWyBTeW1ib2xDb25zdHJ1Y3Rvck5hbWUgXSApIHtcblx0XHRjb25zdCBtc2cgPSAnc2hvdWxkIGluaGVyaXQgZnJvbSBtbmVtb25pY2EgaW5zdGFuY2UnO1xuXHRcdHNlbGYudGhyb3dNb2RpZmljYXRpb25FcnJvciggbmV3IFdST05HX01PRElGSUNBVElPTl9QQVRURVJOKCBtc2csIHN0YWNrICkgKTtcblx0fVxuXG5cdGlmICggY29udGludWF0aW9uT2YgJiYgISggc2VsZi5pbmhlcml0ZWRJbnN0YW5jZSBpbnN0YW5jZW9mIGNvbnRpbnVhdGlvbk9mICkgKSB7XG5cdFx0Ly8gZGVidWdnZXI7XG5cdFx0Y29uc3QgaWNuID0gc2VsZi5pbmhlcml0ZWRJbnN0YW5jZS5jb25zdHJ1Y3Rvci5uYW1lO1xuXHRcdGNvbnN0IG1zZyA9IGBzaG91bGQgaW5oZXJpdCBmcm9tICR7Y29udGludWF0aW9uT2YuVHlwZU5hbWV9IGJ1dCBnb3QgJHtpY259YDtcblx0XHRzZWxmLnRocm93TW9kaWZpY2F0aW9uRXJyb3IoIG5ldyBXUk9OR19NT0RJRklDQVRJT05fUEFUVEVSTiggbXNnLCBzdGFjayApICk7XG5cdFx0Ly8gdGhyb3cgbmV3IFdST05HX01PRElGSUNBVElPTl9QQVRURVJOKG1zZywgc2VsZi5zdGFjayk7XG5cdH1cblxuXHRvZHAoIHNlbGYuaW5oZXJpdGVkSW5zdGFuY2UsICdfX3NlbGZfXycsIHtcblx0XHRnZXQgKCkge1xuXHRcdFx0cmV0dXJuIHNlbGYuaW5oZXJpdGVkSW5zdGFuY2U7XG5cdFx0fVxuXHR9ICk7XG5cblx0c2VsZi5pbnZva2VQb3N0SG9va3MoKTtcblxufTtcblxuY29uc3QgYWRkVGhlbiA9IGZ1bmN0aW9uICggdGhpczogYW55LCB0aGVuOiBhbnkgKSB7XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG5cdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdHNlbGYuaW5oZXJpdGVkSW5zdGFuY2UgPSBzZWxmLmluaGVyaXRlZEluc3RhbmNlXG5cdFx0Ly8gLnRoZW4oICggaW5zdGFuY2U6IGFueSApID0+IHtcblx0XHQudGhlbiggKCkgPT4ge1xuXHRcdFx0Ly8gc2VsZi5pbmhlcml0ZWRJbnN0YW5jZSA9IGluc3RhbmNlO1xuXHRcdFx0c2VsZi5pbmhlcml0ZWRJbnN0YW5jZSA9XG5cdFx0XHRcdG5ldyBJbnN0YW5jZUNyZWF0b3IoXG5cdFx0XHRcdFx0dGhlbi5zdWJ0eXBlLFxuXHRcdFx0XHRcdHNlbGYuaW5oZXJpdGVkSW5zdGFuY2UsXG5cdFx0XHRcdFx0dGhlbi5hcmdzLFxuXHRcdFx0XHRcdC8vIHdhcyBjaGFpbmVkIDpcblx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0Ly8gc2VsZi5leGlzdGVudEluc3RhbmNlXG5cdFx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gc2VsZi5pbmhlcml0ZWRJbnN0YW5jZTtcblx0XHR9ICk7XG5cbn07XG5cblxuY29uc3QgbWFrZUF3YWl0ZXIgPSBmdW5jdGlvbiAoIHRoaXM6IGFueSwgdHlwZTogYW55LCB0aGVuOiBhbnkgKSB7XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG5cdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdHNlbGYuaW5oZXJpdGVkSW5zdGFuY2UgPSBzZWxmLmluaGVyaXRlZEluc3RhbmNlXG5cdFx0LnRoZW4oICggaW5zdGFuY2U6IGFueSApID0+IHtcblxuXHRcdFx0aWYgKCB0eXBlb2YgaW5zdGFuY2UgIT09ICdvYmplY3QnICkge1xuXHRcdFx0XHRpZiAoIHNlbGYuY29uZmlnLmF3YWl0UmV0dXJuICkge1xuXHRcdFx0XHRcdGNvbnN0IG1zZyA9IGBzaG91bGQgaW5oZXJpdCBmcm9tICR7dHlwZS5UeXBlTmFtZX06IHNlZW1zIGFzeW5jICR7dHlwZS5UeXBlTmFtZX0gaGFzIG5vIHJldHVybiBzdGF0ZW1lbnRgO1xuXHRcdFx0XHRcdHRocm93IG5ldyBXUk9OR19NT0RJRklDQVRJT05fUEFUVEVSTiggbXNnLCBzZWxmLnN0YWNrICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGluc3RhbmNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggISggaW5zdGFuY2UgaW5zdGFuY2VvZiBzZWxmLnR5cGUgKSApIHtcblx0XHRcdFx0Y29uc3QgaWNuID0gaW5zdGFuY2UuY29uc3RydWN0b3IubmFtZTtcblx0XHRcdFx0Y29uc3QgbXNnID0gYHNob3VsZCBpbmhlcml0IGZyb20gJHt0eXBlLlR5cGVOYW1lfSBidXQgZ290ICR7aWNufWA7XG5cdFx0XHRcdC8vIHNlbGYudGhyb3dNb2RpZmljYXRpb25FcnJvcihuZXcgV1JPTkdfTU9ESUZJQ0FUSU9OX1BBVFRFUk4obXNnLCBzZWxmLnN0YWNrKSk7XG5cdFx0XHRcdHRocm93IG5ldyBXUk9OR19NT0RJRklDQVRJT05fUEFUVEVSTiggbXNnLCBzZWxmLnN0YWNrICk7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGYuaW5oZXJpdGVkSW5zdGFuY2UgPSBpbnN0YW5jZTtcblxuXHRcdFx0aWYgKCBzZWxmLmluaGVyaXRlZEluc3RhbmNlLl9fc2VsZl9fICE9PSBzZWxmLmluaGVyaXRlZEluc3RhbmNlICkge1xuXHRcdFx0XHQvLyBpdCB3YXMgYXN5bmMgaW5zdGFuY2UsXG5cdFx0XHRcdC8vIHNvIHdlIGhhdmUgdG8gYWRkIGFsbCB0aGUgc3R1ZmZcblx0XHRcdFx0Ly8gZm9yIHN5bmMgaW5zdGFuY2VzIGl0IHdhcyBkb25lIGFscmVhZHlcblx0XHRcdFx0c2VsZi5wb3N0UHJvY2Vzc2luZyggdHlwZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2VsZi5pbmhlcml0ZWRJbnN0YW5jZTtcblxuXHRcdH0gKVxuXHRcdC5jYXRjaCggKCBlcnJvcjogRXJyb3IgKSA9PiB7XG5cdFx0XHRpZiAoIHNlbGYuY29uZmlnLmJsb2NrRXJyb3JzICkge1xuXHRcdFx0XHRzZWxmLnRocm93TW9kaWZpY2F0aW9uRXJyb3IoIGVycm9yICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0aWYgKCB0aGVuICkge1xuXHRcdHNlbGYuYWRkVGhlbiggdGhlbiApO1xuXHR9XG5cblx0dHlwZS5zdWJ0eXBlcy5mb3JFYWNoKCAoIHN1YnR5cGU6IGFueSwgbmFtZTogc3RyaW5nICkgPT4ge1xuXHRcdHNlbGYuaW5oZXJpdGVkSW5zdGFuY2VbIG5hbWUgXSA9ICggLi4uYXJnczogYW55W10gKSA9PiB7XG5cdFx0XHRzZWxmLmluaGVyaXRlZEluc3RhbmNlID0gc2VsZi5tYWtlQXdhaXRlciggc3VidHlwZSwge1xuXHRcdFx0XHRuYW1lLFxuXHRcdFx0XHRzdWJ0eXBlLFxuXHRcdFx0XHRhcmdzLFxuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHNlbGYuaW5oZXJpdGVkSW5zdGFuY2U7XG5cdFx0fTtcblx0fSApO1xuXG5cdHJldHVybiBzZWxmLmluaGVyaXRlZEluc3RhbmNlO1xuXG59O1xuXG5jb25zdCBJbnN0YW5jZUNyZWF0b3JQcm90b3R5cGUgPSB7XG5cdGdldEV4aXN0ZW50QXN5bmNTdGFjayxcblx0cG9zdFByb2Nlc3NpbmcsXG5cdG1ha2VBd2FpdGVyLFxuXHRhZGRQcm9wcyxcblx0YWRkVGhlbixcblx0aW52b2tlUHJlSG9va3MsXG5cdGludm9rZVBvc3RIb29rcyxcblx0dGhyb3dNb2RpZmljYXRpb25FcnJvclxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuLy8gQHRzLWlnbm9yZVxuZXhwb3J0IGNvbnN0IEluc3RhbmNlQ3JlYXRvciA9IGZ1bmN0aW9uICggdGhpczogYW55LCB0eXBlOiBhbnksIGV4aXN0ZW50SW5zdGFuY2U6IGFueSwgYXJnczogYW55W10sIGNoYWluZWQ6IGJvb2xlYW4gKSB7XG5cblx0Y29uc3Qge1xuXHRcdGNvbnN0cnVjdEhhbmRsZXIsXG5cdFx0cHJvdG8sXG5cdFx0Y29uZmlnLFxuXHRcdFR5cGVOYW1lXG5cdH0gPSB0eXBlO1xuXG5cdGNvbnN0IHtcblx0XHRNb2RpZmljYXRpb25Db25zdHJ1Y3Rvcixcblx0XHRibG9ja0Vycm9ycyxcblx0XHRzdWJtaXRTdGFja1xuXHR9ID0gY29uZmlnO1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG5cdGNvbnN0IG1jID0gTW9kaWZpY2F0aW9uQ29uc3RydWN0b3IoIG9iZXkgKTtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcblx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0Y29uc3QgTW9kaWZpY2F0b3JUeXBlID0gY29uc3RydWN0SGFuZGxlcigpO1xuXG5cdE9iamVjdC5hc3NpZ24oIHNlbGYsIHtcblxuXHRcdHR5cGUsXG5cdFx0VHlwZU5hbWUsXG5cblx0XHRleGlzdGVudEluc3RhbmNlLFxuXG5cdFx0Z2V0IGFyZ3MgKCkge1xuXHRcdFx0cmV0dXJuIGFyZ3M7XG5cdFx0fSxcblxuXHRcdE1vZGlmaWNhdGlvbkNvbnN0cnVjdG9yIDogbWMsXG5cdFx0TW9kaWZpY2F0b3JUeXBlLFxuXG5cdFx0Y29uZmlnLFxuXG5cdFx0cHJvdG9cblxuXHR9ICk7XG5cblx0aWYgKCBzdWJtaXRTdGFjayB8fCBjaGFpbmVkICkge1xuXHRcdGNvbnN0IHN0YWNrQWRkaXRpb246IHN0cmluZ1tdID0gY2hhaW5lZCA/IHNlbGYuZ2V0RXhpc3RlbnRBc3luY1N0YWNrKCBleGlzdGVudEluc3RhbmNlICkgOiBbXTtcblx0XHRjb25zdCB0aXRsZSA9IGBcXG48LS0gY3JlYXRpb24gb2YgWyAke1R5cGVOYW1lfSBdIHRyYWNlZCAtLT5gO1xuXHRcdGlmICggc3VibWl0U3RhY2sgKSB7XG5cdFx0XHRnZXRTdGFjay5jYWxsKCBzZWxmLCB0aXRsZSwgc3RhY2tBZGRpdGlvbiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZWxmLnN0YWNrID0gdGl0bGU7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBibG9ja0Vycm9ycyAmJiBleGlzdGVudEluc3RhbmNlIGluc3RhbmNlb2YgRXJyb3IgKSB7XG5cblx0XHRzZWxmLk1vZGlmaWNhdG9yVHlwZSA9IG1ha2VGYWtlTW9kaWZpY2F0b3JUeXBlKCBUeXBlTmFtZSApO1xuXG5cdFx0c2VsZi5JbnN0YW5jZU1vZGlmaWNhdG9yID0gbWFrZUluc3RhbmNlTW9kaWZpY2F0b3IoIHNlbGYgKTtcblxuXHRcdHRocm93IG5ldyBzZWxmLkluc3RhbmNlTW9kaWZpY2F0b3IoIC4uLmFyZ3MgKTtcblxuXHR9XG5cblx0c2VsZi5pbnZva2VQcmVIb29rcygpO1xuXG5cdHNlbGYuSW5zdGFuY2VNb2RpZmljYXRvciA9IG1ha2VJbnN0YW5jZU1vZGlmaWNhdG9yKCBzZWxmICk7XG5cblx0aWYgKCBibG9ja0Vycm9ycyApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBDb25zdHJ1Y3RvciBJbnZvY2F0aW9uIEl0c2VsZlxuXHRcdFx0Y29uc3QgYW5zd2VyID0gbmV3IHNlbGYuSW5zdGFuY2VNb2RpZmljYXRvciggLi4uYXJncyApO1xuXHRcdFx0Ly8gZGVidWdnZXI7XG5cdFx0XHRzZWxmLmluaGVyaXRlZEluc3RhbmNlID0gYW5zd2VyO1xuXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRzZWxmLnRocm93TW9kaWZpY2F0aW9uRXJyb3IoIGVycm9yICk7XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIENvbnN0cnVjdG9yIEludm9jYXRpb24gSXRzZWxmXG5cdFx0Y29uc3QgYW5zd2VyID0gbmV3IHNlbGYuSW5zdGFuY2VNb2RpZmljYXRvciggLi4uYXJncyApO1xuXHRcdC8vIGRlYnVnZ2VyO1xuXHRcdHNlbGYuaW5oZXJpdGVkSW5zdGFuY2UgPSBhbnN3ZXI7XG5cblx0fVxuXG5cblx0aWYgKCBzZWxmLmluaGVyaXRlZEluc3RhbmNlIGluc3RhbmNlb2YgUHJvbWlzZSApIHtcblxuXHRcdGNvbnN0IHdhaXRlciA9IHNlbGYubWFrZUF3YWl0ZXIoIHR5cGUgKTtcblxuXHRcdG9kcCggd2FpdGVyLCBTeW1ib2xDb25zdHJ1Y3Rvck5hbWUsIHtcblx0XHRcdGdldCAoKSB7XG5cdFx0XHRcdHJldHVybiBUeXBlTmFtZTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gd2FpdGVyO1xuXG5cdH1cblxuXHRzZWxmLnBvc3RQcm9jZXNzaW5nKCB0eXBlICk7XG5cblx0cmV0dXJuIHNlbGYuaW5oZXJpdGVkSW5zdGFuY2U7XG5cbn0gYXMgQ29uc3RydWN0b3JGdW5jdGlvbjx0eXBlb2YgSW5zdGFuY2VDcmVhdG9yUHJvdG90eXBlPjtcblxuT2JqZWN0LmFzc2lnbiggSW5zdGFuY2VDcmVhdG9yLnByb3RvdHlwZSwgSW5zdGFuY2VDcmVhdG9yUHJvdG90eXBlICk7XG4iXX0=