'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../../constants");
const { odp, SymbolConstructorName, MNEMONICA, } = constants_1.constants;
const utils_1 = require("../utils");
const { getTypeChecker, findSubTypeFromParent, reflectPrimitiveWrappers } = utils_1.default;
const extract_1 = require("../../utils/extract");
const parent_1 = require("../../utils/parent");
const pick_1 = require("../../utils/pick");
const exceptionConstructor_1 = require("../errors/exceptionConstructor");
const InstanceCreator_1 = require("./InstanceCreator");
const Props_1 = require("./Props");
const getDefaultPrototype = () => {
    return Object.create(null);
};
const MnemonicaProtoProps = {
    extract() {
        return function () {
            return (0, extract_1.extract)(this);
        };
    },
    pick() {
        return function (...args) {
            return (0, pick_1.pick)(this, ...args);
        };
    },
    parent() {
        return function (constructorLookupPath) {
            return (0, parent_1.parent)(this, constructorLookupPath);
        };
    },
    clone() {
        return this.fork();
    },
    fork() {
        const props = (0, Props_1._getProps)(this);
        const { __type__: type, __collection__: collection, __parent__: existentInstance, __args__, __self__, } = props;
        const { isSubType, TypeName } = type;
        return function (...forkArgs) {
            let forked;
            const Constructor = isSubType ?
                existentInstance :
                collection;
            const args = forkArgs.length ? forkArgs : __args__;
            if (this === __self__) {
                forked = new (Constructor[TypeName])(...args);
            }
            else {
                forked = new InstanceCreator_1.InstanceCreator(type, reflectPrimitiveWrappers(this), args);
            }
            return forked;
        };
    },
    [SymbolConstructorName]() {
        return MNEMONICA;
    },
    exception() {
        const self = this;
        return function (error, ...args) {
            const target = new.target;
            return exceptionConstructor_1.default.call(self, target, error, ...args);
        };
    },
    sibling() {
        const siblings = (SiblingTypeName) => {
            const props = (0, Props_1._getProps)(this);
            const { __collection__: collection, } = props;
            const sibling = collection[SiblingTypeName];
            return sibling;
        };
        return new Proxy(siblings, {
            get(_, prop) {
                return siblings(prop);
            },
            apply(_, __, args) {
                return siblings(args[0]);
            }
        });
    }
};
const staticProps = [
    'constructor',
    'prototype',
    'then',
    'stack',
    'message',
    'domain',
    'on',
    'once',
    'off',
    'inspect',
    'showDiff',
]
    .concat(Object.keys(MnemonicaProtoProps))
    .concat(Object.getOwnPropertyNames(Object.prototype))
    .concat(Object.getOwnPropertyNames(Function.prototype))
    .reduce((obj, key) => {
    obj[key] = true;
    return obj;
}, Object.create(null));
const makeSubTypeProxy = function (subtype, inheritedInstance) {
    const subtypeProxy = new Proxy(InstanceCreator_1.InstanceCreator, {
        get(Target, _prop) {
            if (_prop === Symbol.hasInstance) {
                return getTypeChecker(subtype.TypeName);
            }
            return Reflect.get(Target, _prop);
        },
        construct(Target, _args) {
            return new Target(subtype, inheritedInstance, _args);
        },
        apply(Target, thisArg, _args) {
            if (thisArg === undefined) {
                thisArg = inheritedInstance;
            }
            const existentInstance = reflectPrimitiveWrappers(thisArg);
            const entity = new Target(subtype, existentInstance, _args);
            return entity;
        },
    });
    return subtypeProxy;
};
const prepareSubtypeForConstruction = function (subtypeName, inheritedInstance) {
    const propInstance = Reflect.getPrototypeOf(inheritedInstance);
    const props = (0, Props_1._getProps)(propInstance);
    if (!props) {
        return undefined;
    }
    const { __type__: { config: { strictChain }, subtypes }, } = props;
    const subtype = subtypes.has(subtypeName) ?
        subtypes.get(subtypeName) :
        strictChain ?
            undefined :
            findSubTypeFromParent(inheritedInstance, subtypeName);
    return subtype ? makeSubTypeProxy(subtype, inheritedInstance) : undefined;
};
const mnemosyneProxyHandlerGet = (target, prop, receiver) => {
    const result = Reflect.get(target, prop, receiver);
    if (result !== undefined) {
        return result;
    }
    if (typeof prop === 'symbol') {
        return result;
    }
    if (staticProps[prop]) {
        return result;
    }
    const subtype = prepareSubtypeForConstruction(prop, receiver);
    return subtype || result;
};
const Mnemosyne = function (mnemonica) {
    const instance = this;
    const Mnemonica = function () {
        odp(this, SymbolConstructorName, {
            get() {
                return MNEMONICA;
            }
        });
    };
    Object.setPrototypeOf(Mnemonica.prototype, mnemonica);
    Object.entries(MnemonicaProtoProps).forEach(([name, method]) => {
        odp(Mnemonica.prototype, name, {
            get() {
                return method.call(this);
            }
        });
    });
    Object.getOwnPropertySymbols(MnemonicaProtoProps).forEach((symbol) => {
        odp(Mnemonica.prototype, symbol, {
            get() {
                const symbolMethod = Reflect.get(MnemonicaProtoProps, symbol);
                return symbolMethod.call(this);
            }
        });
    });
    odp(Mnemonica.prototype, Symbol.hasInstance, {
        get() {
            return getTypeChecker(this.constructor.name);
        }
    });
    const proto = new Mnemonica();
    Reflect.setPrototypeOf(instance, proto);
};
const createMnemosyne = function (Uranus) {
    const uranus = reflectPrimitiveWrappers(Uranus);
    const mnemosyne = new Mnemosyne(uranus);
    const mnemosyneProxy = new Proxy(mnemosyne, {
        get: mnemosyneProxyHandlerGet
    });
    return mnemosyneProxy;
};
exports.default = {
    get createMnemosyne() {
        return createMnemosyne;
    },
    get prepareSubtypeForConstruction() {
        return prepareSubtypeForConstruction;
    },
    get getDefaultPrototype() {
        return getDefaultPrototype;
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW5lbW9zeW5lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2FwaS90eXBlcy9NbmVtb3N5bmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxDQUFDOztBQUdiLCtDQUE0QztBQUM1QyxNQUFNLEVBQ0wsR0FBRyxFQUNILHFCQUFxQixFQUVyQixTQUFTLEdBRVQsR0FBRyxxQkFBUyxDQUFDO0FBRWQsb0NBQWtDO0FBQ2xDLE1BQU0sRUFDTCxjQUFjLEVBQ2QscUJBQXFCLEVBQ3JCLHdCQUF3QixFQUN4QixHQUFHLGVBQVUsQ0FBQztBQUVmLGlEQUE4QztBQUM5QywrQ0FBNEM7QUFDNUMsMkNBQXdDO0FBRXhDLHlFQUFrRTtBQUVsRSx1REFBb0Q7QUFFcEQsbUNBQTJDO0FBRTNDLE1BQU0sbUJBQW1CLEdBQUcsR0FBRyxFQUFFO0lBQ2hDLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM1QixDQUFDLENBQUM7QUFJRixNQUFNLG1CQUFtQixHQUFHO0lBRTNCLE9BQU87UUFDTixPQUFPO1lBQ04sT0FBTyxJQUFBLGlCQUFPLEVBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEIsQ0FBQyxDQUFDO0lBQ0gsQ0FBQztJQUVELElBQUk7UUFDSCxPQUFPLFVBQXFCLEdBQUcsSUFBVztZQUN6QyxPQUFPLElBQUEsV0FBSSxFQUFDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDO1FBQzVCLENBQUMsQ0FBQztJQUNILENBQUM7SUFFRCxNQUFNO1FBQ0wsT0FBTyxVQUFxQixxQkFBNkI7WUFDeEQsT0FBTyxJQUFBLGVBQU0sRUFBQyxJQUFJLEVBQUUscUJBQXFCLENBQUMsQ0FBQztRQUM1QyxDQUFDLENBQUM7SUFDSCxDQUFDO0lBRUQsS0FBSztRQUNKLE9BQU8sSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxJQUFJO1FBRUgsTUFBTSxLQUFLLEdBQUcsSUFBQSxp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QyxTQUFTLEVBQUUsTUFBTSxDQUFDLFdBQVcsRUFBRTtRQUM1QyxHQUFHO1lBQ0YsT0FBTyxjQUFjLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM5QyxDQUFDO0tBQ0QsQ0FBQyxDQUFDO0lBRUgsTUFBTSxLQUFLLEdBQUcsSUFBSSxTQUFTLEVBQUUsQ0FBQztJQUM5QixPQUFPLENBQUMsY0FBYyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUl6QyxDQUFvRCxDQUFDO0FBRXJELE1BQU0sZUFBZSxHQUFHLFVBQVUsTUFBZTtJQVVoRCxNQUFNLE1BQU0sR0FBRyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNoRCxNQUFNLFNBQVMsR0FBRyxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN4QyxNQUFNLGNBQWMsR0FBRyxJQUFJLEtBQUssQ0FBQyxTQUFTLEVBQUU7UUFDM0MsR0FBRyxFQUFHLHdCQUF3QjtLQUM5QixDQUFDLENBQUM7SUFFSCxPQUFPLGNBQWMsQ0FBQztBQUN2QixDQUFDLENBQUM7QUFFRixrQkFBZTtJQUNkLElBQUksZUFBZTtRQUNsQixPQUFPLGVBQWUsQ0FBQztJQUN4QixDQUFDO0lBQ0QsSUFBSSw2QkFBNkI7UUFDaEMsT0FBTyw2QkFBNkIsQ0FBQztJQUN0QyxDQUFDO0lBQ0QsSUFBSSxtQkFBbUI7UUFDdEIsT0FBTyxtQkFBbUIsQ0FBQztJQUM1QixDQUFDO0NBT0QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgQ29uc3RydWN0b3JGdW5jdGlvbiB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IGNvbnN0YW50cyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5jb25zdCB7XG5cdG9kcCxcblx0U3ltYm9sQ29uc3RydWN0b3JOYW1lLFxuXG5cdE1ORU1PTklDQSxcblxufSA9IGNvbnN0YW50cztcblxuaW1wb3J0IFR5cGVzVXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuY29uc3Qge1xuXHRnZXRUeXBlQ2hlY2tlcixcblx0ZmluZFN1YlR5cGVGcm9tUGFyZW50LFxuXHRyZWZsZWN0UHJpbWl0aXZlV3JhcHBlcnNcbn0gPSBUeXBlc1V0aWxzO1xuXG5pbXBvcnQgeyBleHRyYWN0IH0gZnJvbSAnLi4vLi4vdXRpbHMvZXh0cmFjdCc7XG5pbXBvcnQgeyBwYXJlbnQgfSBmcm9tICcuLi8uLi91dGlscy9wYXJlbnQnO1xuaW1wb3J0IHsgcGljayB9IGZyb20gJy4uLy4uL3V0aWxzL3BpY2snO1xuXG5pbXBvcnQgZXhjZXB0aW9uQ29uc3RydWN0b3IgZnJvbSAnLi4vZXJyb3JzL2V4Y2VwdGlvbkNvbnN0cnVjdG9yJztcblxuaW1wb3J0IHsgSW5zdGFuY2VDcmVhdG9yIH0gZnJvbSAnLi9JbnN0YW5jZUNyZWF0b3InO1xuXG5pbXBvcnQgeyBfZ2V0UHJvcHMsIFByb3BzIH0gZnJvbSAnLi9Qcm9wcyc7XG5cbmNvbnN0IGdldERlZmF1bHRQcm90b3R5cGUgPSAoKSA9PiB7XG5cdHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufTtcblxuLy8gY29uc3QgSW5zdGFuY2VSb290cyA9IG5ldyBXZWFrTWFwO1xuXG5jb25zdCBNbmVtb25pY2FQcm90b1Byb3BzID0ge1xuXG5cdGV4dHJhY3QgKCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAodGhpczogYW55KSB7XG5cdFx0XHRyZXR1cm4gZXh0cmFjdCh0aGlzKTtcblx0XHR9O1xuXHR9LFxuXG5cdHBpY2sgKCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAodGhpczogYW55LCAuLi5hcmdzOiBhbnlbXSkge1xuXHRcdFx0cmV0dXJuIHBpY2sodGhpcywgLi4uYXJncyk7XG5cdFx0fTtcblx0fSxcblxuXHRwYXJlbnQgKCkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAodGhpczogYW55LCBjb25zdHJ1Y3Rvckxvb2t1cFBhdGg6IHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHBhcmVudCh0aGlzLCBjb25zdHJ1Y3Rvckxvb2t1cFBhdGgpO1xuXHRcdH07XG5cdH0sXG5cblx0Y2xvbmUgKHRoaXM6IGFueSkge1xuXHRcdHJldHVybiB0aGlzLmZvcmsoKTtcblx0fSxcblxuXHRmb3JrICh0aGlzOiBhbnkpIHtcblxuXHRcdGNvbnN0IHByb3BzID0gX2dldFByb3BzKHRoaXMpIGFzIFByb3BzO1xuXG5cdFx0Y29uc3Qge1xuXHRcdFx0X190eXBlX186IHR5cGUsXG5cdFx0XHRfX2NvbGxlY3Rpb25fXzogY29sbGVjdGlvbixcblx0XHRcdF9fcGFyZW50X186IGV4aXN0ZW50SW5zdGFuY2UsXG5cdFx0XHRfX2FyZ3NfXyxcblx0XHRcdF9fc2VsZl9fLFxuXHRcdH0gPSBwcm9wcztcblxuXHRcdGNvbnN0IHtcblx0XHRcdGlzU3ViVHlwZSxcblx0XHRcdFR5cGVOYW1lXG5cdFx0fSA9IHR5cGU7XG5cblx0XHQvLyAnZnVuY3Rpb24nLCBjYXVzZSBtaWdodCBiZSBjYWxsZWQgd2l0aCAnbmV3J1xuXHRcdCBcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHRoaXM6IGFueSwgLi4uZm9ya0FyZ3M6IGFueVtdKSB7XG5cblx0XHRcdGxldCBmb3JrZWQ7XG5cdFx0XHRjb25zdCBDb25zdHJ1Y3RvciA9IGlzU3ViVHlwZSA/XG5cdFx0XHRcdGV4aXN0ZW50SW5zdGFuY2UgOlxuXHRcdFx0XHRjb2xsZWN0aW9uO1xuXG5cdFx0XHRjb25zdCBhcmdzID0gZm9ya0FyZ3MubGVuZ3RoID8gZm9ya0FyZ3MgOiBfX2FyZ3NfXztcblxuXG5cdFx0XHRpZiAodGhpcyA9PT0gX19zZWxmX18pIHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuXHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFxuXHRcdFx0XHRmb3JrZWQgPSBuZXcgKENvbnN0cnVjdG9yWyBUeXBlTmFtZSBdKSguLi5hcmdzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGZvcmsuY2FsbCA/IGxldCdzIGRvIGl0ICFcblx0XHRcdFx0Zm9ya2VkID0gbmV3IEluc3RhbmNlQ3JlYXRvcih0eXBlLCByZWZsZWN0UHJpbWl0aXZlV3JhcHBlcnModGhpcyksIGFyZ3MpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm9ya2VkO1xuXG5cdFx0fTtcblx0fSxcblxuXHRbIFN5bWJvbENvbnN0cnVjdG9yTmFtZSBdICgpIHtcblx0XHRyZXR1cm4gTU5FTU9OSUNBO1xuXHR9LFxuXG5cdGV4Y2VwdGlvbiAoKSB7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChlcnJvcjogRXJyb3IsIC4uLmFyZ3M6IGFueVtdKSB7XG5cdFx0XHRjb25zdCB0YXJnZXQgPSBuZXcudGFyZ2V0O1xuXHRcdFx0cmV0dXJuIGV4Y2VwdGlvbkNvbnN0cnVjdG9yLmNhbGwoc2VsZiwgdGFyZ2V0LCBlcnJvciwgLi4uYXJncyk7XG5cdFx0fTtcblx0fSxcblxuXHRzaWJsaW5nICgpIHtcblx0XHQgXG5cdFx0Y29uc3Qgc2libGluZ3MgPSAoU2libGluZ1R5cGVOYW1lOiBzdHJpbmcpID0+IHtcblxuXHRcdFx0Y29uc3QgcHJvcHMgPSBfZ2V0UHJvcHModGhpcykgYXMgUHJvcHM7XG5cdFx0XHRjb25zdCB7XG5cdFx0XHRcdF9fY29sbGVjdGlvbl9fOiBjb2xsZWN0aW9uLFxuXHRcdFx0fSA9IHByb3BzO1xuXHRcdFx0Y29uc3Qgc2libGluZzogYW55ID0gY29sbGVjdGlvblsgU2libGluZ1R5cGVOYW1lIF07XG5cdFx0XHRyZXR1cm4gc2libGluZztcblx0XHR9O1xuXG5cdFx0cmV0dXJuIG5ldyBQcm94eShzaWJsaW5ncywge1xuXHRcdFx0Z2V0IChfLCBwcm9wOiBzdHJpbmcpIHtcblx0XHRcdFx0cmV0dXJuIHNpYmxpbmdzKHByb3ApO1xuXHRcdFx0fSxcblx0XHRcdGFwcGx5IChfLCBfXywgYXJncywpIHtcblx0XHRcdFx0cmV0dXJuIHNpYmxpbmdzKGFyZ3NbIDAgXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxufTtcblxuY29uc3Qgc3RhdGljUHJvcHMgPSBbXG5cblx0Ly8gYnVpbHRpbnM6IGZ1bmN0aW9ucyArIFByb21pc2VzXG5cdCdjb25zdHJ1Y3RvcicsXG5cdCdwcm90b3R5cGUnLFxuXHQndGhlbicsXG5cblx0Ly8gYnVpbHRpbnM6IGVycm9yc1xuXHQnc3RhY2snLFxuXHQnbWVzc2FnZScsXG5cdCdkb21haW4nLFxuXG5cdC8vIGJ1aWx0aW5zOiBFdmVudEVtaXR0ZXJcblx0J29uJyxcblx0J29uY2UnLFxuXHQnb2ZmJyxcblxuXHQvLyBtb2NoYSArIGNoYWkgPT4gYnVnOiAuL3V0aWxzLmpzIC5maW5kU3ViVHlwZUZyb21QYXJlbnQgJ2luc3BlY3QnXG5cdCdpbnNwZWN0Jyxcblx0J3Nob3dEaWZmJyxcblxuXVxuXHQuY29uY2F0KE9iamVjdC5rZXlzKE1uZW1vbmljYVByb3RvUHJvcHMpKVxuXHQuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5wcm90b3R5cGUpKVxuXHQuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKEZ1bmN0aW9uLnByb3RvdHlwZSkpXG5cdC5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG5cdFx0b2JqWyBrZXkgXSA9IHRydWU7XG5cdFx0cmV0dXJuIG9iajtcblx0fSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogb25seS1hcnJvdy1mdW5jdGlvbnNcbmNvbnN0IG1ha2VTdWJUeXBlUHJveHkgPSBmdW5jdGlvbiAoc3VidHlwZTogYW55LCBpbmhlcml0ZWRJbnN0YW5jZTogYW55KSB7XG5cblx0Y29uc3Qgc3VidHlwZVByb3h5ID0gbmV3IFByb3h5KEluc3RhbmNlQ3JlYXRvciwge1xuXG5cdFx0Z2V0IChUYXJnZXQsIF9wcm9wKSB7XG5cblx0XHRcdGlmIChfcHJvcCA9PT0gU3ltYm9sLmhhc0luc3RhbmNlKSB7XG5cdFx0XHRcdHJldHVybiBnZXRUeXBlQ2hlY2tlcihzdWJ0eXBlLlR5cGVOYW1lKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFJlZmxlY3QuZ2V0KFRhcmdldCwgX3Byb3ApO1xuXG5cdFx0fSxcblxuXHRcdGNvbnN0cnVjdCAoVGFyZ2V0LCBfYXJncykge1xuXHRcdFx0cmV0dXJuIG5ldyBUYXJnZXQoc3VidHlwZSwgaW5oZXJpdGVkSW5zdGFuY2UsIF9hcmdzKTtcblx0XHR9LFxuXG5cdFx0YXBwbHkgKFRhcmdldCwgdGhpc0FyZywgX2FyZ3MpIHtcblxuXHRcdFx0aWYgKHRoaXNBcmcgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzQXJnID0gaW5oZXJpdGVkSW5zdGFuY2U7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGV4aXN0ZW50SW5zdGFuY2UgPSByZWZsZWN0UHJpbWl0aXZlV3JhcHBlcnModGhpc0FyZyk7XG5cblx0XHRcdGNvbnN0IGVudGl0eSA9IG5ldyBUYXJnZXQoc3VidHlwZSwgZXhpc3RlbnRJbnN0YW5jZSwgX2FyZ3MpO1xuXHRcdFx0cmV0dXJuIGVudGl0eTtcblx0XHR9LFxuXG5cdH0pO1xuXG5cdHJldHVybiBzdWJ0eXBlUHJveHk7XG59O1xuXG5jb25zdCBwcmVwYXJlU3VidHlwZUZvckNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIChzdWJ0eXBlTmFtZTogc3RyaW5nLCBpbmhlcml0ZWRJbnN0YW5jZTogYW55KSB7XG5cdC8vIHByb3RvdHlwZSBvZiBwcm94eVxuXHRjb25zdCBwcm9wSW5zdGFuY2U6IGFueSA9IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YoaW5oZXJpdGVkSW5zdGFuY2UpO1xuXG5cdGNvbnN0IHByb3BzID0gX2dldFByb3BzKHByb3BJbnN0YW5jZSkgYXMgUHJvcHM7XG5cdGlmICghcHJvcHMpIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Y29uc3Qge1xuXHRcdF9fdHlwZV9fOiB7XG5cdFx0XHRjb25maWc6IHtcblx0XHRcdFx0c3RyaWN0Q2hhaW5cblx0XHRcdH0sXG5cdFx0XHRzdWJ0eXBlc1xuXHRcdH0sXG5cdH0gPSBwcm9wcztcblxuXG5cdGNvbnN0IHN1YnR5cGUgPSBzdWJ0eXBlcy5oYXMoc3VidHlwZU5hbWUpID9cblx0XHRzdWJ0eXBlcy5nZXQoc3VidHlwZU5hbWUpIDpcblx0XHRzdHJpY3RDaGFpbiA/XG5cdFx0XHR1bmRlZmluZWQgOlxuXHRcdFx0ZmluZFN1YlR5cGVGcm9tUGFyZW50KGluaGVyaXRlZEluc3RhbmNlLCBzdWJ0eXBlTmFtZSk7XG5cblx0cmV0dXJuIHN1YnR5cGUgPyBtYWtlU3ViVHlwZVByb3h5KHN1YnR5cGUsIGluaGVyaXRlZEluc3RhbmNlKSA6IHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IG1uZW1vc3luZVByb3h5SGFuZGxlckdldCA9ICh0YXJnZXQ6IGFueSwgcHJvcDogc3RyaW5nLCByZWNlaXZlcjogYW55KSA9PiB7XG5cblx0Ly8gTm9kZS5qcyAyMiBSZWZsZWN0LmdldCBCZWhhdmlvdXIgQ2hhbmdlZCBoZXJlXG5cdC8vIGNhdXNlIHNvbWV0aGluZyBnb25lIHdyb25nIHdpdGggcHJvcCBhc3NpZ25tZW50XG5cdC8vIHNvIG5vdyBpZiB3ZSBuZWVkIC5zdGFjaywgd2Ugc2hvdWxkIGF2b2lkIHJlY2VpdmVyIGhlcmVcblx0Ly8gbmF2ZSBub3QgeWV0IGNoZWNrZWQgb3RoZXIgc3RhdGljUHJvcHMsXG5cdC8vIGp1c3QgZml4ZWQgdGhpcyBiZWxvd1xuXHQvLyB3aGlsZSB1c2luZyBjb25kaXRpb25hbCBmb3Igc3RhdGljUHJvcHNcblx0Y29uc3QgcmVzdWx0ID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG5cblx0aWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N5bWJvbCcpIHtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0aWYgKHN0YXRpY1Byb3BzWyBwcm9wIF0pIHtcblx0XHQvKlxuXHRcdGNvbnN0IG1heUJlUmVzdWx0ID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wKTtcblx0XHRpZiAobWF5QmVSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIG1heUJlUmVzdWx0O1xuXHRcdH1cblx0XHQqL1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRjb25zdCBzdWJ0eXBlID0gcHJlcGFyZVN1YnR5cGVGb3JDb25zdHJ1Y3Rpb24ocHJvcCwgcmVjZWl2ZXIpO1xuXHRyZXR1cm4gc3VidHlwZSB8fCByZXN1bHQ7XG59O1xuXG5jb25zdCBNbmVtb3N5bmUgPSBmdW5jdGlvbiAobW5lbW9uaWNhOiBvYmplY3QpIHtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcblx0Y29uc3QgaW5zdGFuY2UgPSB0aGlzO1xuXG5cdGNvbnN0IE1uZW1vbmljYSA9IGZ1bmN0aW9uICh0aGlzOiBhbnkpIHtcblx0XHRvZHAodGhpcywgU3ltYm9sQ29uc3RydWN0b3JOYW1lLCB7XG5cdFx0XHRnZXQgKCkge1xuXHRcdFx0XHRyZXR1cm4gTU5FTU9OSUNBO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9IGFzIENvbnN0cnVjdG9yRnVuY3Rpb248dHlwZW9mIE1uZW1vbmljYVByb3RvUHJvcHM+O1xuXHRcblx0Ly8gdGhpcyB0aHJvd3MgYW4gZXJyb3Jcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKE1uZW1vbmljYS5wcm90b3R5cGUsIG1uZW1vbmljYSk7XG5cdC8vIHdoaWxlIHRoaXMganVzdCByZXR1cm5zIGZhbHNlLCBzaWxlbnRseSAuLi4gdW5mb3J0dW5hdGVseVxuXHQvLyBSZWZsZWN0LnNldFByb3RvdHlwZU9mKE1uZW1vbmljYS5wcm90b3R5cGUsIG1uZW1vbmljYSk7XG5cblx0T2JqZWN0LmVudHJpZXMoTW5lbW9uaWNhUHJvdG9Qcm9wcykuZm9yRWFjaCgoWyBuYW1lLCBtZXRob2QgXTogW3N0cmluZywgYW55XSkgPT4ge1xuXHRcdG9kcChNbmVtb25pY2EucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRnZXQgKHRoaXM6IGFueSkge1xuXHRcdFx0XHRyZXR1cm4gbWV0aG9kLmNhbGwodGhpcyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXG5cdE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTW5lbW9uaWNhUHJvdG9Qcm9wcykuZm9yRWFjaCgoc3ltYm9sOiBzeW1ib2wpID0+IHtcblx0XHRvZHAoTW5lbW9uaWNhLnByb3RvdHlwZSwgc3ltYm9sLCB7XG5cdFx0XHRnZXQgKCkge1xuXHRcdFx0XHRjb25zdCBzeW1ib2xNZXRob2QgPSBSZWZsZWN0LmdldChNbmVtb25pY2FQcm90b1Byb3BzLCBzeW1ib2wpO1xuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0cmV0dXJuIHN5bWJvbE1ldGhvZC5jYWxsKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblxuXHQvLyBpbnN0YW5jZSBvZiBzZWxmIENvbnN0cnVjdG9yIHR5cGVcblx0b2RwKE1uZW1vbmljYS5wcm90b3R5cGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuXHRcdGdldCAoKSB7XG5cdFx0XHRyZXR1cm4gZ2V0VHlwZUNoZWNrZXIodGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcblx0XHR9XG5cdH0pO1xuXG5cdGNvbnN0IHByb3RvID0gbmV3IE1uZW1vbmljYSgpO1xuXHRSZWZsZWN0LnNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBwcm90byk7XG5cblx0Ly8gSW5zdGFuY2VSb290cy5zZXQoaW5zdGFuY2UsIHByb3RvKTtcblxufSBhcyBDb25zdHJ1Y3RvckZ1bmN0aW9uPHR5cGVvZiBNbmVtb25pY2FQcm90b1Byb3BzPjtcblxuY29uc3QgY3JlYXRlTW5lbW9zeW5lID0gZnVuY3Rpb24gKFVyYW51czogdW5rbm93bikge1xuLy8gY29uc3QgY3JlYXRlTW5lbW9zeW5lID0gZnVuY3Rpb24gKFVyYW51czogdW5rbm93biwgdHlwZVByb3h5OiBhbnkpIHtcbi8vIFx0aWYgKHR5cGVvZiBVcmFudXMgPT09ICd1bmRlZmluZWQnKSB7XG4vLyBcdFx0Y29uc3QgeyBfX3R5cGVfXzogdHlwZSwgVXJhbnVzOiBfdXJhbnVzIH0gPSB0eXBlUHJveHk7XG4vLyBcdFx0Y29uc29sZS5sb2codHlwZSwgX3VyYW51cyk7XG4vLyBcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWRlYnVnZ2VyXG4vLyBcdFx0ZGVidWdnZXI7XG4vLyBcdFx0dGhyb3cgbmV3IEVycm9yKCdjcmVhdGVNbmVtb3N5bmUgVXJhbnVzIGlzIG5vdCBkZWZpbmVkIGZvciB0eXBlUHJveHkuJyk7XG4vLyBcdH1cblxuXHRjb25zdCB1cmFudXMgPSByZWZsZWN0UHJpbWl0aXZlV3JhcHBlcnMoVXJhbnVzKTtcblx0Y29uc3QgbW5lbW9zeW5lID0gbmV3IE1uZW1vc3luZSh1cmFudXMpO1xuXHRjb25zdCBtbmVtb3N5bmVQcm94eSA9IG5ldyBQcm94eShtbmVtb3N5bmUsIHtcblx0XHRnZXQgOiBtbmVtb3N5bmVQcm94eUhhbmRsZXJHZXRcblx0fSk7XG5cblx0cmV0dXJuIG1uZW1vc3luZVByb3h5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuXHRnZXQgY3JlYXRlTW5lbW9zeW5lICgpIHtcblx0XHRyZXR1cm4gY3JlYXRlTW5lbW9zeW5lO1xuXHR9LFxuXHRnZXQgcHJlcGFyZVN1YnR5cGVGb3JDb25zdHJ1Y3Rpb24gKCkge1xuXHRcdHJldHVybiBwcmVwYXJlU3VidHlwZUZvckNvbnN0cnVjdGlvbjtcblx0fSxcblx0Z2V0IGdldERlZmF1bHRQcm90b3R5cGUgKCkge1xuXHRcdHJldHVybiBnZXREZWZhdWx0UHJvdG90eXBlO1xuXHR9LFxuXHQvLyBnZXQgTW5lbW9zeW5lUHJvdG90eXBlS2V5cyAoKSB7XG5cdC8vIFx0cmV0dXJuIE1uZW1vc3luZVByb3RvdHlwZUtleXM7XG5cdC8vIH0sXG5cdC8vIGdldCBJbnN0YW5jZVJvb3RzICgpIHtcblx0Ly8gXHRyZXR1cm4gSW5zdGFuY2VSb290cztcblx0Ly8gfVxufTtcbiJdfQ==