'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
const errors_1 = require("../descriptors/errors");
const { WRONG_MODIFICATION_PATTERN, WRONG_ARGUMENTS_USED } = errors_1.ErrorsTypes;
const constants_1 = require("../constants");
const { MNEMONICA, SymbolConstructorName } = constants_1.constants;
const extract_1 = require("./extract");
const parse = (self) => {
    if (!self || !self.constructor) {
        throw new WRONG_MODIFICATION_PATTERN;
    }
    const proto = Reflect.getPrototypeOf(self);
    if (self.constructor.name.toString() !== proto.constructor.name.toString()) {
        throw new WRONG_ARGUMENTS_USED(`have to use "instance" itself: '${self.constructor.name}' vs '${proto.constructor.name}'`);
    }
    const protoProto = Reflect.getPrototypeOf(proto);
    if (protoProto && proto.constructor.name.toString() !== protoProto.constructor.name.toString()) {
        throw new WRONG_ARGUMENTS_USED(`have to use "instance" itself: '${proto.constructor.name}' vs '${protoProto.constructor.name}'`);
    }
    const { name } = proto.constructor;
    const props = (0, extract_1.extract)(Object.assign({}, self));
    delete props.constructor;
    const joint = (0, extract_1.extract)(Object.assign({}, proto));
    delete joint.constructor;
    let parent;
    if (protoProto[SymbolConstructorName] === MNEMONICA) {
        parent = protoProto;
    }
    else {
        parent = (0, exports.parse)(Reflect.getPrototypeOf(protoProto));
    }
    return {
        name,
        props,
        self,
        proto,
        joint,
        parent,
    };
};
exports.parse = parse;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMvcGFyc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxDQUFDOzs7QUFFYixrREFBb0Q7QUFDcEQsTUFBTSxFQUNMLDBCQUEwQixFQUMxQixvQkFBb0IsRUFDcEIsR0FBRyxvQkFBVyxDQUFDO0FBRWhCLDRDQUF5QztBQUN6QyxNQUFNLEVBQ0wsU0FBUyxFQUNULHFCQUFxQixFQUNyQixHQUFHLHFCQUFTLENBQUM7QUFHZCx1Q0FBb0M7QUFFN0IsTUFBTSxLQUFLLEdBQUcsQ0FBRSxJQUFTLEVBQVEsRUFBRTtJQUV6QyxJQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRyxDQUFDO1FBQ2xDLE1BQU0sSUFBSSwwQkFBMEIsQ0FBQztJQUN0QyxDQUFDO0lBRUQsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBRSxJQUFJLENBQVksQ0FBQztJQUV2RCxJQUFLLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxLQUFLLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFHLENBQUM7UUFDOUUsTUFBTSxJQUFJLG9CQUFvQixDQUFFLG1DQUFtQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksU0FBUyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRyxDQUFFLENBQUM7SUFDOUgsQ0FBQztJQUVELE1BQU0sVUFBVSxHQUFRLE9BQU8sQ0FBQyxjQUFjLENBQUUsS0FBSyxDQUFFLENBQUM7SUFDeEQsSUFBSyxVQUFVLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEtBQUssVUFBVSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUcsQ0FBQztRQUNsRyxNQUFNLElBQUksb0JBQW9CLENBQUUsbUNBQW1DLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxTQUFTLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxHQUFHLENBQUUsQ0FBQztJQUNwSSxDQUFDO0lBS0QsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7SUFFbkMsTUFBTSxLQUFLLEdBQVEsSUFBQSxpQkFBTyxvQkFBTyxJQUFJLEVBQUksQ0FBQztJQUUxQyxPQUFPLEtBQUssQ0FBQyxXQUFXLENBQUM7SUFFekIsTUFBTSxLQUFLLEdBQVEsSUFBQSxpQkFBTyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUUsRUFBRSxFQUFFLEtBQUssQ0FBRSxDQUFFLENBQUM7SUFDekQsT0FBTyxLQUFLLENBQUMsV0FBVyxDQUFDO0lBRXpCLElBQUksTUFBTSxDQUFDO0lBQ1gsSUFBSyxVQUFVLENBQUUscUJBQXFCLENBQUUsS0FBSyxTQUFTLEVBQUcsQ0FBQztRQUN6RCxNQUFNLEdBQUcsVUFBVSxDQUFDO0lBQ3JCLENBQUM7U0FBTSxDQUFDO1FBQ1AsTUFBTSxHQUFHLElBQUEsYUFBSyxFQUFFLE9BQU8sQ0FBQyxjQUFjLENBQUUsVUFBVSxDQUFFLENBQUUsQ0FBQztJQUN4RCxDQUFDO0lBRUQsT0FBTztRQUVOLElBQUk7UUFFSixLQUFLO1FBR0wsSUFBSTtRQUNKLEtBQUs7UUFFTCxLQUFLO1FBRUwsTUFBTTtLQUVOLENBQUM7QUFDSCxDQUFDLENBQUM7QUFuRFcsUUFBQSxLQUFLLFNBbURoQiIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgRXJyb3JzVHlwZXMgfSBmcm9tICcuLi9kZXNjcmlwdG9ycy9lcnJvcnMnO1xuY29uc3Qge1xuXHRXUk9OR19NT0RJRklDQVRJT05fUEFUVEVSTixcblx0V1JPTkdfQVJHVU1FTlRTX1VTRURcbn0gPSBFcnJvcnNUeXBlcztcblxuaW1wb3J0IHsgY29uc3RhbnRzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmNvbnN0IHtcblx0TU5FTU9OSUNBLFxuXHRTeW1ib2xDb25zdHJ1Y3Rvck5hbWVcbn0gPSBjb25zdGFudHM7XG5cblxuaW1wb3J0IHsgZXh0cmFjdCB9IGZyb20gJy4vZXh0cmFjdCc7XG5cbmV4cG9ydCBjb25zdCBwYXJzZSA9ICggc2VsZjogYW55ICk6IGFueSA9PiB7XG5cblx0aWYgKCAhc2VsZiB8fCAhc2VsZi5jb25zdHJ1Y3RvciApIHtcblx0XHR0aHJvdyBuZXcgV1JPTkdfTU9ESUZJQ0FUSU9OX1BBVFRFUk47XG5cdH1cblxuXHRjb25zdCBwcm90byA9IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YoIHNlbGYgKSBhcyBvYmplY3Q7XG5cblx0aWYgKCBzZWxmLmNvbnN0cnVjdG9yLm5hbWUudG9TdHJpbmcoKSAhPT0gcHJvdG8uY29uc3RydWN0b3IubmFtZS50b1N0cmluZygpICkge1xuXHRcdHRocm93IG5ldyBXUk9OR19BUkdVTUVOVFNfVVNFRCggYGhhdmUgdG8gdXNlIFwiaW5zdGFuY2VcIiBpdHNlbGY6ICcke3NlbGYuY29uc3RydWN0b3IubmFtZX0nIHZzICcke3Byb3RvLmNvbnN0cnVjdG9yLm5hbWV9J2AgKTtcblx0fVxuXG5cdGNvbnN0IHByb3RvUHJvdG86IGFueSA9IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YoIHByb3RvICk7XG5cdGlmICggcHJvdG9Qcm90byAmJiBwcm90by5jb25zdHJ1Y3Rvci5uYW1lLnRvU3RyaW5nKCkgIT09IHByb3RvUHJvdG8uY29uc3RydWN0b3IubmFtZS50b1N0cmluZygpICkge1xuXHRcdHRocm93IG5ldyBXUk9OR19BUkdVTUVOVFNfVVNFRCggYGhhdmUgdG8gdXNlIFwiaW5zdGFuY2VcIiBpdHNlbGY6ICcke3Byb3RvLmNvbnN0cnVjdG9yLm5hbWV9JyB2cyAnJHtwcm90b1Byb3RvLmNvbnN0cnVjdG9yLm5hbWV9J2AgKTtcblx0fVxuXG5cdC8vIGNvbnN0IGFyZ3MgPSBzZWxmW1N5bWJvbENvbnN0cnVjdG9yTmFtZV0gP1xuXHQvLyBzZWxmW1N5bWJvbENvbnN0cnVjdG9yTmFtZV0uYXJncyA6IFtdO1xuXG5cdGNvbnN0IHsgbmFtZSB9ID0gcHJvdG8uY29uc3RydWN0b3I7XG5cblx0Y29uc3QgcHJvcHM6IGFueSA9IGV4dHJhY3QoIHsgLi4uc2VsZiB9ICk7XG5cdC8vIHByb3BzLmNvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuXHRkZWxldGUgcHJvcHMuY29uc3RydWN0b3I7XG5cblx0Y29uc3Qgam9pbnQ6IGFueSA9IGV4dHJhY3QoIE9iamVjdC5hc3NpZ24oIHt9LCBwcm90byApICk7XG5cdGRlbGV0ZSBqb2ludC5jb25zdHJ1Y3RvcjtcblxuXHRsZXQgcGFyZW50O1xuXHRpZiAoIHByb3RvUHJvdG9bIFN5bWJvbENvbnN0cnVjdG9yTmFtZSBdID09PSBNTkVNT05JQ0EgKSB7XG5cdFx0cGFyZW50ID0gcHJvdG9Qcm90bztcblx0fSBlbHNlIHtcblx0XHRwYXJlbnQgPSBwYXJzZSggUmVmbGVjdC5nZXRQcm90b3R5cGVPZiggcHJvdG9Qcm90byApICk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXG5cdFx0bmFtZSxcblxuXHRcdHByb3BzLFxuXHRcdC8vIHRoZSBsaW5lIGJlbG93IGNvcHkgc3ltYm9scyBhbHNvXG5cblx0XHRzZWxmLFxuXHRcdHByb3RvLFxuXG5cdFx0am9pbnQsXG5cdFx0Ly8gYXJncyxcblx0XHRwYXJlbnQsXG5cblx0fTtcbn07XG4iXX0=