'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineStackCleaner = exports.utils = exports.errors = exports.defaultCollection = exports.createTypesCollection = exports.ErrorMessages = exports.TYPE_TITLE_PREFIX = exports.URANUS = exports.GAIA = exports.MNEMOSYNE = exports.MNEMONICA = exports.SymbolConfig = exports.SymbolDefaultTypesCollection = exports.SymbolReplaceUranus = exports.SymbolGaia = exports.SymbolConstructorName = exports.SymbolParentType = exports.mnemonica = exports.registerHook = exports.decorate = exports.bind = exports.call = exports.apply = exports.lookup = exports.define = exports.defaultTypes = exports.setProps = exports.getProps = void 0;
var Props_1 = require("./api/types/Props");
Object.defineProperty(exports, "getProps", { enumerable: true, get: function () { return Props_1.getProps; } });
Object.defineProperty(exports, "setProps", { enumerable: true, get: function () { return Props_1.setProps; } });
const constants_1 = require("./constants");
const { odp } = constants_1.constants;
const errorsApi = require("./api/errors");
const descriptors_1 = require("./descriptors");
exports.defaultTypes = descriptors_1.descriptors.defaultTypes;
function checkThis(pointer) {
    return pointer === exports.mnemonica || pointer === exports;
}
const define = function (TypeName, constructHandler, proto, config) {
    const types = checkThis(this) ? exports.defaultTypes : this || exports.defaultTypes;
    return types.define(TypeName, constructHandler, proto, config);
};
exports.define = define;
exports.lookup = function (TypeNestedPath) {
    const types = checkThis(this) ? exports.defaultTypes : this || exports.defaultTypes;
    return types.lookup(TypeNestedPath);
};
const apply = function (entity, Constructor, args = []) {
    const result = new entity[Constructor.TypeName](...args);
    return result;
};
exports.apply = apply;
const call = function (entity, Constructor, ...args) {
    const result = new entity[Constructor.TypeName](...args);
    return result;
};
exports.call = call;
const bind = function (entity, Constructor) {
    return (...args) => {
        const result = new entity[Constructor.TypeName](...args);
        return result;
    };
};
exports.bind = bind;
const decorate = function (parentClass = undefined, proto, config) {
    const decorator = function (cstr, s) {
        if (parentClass === undefined) {
            return (0, exports.define)(s.name, cstr, proto, config);
        }
        return parentClass.define(s.name, cstr, proto, config);
    };
    return decorator;
};
exports.decorate = decorate;
const registerHook = function (Constructor, hookType, cb) {
    Constructor.registerHook(hookType, cb);
};
exports.registerHook = registerHook;
exports.mnemonica = Object.entries(Object.assign(Object.assign(Object.assign({ define: exports.define,
    lookup: exports.lookup,
    apply: exports.apply,
    call: exports.call,
    bind: exports.bind,
    decorate: exports.decorate,
    registerHook: exports.registerHook }, descriptors_1.descriptors), errorsApi), constants_1.constants)).reduce((acc, entry) => {
    const [name, code] = entry;
    odp(acc, name, {
        get() {
            return code;
        },
        enumerable: true
    });
    return acc;
}, {});
exports.SymbolParentType = exports.mnemonica.SymbolParentType, exports.SymbolConstructorName = exports.mnemonica.SymbolConstructorName, exports.SymbolGaia = exports.mnemonica.SymbolGaia, exports.SymbolReplaceUranus = exports.mnemonica.SymbolReplaceUranus, exports.SymbolDefaultTypesCollection = exports.mnemonica.SymbolDefaultTypesCollection, exports.SymbolConfig = exports.mnemonica.SymbolConfig, exports.MNEMONICA = exports.mnemonica.MNEMONICA, exports.MNEMOSYNE = exports.mnemonica.MNEMOSYNE, exports.GAIA = exports.mnemonica.GAIA, exports.URANUS = exports.mnemonica.URANUS, exports.TYPE_TITLE_PREFIX = exports.mnemonica.TYPE_TITLE_PREFIX, exports.ErrorMessages = exports.mnemonica.ErrorMessages, exports.createTypesCollection = exports.mnemonica.createTypesCollection;
exports.defaultCollection = exports.defaultTypes.subtypes;
exports.errors = descriptors_1.descriptors.ErrorsTypes;
var utils_1 = require("./utils");
Object.defineProperty(exports, "utils", { enumerable: true, get: function () { return utils_1.utils; } });
var utils_2 = require("./utils");
Object.defineProperty(exports, "defineStackCleaner", { enumerable: true, get: function () { return utils_2.defineStackCleaner; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsWUFBWSxDQUFDOzs7QUFhYiwyQ0FBd0Q7QUFBOUMsaUdBQUEsUUFBUSxPQUFBO0FBQUUsaUdBQUEsUUFBUSxPQUFBO0FBRTVCLDJDQUF3QztBQUN4QyxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcscUJBQVMsQ0FBQztBQUUxQiwwQ0FBMEM7QUFDMUMsK0NBQTRDO0FBRzNDLG9CQUFZLEdBQ1QseUJBQVcsY0FBQztBQUVoQixTQUFTLFNBQVMsQ0FBRyxPQUFvRDtJQUN4RSxPQUFPLE9BQU8sS0FBSyxpQkFBUyxJQUFJLE9BQU8sS0FBSyxPQUFPLENBQUM7QUFDckQsQ0FBQztBQUVNLE1BQU0sTUFBTSxHQUFHLFVBYXJCLFFBQWlCLEVBQ2pCLGdCQUEwQixFQUMxQixLQUFTLEVBQ1QsTUFBMkI7SUFFM0IsTUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFFLElBQUksQ0FBRSxDQUFDLENBQUMsQ0FBQyxvQkFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksb0JBQVksQ0FBQztJQUN0RSxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUUsUUFBUSxFQUFFLGdCQUFnQixFQUFFLEtBQUssRUFBRSxNQUFNLENBQUUsQ0FBQztBQUNsRSxDQUFDLENBQUM7QUFwQlcsUUFBQSxNQUFNLFVBb0JqQjtBQUVXLFFBQUEsTUFBTSxHQUFHLFVBQVcsY0FBYztJQUM5QyxNQUFNLEtBQUssR0FBRyxTQUFTLENBQUUsSUFBSSxDQUFFLENBQUMsQ0FBQyxDQUFDLG9CQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxvQkFBWSxDQUFDO0lBQ3RFLE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBRSxjQUFjLENBQUUsQ0FBQztBQUN2QyxDQUFlLENBQUM7QUFFVCxNQUFNLEtBQUssR0FBRyxVQUF1RSxNQUFTLEVBQUUsV0FBb0IsRUFBRSxPQUFrQixFQUFF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SloseUJBQWlCLEdBSWQsaUJBQVMsb0JBSFoscUJBQWEsR0FHVixpQkFBUyxnQkFGWiw2QkFBcUIsR0FFbEIsaUJBQVMsdUJBQUM7QUFHRCxRQUFBLGlCQUFpQixHQUFHLG9CQUFZLENBQUMsUUFBUSxDQUFDO0FBQzFDLFFBQUEsTUFBTSxHQUFHLHlCQUFXLENBQUMsV0FBVyxDQUFDO0FBRTlDLGlDQUFnQztBQUF2Qiw4RkFBQSxLQUFLLE9BQUE7QUFDZCxpQ0FBNkM7QUFBcEMsMkdBQUEsa0JBQWtCLE9BQUEiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQsIGluZGVudCwgbmV3LWNhcCwgc3BhY2UtYmVmb3JlLWZ1bmN0aW9uLXBhcmVuICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7XG5cdFR5cGVMb29rdXAsXG5cdElERUYsXG5cdGhvb2ssXG5cdGhvb2tzVHlwZXMsXG5cdGNvbnN0cnVjdG9yT3B0aW9ucyxcblx0UHJvdG8sXG5cdFNOLFxuXHRJRGVmaW5pdG9ySW5zdGFuY2Vcbn0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgdHlwZSB7IElERUYsIENvbnN0cnVjdG9yRnVuY3Rpb24gfSBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCB7ICBnZXRQcm9wcywgc2V0UHJvcHMgfSBmcm9tICcuL2FwaS90eXBlcy9Qcm9wcyc7XG5cbmltcG9ydCB7IGNvbnN0YW50cyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmNvbnN0IHsgb2RwIH0gPSBjb25zdGFudHM7XG5cbmltcG9ydCAqIGFzIGVycm9yc0FwaSBmcm9tICcuL2FwaS9lcnJvcnMnO1xuaW1wb3J0IHsgZGVzY3JpcHRvcnMgfSBmcm9tICcuL2Rlc2NyaXB0b3JzJztcblxuZXhwb3J0IGNvbnN0IHtcblx0ZGVmYXVsdFR5cGVzLFxufSA9IGRlc2NyaXB0b3JzO1xuXG5mdW5jdGlvbiBjaGVja1RoaXMgKCBwb2ludGVyOiB0eXBlb2YgbW5lbW9uaWNhIHwgdHlwZW9mIGV4cG9ydHMgfCB1bmtub3duICk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gcG9pbnRlciA9PT0gbW5lbW9uaWNhIHx8IHBvaW50ZXIgPT09IGV4cG9ydHM7XG59XG5cbmV4cG9ydCBjb25zdCBkZWZpbmUgPSBmdW5jdGlvbiA8XG5cdFQsXG5cdC8vIEsgZXh0ZW5kcyBJREVGPFQ+LFxuXHQvLyBIIGV4dGVuZHMgVGhpc1R5cGU8SURFRjxUPj4sXG5cdFAgZXh0ZW5kcyBvYmplY3QsXG5cdE4gZXh0ZW5kcyBQcm90bzxQLCBUPixcblx0Ly8gc28gUyBpdCBqdXN0IGJhc2ljYWxseSBhbGxvd3MgbmVzdGVkIGNvbnN0cnVjdG9yc1xuXHQvLyBhbmQgZ2l2ZXMgZXh0cmFjdGVkIHByb3BzIGZyb20gY29uc3RydWN0SGFuZGxlciAmIHByb3RvXG5cdC8vIHRoZW4gaXQgZ29lcyB0byBuZXcoKSBrZXl3b3JkIG9mIGRlZmluZSBvdXRwdXRcblx0UyBleHRlbmRzIFNOICYgTixcblx0UiBleHRlbmRzIElEZWZpbml0b3JJbnN0YW5jZTxOLCBTPlxuPiAoXG5cdHRoaXM6IHVua25vd24sXG5cdFR5cGVOYW1lPzogc3RyaW5nLFxuXHRjb25zdHJ1Y3RIYW5kbGVyPzogSURFRjxUPixcblx0cHJvdG8/OiBQLFxuXHRjb25maWc/OiBjb25zdHJ1Y3Rvck9wdGlvbnMsXG4pOiBSIHtcblx0Y29uc3QgdHlwZXMgPSBjaGVja1RoaXMoIHRoaXMgKSA/IGRlZmF1bHRUeXBlcyA6IHRoaXMgfHwgZGVmYXVsdFR5cGVzO1xuXHRyZXR1cm4gdHlwZXMuZGVmaW5lKCBUeXBlTmFtZSwgY29uc3RydWN0SGFuZGxlciwgcHJvdG8sIGNvbmZpZyApO1xufTtcblxuZXhwb3J0IGNvbnN0IGxvb2t1cCA9IGZ1bmN0aW9uICggVHlwZU5lc3RlZFBhdGggKSB7XG5cdGNvbnN0IHR5cGVzID0gY2hlY2tUaGlzKCB0aGlzICkgPyBkZWZhdWx0VHlwZXMgOiB0aGlzIHx8IGRlZmF1bHRUeXBlcztcblx0cmV0dXJuIHR5cGVzLmxvb2t1cCggVHlwZU5lc3RlZFBhdGggKTtcbn0gYXMgVHlwZUxvb2t1cDtcblxuZXhwb3J0IGNvbnN0IGFwcGx5ID0gZnVuY3Rpb24gPEUgZXh0ZW5kcyBvYmplY3QsIFQgZXh0ZW5kcyBvYmplY3QsIFMgZXh0ZW5kcyBQcm90bzxFLCBUPj4gKCBlbnRpdHk6IEUsIENvbnN0cnVjdG9yOiBJREVGPFQ+LCBhcmdzOiB1bmtub3duW10gPSBbXSApOiB7XG5cdFsga2V5IGluIGtleW9mIFMgXTogU1sga2V5IF1cbn0ge1xuXHQvLyBAdHMtaWdub3JlXG5cdGNvbnN0IHJlc3VsdCA9IG5ldyBlbnRpdHlbIENvbnN0cnVjdG9yLlR5cGVOYW1lIF0oIC4uLmFyZ3MgKTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBjb25zdCBjYWxsID0gZnVuY3Rpb24gPEUgZXh0ZW5kcyBvYmplY3QsIFQgZXh0ZW5kcyBvYmplY3QsIFMgZXh0ZW5kcyBQcm90bzxFLCBUPj4gKCBlbnRpdHk6IEUsIENvbnN0cnVjdG9yOiBJREVGPFQ+LCAuLi5hcmdzOiB1bmtub3duW10gKToge1xuXHRbIGtleSBpbiBrZXlvZiBTIF06IFNbIGtleSBdXG59IHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRjb25zdCByZXN1bHQgPSBuZXcgZW50aXR5WyBDb25zdHJ1Y3Rvci5UeXBlTmFtZSBdKCAuLi5hcmdzICk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgY29uc3QgYmluZCA9IGZ1bmN0aW9uIDxFIGV4dGVuZHMgb2JqZWN0LCBUIGV4dGVuZHMgb2JqZWN0LCBTIGV4dGVuZHMgUHJvdG88RSwgVD4+ICggZW50aXR5OiBFLCBDb25zdHJ1Y3RvcjogSURFRjxUPiApOiAoIC4uLmFyZ3M6IHVua25vd25bXSApID0+IHtcblx0WyBrZXkgaW4ga2V5b2YgUyBdOiBTWyBrZXkgXVxufSB7XG5cdHJldHVybiAoIC4uLmFyZ3MgKSA9PiB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGNvbnN0IHJlc3VsdCA9IG5ldyBlbnRpdHlbIENvbnN0cnVjdG9yLlR5cGVOYW1lIF0oIC4uLmFyZ3MgKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xufTtcblxuZXhwb3J0IGNvbnN0IGRlY29yYXRlID0gZnVuY3Rpb24gKCBwYXJlbnRDbGFzczogdW5rbm93biA9IHVuZGVmaW5lZCwgcHJvdG8/OiBvYmplY3QsIGNvbmZpZz86IGNvbnN0cnVjdG9yT3B0aW9ucyApIHtcblx0Y29uc3QgZGVjb3JhdG9yID0gZnVuY3Rpb24gPFQgZXh0ZW5kcyB7IG5ldygpOiB1bmtub3duIH0+ICggY3N0cjogVCwgczogQ2xhc3NEZWNvcmF0b3JDb250ZXh0PFQ+ICk6IFQge1xuXHRcdGlmICggcGFyZW50Q2xhc3MgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBkZWZpbmUoIHMubmFtZSwgY3N0ciwgcHJvdG8sIGNvbmZpZyApIGFzIHVua25vd24gYXMgVCA7XG5cdFx0fVxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gcGFyZW50Q2xhc3MuZGVmaW5lKCBzLm5hbWUsIGNzdHIsIHByb3RvLCBjb25maWcgKSBhcyB1bmtub3duIGFzIFQ7XG5cdH07XG5cdHJldHVybiBkZWNvcmF0b3I7XG59O1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJIb29rID0gZnVuY3Rpb24gPFQgZXh0ZW5kcyBvYmplY3Q+ICggQ29uc3RydWN0b3I6IElERUY8VD4sIGhvb2tUeXBlOiBob29rc1R5cGVzLCBjYjogaG9vayApOiB2b2lkIHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRDb25zdHJ1Y3Rvci5yZWdpc3Rlckhvb2soIGhvb2tUeXBlLCBjYiApO1xufTtcblxuZXhwb3J0IGNvbnN0IG1uZW1vbmljYSA9IE9iamVjdC5lbnRyaWVzKCB7XG5cblx0ZGVmaW5lLFxuXHRsb29rdXAsXG5cdGFwcGx5LFxuXHRjYWxsLFxuXHRiaW5kLFxuXHRkZWNvcmF0ZSxcblx0cmVnaXN0ZXJIb29rLFxuXG5cdC4uLmRlc2NyaXB0b3JzLFxuXG5cdC4uLmVycm9yc0FwaSxcblx0Li4uY29uc3RhbnRzLFxuXG59ICkucmVkdWNlKCAoIGFjYzogeyBbIGluZGV4OiBzdHJpbmcgXTogdW5rbm93biB9LCBlbnRyeTogWyBzdHJpbmcsIHVua25vd24gXSApID0+IHtcblx0Y29uc3QgWyBuYW1lLCBjb2RlIF0gPSBlbnRyeTtcblx0b2RwKCBhY2MsIG5hbWUsIHtcblx0XHRnZXQgKCkge1xuXHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0fSxcblx0XHRlbnVtZXJhYmxlIDogdHJ1ZVxuXHR9ICk7XG5cdHJldHVybiBhY2M7XG59LCB7fSApO1xuXG5leHBvcnQgY29uc3Qge1xuXG5cdFN5bWJvbFBhcmVudFR5cGUsXG5cdFN5bWJvbENvbnN0cnVjdG9yTmFtZSxcblx0U3ltYm9sR2FpYSxcblx0U3ltYm9sUmVwbGFjZVVyYW51cyxcblx0U3ltYm9sRGVmYXVsdFR5cGVzQ29sbGVjdGlvbixcblx0U3ltYm9sQ29uZmlnLFxuXHRNTkVNT05JQ0EsXG5cdE1ORU1PU1lORSxcblx0R0FJQSxcblx0VVJBTlVTLFxuXHRUWVBFX1RJVExFX1BSRUZJWCxcblx0RXJyb3JNZXNzYWdlcyxcblx0Y3JlYXRlVHlwZXNDb2xsZWN0aW9uLFxuXG59ID0gbW5lbW9uaWNhO1xuXG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0Q29sbGVjdGlvbiA9IGRlZmF1bHRUeXBlcy5zdWJ0eXBlcztcbmV4cG9ydCBjb25zdCBlcnJvcnMgPSBkZXNjcmlwdG9ycy5FcnJvcnNUeXBlcztcblxuZXhwb3J0IHsgdXRpbHMgfSBmcm9tICcuL3V0aWxzJztcbmV4cG9ydCB7IGRlZmluZVN0YWNrQ2xlYW5lciB9IGZyb20gJy4vdXRpbHMnO1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQsIGluZGVudCwgbmV3LWNhcCwgc3BhY2UtYmVmb3JlLWZ1bmN0aW9uLXBhcmVuICovXG4iXX0=