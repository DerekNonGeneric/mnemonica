'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineStackCleaner = exports.utils = exports.errors = exports.defaultCollection = exports.createTypesCollection = exports.ErrorMessages = exports.TYPE_TITLE_PREFIX = exports.URANUS = exports.GAIA = exports.MNEMOSYNE = exports.MNEMONICA = exports.SymbolConfig = exports.SymbolDefaultTypesCollection = exports.SymbolReplaceUranus = exports.SymbolGaia = exports.SymbolConstructorName = exports.SymbolParentType = exports.mnemonica = exports.registerHook = exports.decorate = exports.bind = exports.call = exports.apply = exports.lookup = exports.define = exports.defaultTypes = void 0;
const constants_1 = require("./constants");
const { odp } = constants_1.constants;
const errorsApi = require("./api/errors");
const descriptors_1 = require("./descriptors");
exports.defaultTypes = descriptors_1.descriptors.defaultTypes;
function checkThis(pointer) {
    return pointer === exports.mnemonica || pointer === exports;
}
const define = function (TypeName, constructHandler, proto, config) {
    const types = checkThis(this) ? exports.defaultTypes : this || exports.defaultTypes;
    return types.define(TypeName, constructHandler, proto, config);
};
exports.define = define;
exports.lookup = function (TypeNestedPath) {
    const types = checkThis(this) ? exports.defaultTypes : this || exports.defaultTypes;
    return types.lookup(TypeNestedPath);
};
const apply = function (entity, Constructor, args = []) {
    const result = new entity[Constructor.TypeName](...args);
    return result;
};
exports.apply = apply;
const call = function (entity, Constructor, ...args) {
    const result = new entity[Constructor.TypeName](...args);
    return result;
};
exports.call = call;
const bind = function (entity, Constructor) {
    return (...args) => {
        const result = new entity[Constructor.TypeName](...args);
        return result;
    };
};
exports.bind = bind;
const decorate = function (parentClass = undefined, proto, config) {
    const decorator = function (cstr, s) {
        if (parentClass === undefined) {
            return (0, exports.define)(s.name, cstr, proto, config);
        }
        return parentClass.define(s.name, cstr, proto, config);
    };
    return decorator;
};
exports.decorate = decorate;
const registerHook = function (Constructor, hookType, cb) {
    Constructor.registerHook(hookType, cb);
};
exports.registerHook = registerHook;
exports.mnemonica = Object.entries(Object.assign(Object.assign(Object.assign({ define: exports.define,
    lookup: exports.lookup,
    apply: exports.apply,
    call: exports.call,
    bind: exports.bind,
    decorate: exports.decorate,
    registerHook: exports.registerHook }, descriptors_1.descriptors), errorsApi), constants_1.constants)).reduce((acc, entry) => {
    const [name, code] = entry;
    odp(acc, name, {
        get() {
            return code;
        },
        enumerable: true
    });
    return acc;
}, {});
exports.SymbolParentType = exports.mnemonica.SymbolParentType, exports.SymbolConstructorName = exports.mnemonica.SymbolConstructorName, exports.SymbolGaia = exports.mnemonica.SymbolGaia, exports.SymbolReplaceUranus = exports.mnemonica.SymbolReplaceUranus, exports.SymbolDefaultTypesCollection = exports.mnemonica.SymbolDefaultTypesCollection, exports.SymbolConfig = exports.mnemonica.SymbolConfig, exports.MNEMONICA = exports.mnemonica.MNEMONICA, exports.MNEMOSYNE = exports.mnemonica.MNEMOSYNE, exports.GAIA = exports.mnemonica.GAIA, exports.URANUS = exports.mnemonica.URANUS, exports.TYPE_TITLE_PREFIX = exports.mnemonica.TYPE_TITLE_PREFIX, exports.ErrorMessages = exports.mnemonica.ErrorMessages, exports.createTypesCollection = exports.mnemonica.createTypesCollection;
exports.defaultCollection = exports.defaultTypes.subtypes;
exports.errors = descriptors_1.descriptors.ErrorsTypes;
var utils_1 = require("./utils");
Object.defineProperty(exports, "utils", { enumerable: true, get: function () { return utils_1.utils; } });
var utils_2 = require("./utils");
Object.defineProperty(exports, "defineStackCleaner", { enumerable: true, get: function () { return utils_2.defineStackCleaner; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsWUFBWSxDQUFDOzs7QUFjYiwyQ0FBd0M7QUFDeEMsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLHFCQUFTLENBQUM7QUFFMUIsMENBQTBDO0FBQzFDLCtDQUE0QztBQUczQyxvQkFBWSxHQUNULHlCQUFXLGNBQUM7QUFFaEIsU0FBUyxTQUFTLENBQUcsT0FBb0Q7SUFDeEUsT0FBTyxPQUFPLEtBQUssaUJBQVMsSUFBSSxPQUFPLEtBQUssT0FBTyxDQUFDO0FBQ3JELENBQUM7QUFFTSxNQUFNLE1BQU0sR0FBRyxVQWFyQixRQUFpQixFQUNqQixnQkFBMEIsRUFDMUIsS0FBUyxFQUNULE1BQTJCO0lBRTNCLE1BQU0sS0FBSyxHQUFHLFNBQVMsQ0FBRSxJQUFJLENBQUUsQ0FBQyxDQUFDLENBQUMsb0JBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLG9CQUFZLENBQUM7SUFDdEUsT0FBTyxLQUFLLENBQUMsTUFBTSxDQUFFLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFFLENBQUM7QUFDbEUsQ0FBQyxDQUFDO0FBcEJXLFFBQUEsTUFBTSxVQW9CakI7QUFFVyxRQUFBLE1BQU0sR0FBRyxVQUFXLGNBQWM7SUFDOUMsTUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFFLElBQUksQ0FBRSxDQUFDLENBQUMsQ0FBQyxvQkFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksb0JBQVksQ0FBQztJQUN0RSxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUUsY0FBYyxDQUFFLENBQUM7QUFDdkMsQ0FBZSxDQUFDO0FBRVQsTUFBTSxLQUFLLEdBQUcsVUFBdUUsTUFBUyxFQUFFLFdBQW9CLEVBQUUsT0FBa0IsRUFBRTtJQUloSixNQUFNLE1BQU0sR0FBRyxJQUFJLE1BQU0sQ0FBRSxXQUFXLENBQUMsUUFBUSxDQUFF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LEdBRWxCLGlCQUFTLHVCQUFDO0FBR0QsUUFBQSxpQkFBaUIsR0FBRyxvQkFBWSxDQUFDLFFBQVEsQ0FBQztBQUMxQyxRQUFBLE1BQU0sR0FBRyx5QkFBVyxDQUFDLFdBQVcsQ0FBQztBQUU5QyxpQ0FBZ0M7QUFBdkIsOEZBQUEsS0FBSyxPQUFBO0FBQ2QsaUNBQTZDO0FBQXBDLDJHQUFBLGtCQUFrQixPQUFBIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50LCBpbmRlbnQsIG5ldy1jYXAsIHNwYWNlLWJlZm9yZS1mdW5jdGlvbi1wYXJlbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1xuXHRUeXBlTG9va3VwLFxuXHRJREVGLFxuXHRob29rLFxuXHRob29rc1R5cGVzLFxuXHRjb25zdHJ1Y3Rvck9wdGlvbnMsXG5cdFByb3RvLFxuXHRTTixcblx0SURlZmluaXRvckluc3RhbmNlXG59IGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IHR5cGUgeyBJREVGLCBDb25zdHJ1Y3RvckZ1bmN0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbmltcG9ydCB7IGNvbnN0YW50cyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmNvbnN0IHsgb2RwIH0gPSBjb25zdGFudHM7XG5cbmltcG9ydCAqIGFzIGVycm9yc0FwaSBmcm9tICcuL2FwaS9lcnJvcnMnO1xuaW1wb3J0IHsgZGVzY3JpcHRvcnMgfSBmcm9tICcuL2Rlc2NyaXB0b3JzJztcblxuZXhwb3J0IGNvbnN0IHtcblx0ZGVmYXVsdFR5cGVzLFxufSA9IGRlc2NyaXB0b3JzO1xuXG5mdW5jdGlvbiBjaGVja1RoaXMgKCBwb2ludGVyOiB0eXBlb2YgbW5lbW9uaWNhIHwgdHlwZW9mIGV4cG9ydHMgfCB1bmtub3duICk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gcG9pbnRlciA9PT0gbW5lbW9uaWNhIHx8IHBvaW50ZXIgPT09IGV4cG9ydHM7XG59XG5cbmV4cG9ydCBjb25zdCBkZWZpbmUgPSBmdW5jdGlvbiA8XG5cdFQsXG5cdC8vIEsgZXh0ZW5kcyBJREVGPFQ+LFxuXHQvLyBIIGV4dGVuZHMgVGhpc1R5cGU8SURFRjxUPj4sXG5cdFAgZXh0ZW5kcyBvYmplY3QsXG5cdE4gZXh0ZW5kcyBQcm90bzxQLCBUPixcblx0Ly8gc28gUyBpdCBqdXN0IGJhc2ljYWxseSBhbGxvd3MgbmVzdGVkIGNvbnN0cnVjdG9yc1xuXHQvLyBhbmQgZ2l2ZXMgZXh0cmFjdGVkIHByb3BzIGZyb20gY29uc3RydWN0SGFuZGxlciAmIHByb3RvXG5cdC8vIHRoZW4gaXQgZ29lcyB0byBuZXcoKSBrZXl3b3JkIG9mIGRlZmluZSBvdXRwdXRcblx0UyBleHRlbmRzIFNOICYgTixcblx0UiBleHRlbmRzIElEZWZpbml0b3JJbnN0YW5jZTxOLCBTPlxuPiAoXG5cdHRoaXM6IHVua25vd24sXG5cdFR5cGVOYW1lPzogc3RyaW5nLFxuXHRjb25zdHJ1Y3RIYW5kbGVyPzogSURFRjxUPixcblx0cHJvdG8/OiBQLFxuXHRjb25maWc/OiBjb25zdHJ1Y3Rvck9wdGlvbnMsXG4pOiBSIHtcblx0Y29uc3QgdHlwZXMgPSBjaGVja1RoaXMoIHRoaXMgKSA/IGRlZmF1bHRUeXBlcyA6IHRoaXMgfHwgZGVmYXVsdFR5cGVzO1xuXHRyZXR1cm4gdHlwZXMuZGVmaW5lKCBUeXBlTmFtZSwgY29uc3RydWN0SGFuZGxlciwgcHJvdG8sIGNvbmZpZyApO1xufTtcblxuZXhwb3J0IGNvbnN0IGxvb2t1cCA9IGZ1bmN0aW9uICggVHlwZU5lc3RlZFBhdGggKSB7XG5cdGNvbnN0IHR5cGVzID0gY2hlY2tUaGlzKCB0aGlzICkgPyBkZWZhdWx0VHlwZXMgOiB0aGlzIHx8IGRlZmF1bHRUeXBlcztcblx0cmV0dXJuIHR5cGVzLmxvb2t1cCggVHlwZU5lc3RlZFBhdGggKTtcbn0gYXMgVHlwZUxvb2t1cDtcblxuZXhwb3J0IGNvbnN0IGFwcGx5ID0gZnVuY3Rpb24gPEUgZXh0ZW5kcyBvYmplY3QsIFQgZXh0ZW5kcyBvYmplY3QsIFMgZXh0ZW5kcyBQcm90bzxFLCBUPj4gKCBlbnRpdHk6IEUsIENvbnN0cnVjdG9yOiBJREVGPFQ+LCBhcmdzOiB1bmtub3duW10gPSBbXSApOiB7XG5cdFsga2V5IGluIGtleW9mIFMgXTogU1sga2V5IF1cbn0ge1xuXHQvLyBAdHMtaWdub3JlXG5cdGNvbnN0IHJlc3VsdCA9IG5ldyBlbnRpdHlbIENvbnN0cnVjdG9yLlR5cGVOYW1lIF0oIC4uLmFyZ3MgKTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBjb25zdCBjYWxsID0gZnVuY3Rpb24gPEUgZXh0ZW5kcyBvYmplY3QsIFQgZXh0ZW5kcyBvYmplY3QsIFMgZXh0ZW5kcyBQcm90bzxFLCBUPj4gKCBlbnRpdHk6IEUsIENvbnN0cnVjdG9yOiBJREVGPFQ+LCAuLi5hcmdzOiB1bmtub3duW10gKToge1xuXHRbIGtleSBpbiBrZXlvZiBTIF06IFNbIGtleSBdXG59IHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRjb25zdCByZXN1bHQgPSBuZXcgZW50aXR5WyBDb25zdHJ1Y3Rvci5UeXBlTmFtZSBdKCAuLi5hcmdzICk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgY29uc3QgYmluZCA9IGZ1bmN0aW9uIDxFIGV4dGVuZHMgb2JqZWN0LCBUIGV4dGVuZHMgb2JqZWN0LCBTIGV4dGVuZHMgUHJvdG88RSwgVD4+ICggZW50aXR5OiBFLCBDb25zdHJ1Y3RvcjogSURFRjxUPiApOiAoIC4uLmFyZ3M6IHVua25vd25bXSApID0+IHtcblx0WyBrZXkgaW4ga2V5b2YgUyBdOiBTWyBrZXkgXVxufSB7XG5cdHJldHVybiAoIC4uLmFyZ3MgKSA9PiB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGNvbnN0IHJlc3VsdCA9IG5ldyBlbnRpdHlbIENvbnN0cnVjdG9yLlR5cGVOYW1lIF0oIC4uLmFyZ3MgKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xufTtcblxuZXhwb3J0IGNvbnN0IGRlY29yYXRlID0gZnVuY3Rpb24gKCBwYXJlbnRDbGFzczogdW5rbm93biA9IHVuZGVmaW5lZCwgcHJvdG8/OiBvYmplY3QsIGNvbmZpZz86IGNvbnN0cnVjdG9yT3B0aW9ucyApIHtcblx0Y29uc3QgZGVjb3JhdG9yID0gZnVuY3Rpb24gPFQgZXh0ZW5kcyB7IG5ldygpOiB1bmtub3duIH0+ICggY3N0cjogVCwgczogQ2xhc3NEZWNvcmF0b3JDb250ZXh0PFQ+ICk6IFQge1xuXHRcdGlmICggcGFyZW50Q2xhc3MgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBkZWZpbmUoIHMubmFtZSwgY3N0ciwgcHJvdG8sIGNvbmZpZyApIGFzIHVua25vd24gYXMgVCA7XG5cdFx0fVxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gcGFyZW50Q2xhc3MuZGVmaW5lKCBzLm5hbWUsIGNzdHIsIHByb3RvLCBjb25maWcgKSBhcyB1bmtub3duIGFzIFQ7XG5cdH07XG5cdHJldHVybiBkZWNvcmF0b3I7XG59O1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJIb29rID0gZnVuY3Rpb24gPFQgZXh0ZW5kcyBvYmplY3Q+ICggQ29uc3RydWN0b3I6IElERUY8VD4sIGhvb2tUeXBlOiBob29rc1R5cGVzLCBjYjogaG9vayApOiB2b2lkIHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRDb25zdHJ1Y3Rvci5yZWdpc3Rlckhvb2soIGhvb2tUeXBlLCBjYiApO1xufTtcblxuZXhwb3J0IGNvbnN0IG1uZW1vbmljYSA9IE9iamVjdC5lbnRyaWVzKCB7XG5cblx0ZGVmaW5lLFxuXHRsb29rdXAsXG5cdGFwcGx5LFxuXHRjYWxsLFxuXHRiaW5kLFxuXHRkZWNvcmF0ZSxcblx0cmVnaXN0ZXJIb29rLFxuXG5cdC4uLmRlc2NyaXB0b3JzLFxuXG5cdC4uLmVycm9yc0FwaSxcblx0Li4uY29uc3RhbnRzLFxuXG59ICkucmVkdWNlKCAoIGFjYzogeyBbIGluZGV4OiBzdHJpbmcgXTogdW5rbm93biB9LCBlbnRyeTogWyBzdHJpbmcsIHVua25vd24gXSApID0+IHtcblx0Y29uc3QgWyBuYW1lLCBjb2RlIF0gPSBlbnRyeTtcblx0b2RwKCBhY2MsIG5hbWUsIHtcblx0XHRnZXQgKCkge1xuXHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0fSxcblx0XHRlbnVtZXJhYmxlIDogdHJ1ZVxuXHR9ICk7XG5cdHJldHVybiBhY2M7XG59LCB7fSApO1xuXG5leHBvcnQgY29uc3Qge1xuXG5cdFN5bWJvbFBhcmVudFR5cGUsXG5cdFN5bWJvbENvbnN0cnVjdG9yTmFtZSxcblx0U3ltYm9sR2FpYSxcblx0U3ltYm9sUmVwbGFjZVVyYW51cyxcblx0U3ltYm9sRGVmYXVsdFR5cGVzQ29sbGVjdGlvbixcblx0U3ltYm9sQ29uZmlnLFxuXHRNTkVNT05JQ0EsXG5cdE1ORU1PU1lORSxcblx0R0FJQSxcblx0VVJBTlVTLFxuXHRUWVBFX1RJVExFX1BSRUZJWCxcblx0RXJyb3JNZXNzYWdlcyxcblx0Y3JlYXRlVHlwZXNDb2xsZWN0aW9uLFxuXG59ID0gbW5lbW9uaWNhO1xuXG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0Q29sbGVjdGlvbiA9IGRlZmF1bHRUeXBlcy5zdWJ0eXBlcztcbmV4cG9ydCBjb25zdCBlcnJvcnMgPSBkZXNjcmlwdG9ycy5FcnJvcnNUeXBlcztcblxuZXhwb3J0IHsgdXRpbHMgfSBmcm9tICcuL3V0aWxzJztcbmV4cG9ydCB7IGRlZmluZVN0YWNrQ2xlYW5lciB9IGZyb20gJy4vdXRpbHMnO1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQsIGluZGVudCwgbmV3LWNhcCwgc3BhY2UtYmVmb3JlLWZ1bmN0aW9uLXBhcmVuICovXG4iXX0=