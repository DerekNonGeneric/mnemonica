'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineStackCleaner = exports.utils = exports.errors = exports.defaultCollection = exports.createTypesCollection = exports.ErrorMessages = exports.TYPE_TITLE_PREFIX = exports.MNEMOSYNE = exports.MNEMONICA = exports.SymbolConfig = exports.SymbolDefaultTypesCollection = exports.SymbolConstructorName = exports.SymbolParentType = exports.mnemonica = exports.registerHook = exports.decorate = exports.bind = exports.call = exports.apply = exports.lookup = exports.define = exports.defaultTypes = exports.setProps = exports.getProps = void 0;
var Props_1 = require("./api/types/Props");
Object.defineProperty(exports, "getProps", { enumerable: true, get: function () { return Props_1.getProps; } });
Object.defineProperty(exports, "setProps", { enumerable: true, get: function () { return Props_1.setProps; } });
const constants_1 = require("./constants");
const { odp } = constants_1.constants;
const errorsApi = require("./api/errors");
const descriptors_1 = require("./descriptors");
const Mnemosyne_1 = require("./api/types/Mnemosyne");
const { prepareSubtypeForConstruction } = Mnemosyne_1.default;
exports.defaultTypes = descriptors_1.descriptors.defaultTypes;
function checkThis(pointer) {
    return pointer === exports.mnemonica || pointer === exports;
}
const define = function (TypeName, constructHandler, config) {
    const types = checkThis(this) ? exports.defaultTypes : this || exports.defaultTypes;
    return types.define(TypeName, constructHandler, config);
};
exports.define = define;
exports.lookup = function (TypeNestedPath) {
    const types = checkThis(this) ? exports.defaultTypes : this || exports.defaultTypes;
    return types.lookup(TypeNestedPath);
};
const $run = function (entity, Constructor, args = []) {
    const { TypeName } = Constructor;
    const Cstr = prepareSubtypeForConstruction(TypeName, entity);
    if (Cstr === undefined) {
        throw new TypeError(`Type ${TypeName} is not defined in the current context.`);
    }
    const result = new Cstr(...args);
    return result;
};
const apply = function (entity, Constructor, args = []) {
    return $run(entity, Constructor, args);
};
exports.apply = apply;
const call = function (entity, Constructor, ...args) {
    return $run(entity, Constructor, args);
};
exports.call = call;
const bind = function (entity, Constructor) {
    return (...args) => {
        return $run(entity, Constructor, args);
    };
};
exports.bind = bind;
const decorate = function (parentClass = {}, config) {
    if (typeof parentClass === 'object' && !(parentClass instanceof Function)) {
        config = parentClass;
        parentClass = undefined;
    }
    const decorator = function (cstr, s) {
        if (parentClass === undefined) {
            return (0, exports.define)(s.name, cstr, config);
        }
        return parentClass.define(s.name, cstr, config);
    };
    return decorator;
};
exports.decorate = decorate;
const registerHook = function (Constructor, hookType, cb) {
    Constructor.registerHook(hookType, cb);
};
exports.registerHook = registerHook;
exports.mnemonica = Object.entries(Object.assign(Object.assign(Object.assign({ define: exports.define,
    lookup: exports.lookup,
    apply: exports.apply,
    call: exports.call,
    bind: exports.bind,
    decorate: exports.decorate,
    registerHook: exports.registerHook }, descriptors_1.descriptors), errorsApi), constants_1.constants)).reduce((acc, entry) => {
    const [name, code] = entry;
    odp(acc, name, {
        get() {
            return code;
        },
        enumerable: true
    });
    return acc;
}, {});
exports.SymbolParentType = exports.mnemonica.SymbolParentType, exports.SymbolConstructorName = exports.mnemonica.SymbolConstructorName, exports.SymbolDefaultTypesCollection = exports.mnemonica.SymbolDefaultTypesCollection, exports.SymbolConfig = exports.mnemonica.SymbolConfig, exports.MNEMONICA = exports.mnemonica.MNEMONICA, exports.MNEMOSYNE = exports.mnemonica.MNEMOSYNE, exports.TYPE_TITLE_PREFIX = exports.mnemonica.TYPE_TITLE_PREFIX, exports.ErrorMessages = exports.mnemonica.ErrorMessages, exports.createTypesCollection = exports.mnemonica.createTypesCollection;
exports.defaultCollection = exports.defaultTypes.subtypes;
exports.errors = descriptors_1.descriptors.ErrorsTypes;
var utils_1 = require("./utils");
Object.defineProperty(exports, "utils", { enumerable: true, get: function () { return utils_1.utils; } });
var utils_2 = require("./utils");
Object.defineProperty(exports, "defineStackCleaner", { enumerable: true, get: function () { return utils_2.defineStackCleaner; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsWUFBWSxDQUFDOzs7QUFhYiwyQ0FBdUQ7QUFBOUMsaUdBQUEsUUFBUSxPQUFBO0FBQUUsaUdBQUEsUUFBUSxPQUFBO0FBRTNCLDJDQUF3QztBQUN4QyxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcscUJBQVMsQ0FBQztBQUUxQiwwQ0FBMEM7QUFDMUMsK0NBQTRDO0FBRTVDLHFEQUErQztBQUMvQyxNQUFNLEVBQUUsNkJBQTZCLEVBQUUsR0FBRyxtQkFBVSxDQUFDO0FBR3BELG9CQUFZLEdBQ1QseUJBQVcsY0FBQztBQUVoQixTQUFTLFNBQVMsQ0FBQyxPQUFvRDtJQUN0RSxPQUFPLE9BQU8sS0FBSyxpQkFBUyxJQUFJLE9BQU8sS0FBSyxPQUFPLENBQUM7QUFDckQsQ0FBQztBQUVNLE1BQU0sTUFBTSxHQUFHLFVBYXJCLFFBQWlCLEVBQ2pCLGdCQUEwQixFQUMxQixNQUEyQjtJQUUzQixNQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLG9CQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxvQkFBWSxDQUFDO0lBQ3BFLE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDekQsQ0FBQyxDQUFDO0FBbkJXLFFBQUEsTUFBTSxVQW1CakI7QUFFVyxRQUFBLE1BQU0sR0FBRyxVQUFVLGNBQWM7SUFDN0MsTUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxvQkFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksb0JBQVksQ0FBQztJQUNwRSxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDckMsQ0FBZSxDQUFDO0FBR2hCLE1BQU0sSUFBSSxHQUFH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QUFJLEVBQUU7UUFDZCxHQUFHO1lBQ0YsT0FBTyxJQUFJLENBQUM7UUFDYixDQUFDO1FBQ0QsVUFBVSxFQUFHLElBQUk7S0FDakIsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxHQUFHLENBQUM7QUFDWixDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFJTix3QkFBZ0IsR0FVYixpQkFBUyxtQkFUWiw2QkFBcUIsR0FTbEIsaUJBQVMsd0JBUlosb0NBQTRCLEdBUXpCLGlCQUFTLCtCQVBaLG9CQUFZLEdBT1QsaUJBQVMsZUFOWixpQkFBUyxHQU1OLGlCQUFTLFlBTFosaUJBQVMsR0FLTixpQkFBUyxZQUpaLHlCQUFpQixHQUlkLGlCQUFTLG9CQUhaLHFCQUFhLEdBR1YsaUJBQVMsZ0JBRlosNkJBQXFCLEdBRWxCLGlCQUFTLHVCQUFDO0FBR0QsUUFBQSxpQkFBaUIsR0FBRyxvQkFBWSxDQUFDLFFBQVEsQ0FBQztBQUMxQyxRQUFBLE1BQU0sR0FBRyx5QkFBVyxDQUFDLFdBQVcsQ0FBQztBQUU5QyxpQ0FBZ0M7QUFBdkIsOEZBQUEsS0FBSyxPQUFBO0FBQ2QsaUNBQTZDO0FBQXBDLDJHQUFBLGtCQUFrQixPQUFBIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50LCBpbmRlbnQsIG5ldy1jYXAsIHNwYWNlLWJlZm9yZS1mdW5jdGlvbi1wYXJlbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1xuXHRUeXBlTG9va3VwLFxuXHRJREVGLFxuXHRob29rLFxuXHRob29rc1R5cGVzLFxuXHRjb25zdHJ1Y3Rvck9wdGlvbnMsXG5cdFByb3RvLFxuXHRTTixcblx0SURlZmluaXRvckluc3RhbmNlXG59IGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IHR5cGUgeyBJREVGLCBDb25zdHJ1Y3RvckZ1bmN0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgeyBnZXRQcm9wcywgc2V0UHJvcHMgfSBmcm9tICcuL2FwaS90eXBlcy9Qcm9wcyc7XG5cbmltcG9ydCB7IGNvbnN0YW50cyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmNvbnN0IHsgb2RwIH0gPSBjb25zdGFudHM7XG5cbmltcG9ydCAqIGFzIGVycm9yc0FwaSBmcm9tICcuL2FwaS9lcnJvcnMnO1xuaW1wb3J0IHsgZGVzY3JpcHRvcnMgfSBmcm9tICcuL2Rlc2NyaXB0b3JzJztcblxuaW1wb3J0IG1uZW1vc3luZXMgZnJvbSAnLi9hcGkvdHlwZXMvTW5lbW9zeW5lJztcbmNvbnN0IHsgcHJlcGFyZVN1YnR5cGVGb3JDb25zdHJ1Y3Rpb24gfSA9IG1uZW1vc3luZXM7XG5cbmV4cG9ydCBjb25zdCB7XG5cdGRlZmF1bHRUeXBlcyxcbn0gPSBkZXNjcmlwdG9ycztcblxuZnVuY3Rpb24gY2hlY2tUaGlzKHBvaW50ZXI6IHR5cGVvZiBtbmVtb25pY2EgfCB0eXBlb2YgZXhwb3J0cyB8IHVua25vd24pOiBib29sZWFuIHtcblx0cmV0dXJuIHBvaW50ZXIgPT09IG1uZW1vbmljYSB8fCBwb2ludGVyID09PSBleHBvcnRzO1xufVxuXG5leHBvcnQgY29uc3QgZGVmaW5lID0gZnVuY3Rpb24gPFxuXHRULFxuXHQvLyBLIGV4dGVuZHMgSURFRjxUPixcblx0Ly8gSCBleHRlbmRzIFRoaXNUeXBlPElERUY8VD4+LFxuXHRQIGV4dGVuZHMgb2JqZWN0LFxuXHROIGV4dGVuZHMgUHJvdG88UCwgVD4sXG5cdC8vIHNvIFMgaXQganVzdCBiYXNpY2FsbHkgYWxsb3dzIG5lc3RlZCBjb25zdHJ1Y3RvcnNcblx0Ly8gYW5kIGdpdmVzIGV4dHJhY3RlZCBwcm9wcyBmcm9tIGNvbnN0cnVjdEhhbmRsZXIgJiBwcm90b1xuXHQvLyB0aGVuIGl0IGdvZXMgdG8gbmV3KCkga2V5d29yZCBvZiBkZWZpbmUgb3V0cHV0XG5cdFMgZXh0ZW5kcyBTTiAmIE4sXG5cdFIgZXh0ZW5kcyBJRGVmaW5pdG9ySW5zdGFuY2U8TiwgUz5cbj4oXG5cdHRoaXM6IHVua25vd24sXG5cdFR5cGVOYW1lPzogc3RyaW5nLFxuXHRjb25zdHJ1Y3RIYW5kbGVyPzogSURFRjxUPixcblx0Y29uZmlnPzogY29uc3RydWN0b3JPcHRpb25zLFxuKTogUiB7XG5cdGNvbnN0IHR5cGVzID0gY2hlY2tUaGlzKHRoaXMpID8gZGVmYXVsdFR5cGVzIDogdGhpcyB8fCBkZWZhdWx0VHlwZXM7XG5cdHJldHVybiB0eXBlcy5kZWZpbmUoVHlwZU5hbWUsIGNvbnN0cnVjdEhhbmRsZXIsIGNvbmZpZyk7XG59O1xuXG5leHBvcnQgY29uc3QgbG9va3VwID0gZnVuY3Rpb24gKFR5cGVOZXN0ZWRQYXRoKSB7XG5cdGNvbnN0IHR5cGVzID0gY2hlY2tUaGlzKHRoaXMpID8gZGVmYXVsdFR5cGVzIDogdGhpcyB8fCBkZWZhdWx0VHlwZXM7XG5cdHJldHVybiB0eXBlcy5sb29rdXAoVHlwZU5lc3RlZFBhdGgpO1xufSBhcyBUeXBlTG9va3VwO1xuXG5cbmNvbnN0ICRydW4gPSBmdW5jdGlvbiA8RSBleHRlbmRzIG9iamVjdCwgVCBleHRlbmRzIG9iamVjdCwgUyBleHRlbmRzIFByb3RvPEUsIFQ+Pihcblx0ZW50aXR5OiBFLFxuXHRDb25zdHJ1Y3RvcjogSURFRjxUPixcblx0YXJnczogdW5rbm93bltdID0gW11cbik6IHtcblx0XHRba2V5IGluIGtleW9mIFNdOiBTW2tleV1cblx0fSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kZWJ1Z2dlclxuXHQvLyBkZWJ1Z2dlcjtcblx0Ly8gQHRzLWlnbm9yZVxuXHRjb25zdCB7IFR5cGVOYW1lIH0gPSBDb25zdHJ1Y3Rvcjtcblx0Y29uc3QgQ3N0ciA9IHByZXBhcmVTdWJ0eXBlRm9yQ29uc3RydWN0aW9uKFR5cGVOYW1lLCBlbnRpdHkpO1xuXHRpZiAoQ3N0ciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgVHlwZSAke1R5cGVOYW1lfSBpcyBub3QgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBjb250ZXh0LmApO1xuXHR9XG5cdGNvbnN0IHJlc3VsdCA9IG5ldyBDc3RyKC4uLmFyZ3MpO1xuXHQvLyBAdHMtaWdub3JlXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBUT0RPOiBhcHBseSBpbnN0YW5jZSAudG8gdHlwZSAud2l0aCBhcmd1bWVudHNcbmV4cG9ydCBjb25zdCBhcHBseSA9IGZ1bmN0aW9uIDxFIGV4dGVuZHMgb2JqZWN0LCBUIGV4dGVuZHMgb2JqZWN0LCBTIGV4dGVuZHMgUHJvdG88RSwgVD4+KFxuXHRlbnRpdHk6IEUsXG5cdENvbnN0cnVjdG9yOiBJREVGPFQ+LFxuXHRhcmdzOiB1bmtub3duW10gPSBbXVxuKToge1xuXHRcdFtrZXkgaW4ga2V5b2YgU106IFNba2V5XVxuXHR9IHtcblx0cmV0dXJuICRydW48RSwgVCwgUz4oZW50aXR5LCBDb25zdHJ1Y3RvciwgYXJncyk7XG59O1xuXG4vLyBUT0RPOiBjYWxsIHR5cGUgLmJ5IGluc3RhbmNlIC53aXRoIGFyZ3VtZW50c1xuZXhwb3J0IGNvbnN0IGNhbGwgPSBmdW5jdGlvbiA8RSBleHRlbmRzIG9iamVjdCwgVCBleHRlbmRzIG9iamVjdCwgUyBleHRlbmRzIFByb3RvPEUsIFQ+Pihcblx0ZW50aXR5OiBFLFxuXHRDb25zdHJ1Y3RvcjogSURFRjxUPixcblx0Li4uYXJnczogdW5rbm93bltdXG4pOiB7XG5cdFx0W2tleSBpbiBrZXlvZiBTXTogU1trZXldXG5cdH0ge1xuXHRyZXR1cm4gJHJ1bjxFLCBULCBTPihlbnRpdHksIENvbnN0cnVjdG9yLCBhcmdzKTtcbn07XG5cbi8vIFRPRE86IGJpbmQgdHlwZSAud2l0aCBpbnN0YW5jZSDihpIgKC4uLmFyZ3MpXG5leHBvcnQgY29uc3QgYmluZCA9IGZ1bmN0aW9uIDxFIGV4dGVuZHMgb2JqZWN0LCBUIGV4dGVuZHMgb2JqZWN0LCBTIGV4dGVuZHMgUHJvdG88RSwgVD4+KFxuXHRlbnRpdHk6IEUsXG5cdENvbnN0cnVjdG9yOiBJREVGPFQ+XG4pOiAoLi4uYXJnczogdW5rbm93bltdKSA9PiB7XG5cdFtrZXkgaW4ga2V5b2YgU106IFNba2V5XVxufSB7XG5cdHJldHVybiAoLi4uYXJncykgPT4ge1xuXHRcdHJldHVybiAkcnVuPEUsIFQsIFM+KGVudGl0eSwgQ29uc3RydWN0b3IsIGFyZ3MpO1xuXHR9O1xufTtcblxuZXhwb3J0IGNvbnN0IGRlY29yYXRlID0gZnVuY3Rpb24gKFxuXHRwYXJlbnRDbGFzczogeyBuZXcoKTogdW5rbm93biB9IHwgY29uc3RydWN0b3JPcHRpb25zIHwgdW5kZWZpbmVkID0ge30sXG5cdGNvbmZpZz86IGNvbnN0cnVjdG9yT3B0aW9uc1xuKSB7XG5cdGlmICh0eXBlb2YgcGFyZW50Q2xhc3MgPT09ICdvYmplY3QnICYmICEocGFyZW50Q2xhc3MgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcblx0XHRjb25maWcgPSBwYXJlbnRDbGFzcyBhcyBjb25zdHJ1Y3Rvck9wdGlvbnM7XG5cdFx0cGFyZW50Q2xhc3MgPSB1bmRlZmluZWQ7XG5cdH1cblx0Y29uc3QgZGVjb3JhdG9yID0gZnVuY3Rpb24gPFQgZXh0ZW5kcyB7IG5ldygpOiB1bmtub3duIH0+KGNzdHI6IFQsIHM6IENsYXNzRGVjb3JhdG9yQ29udGV4dDxUPik6IFQge1xuXHRcdGlmIChwYXJlbnRDbGFzcyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gZGVmaW5lKHMubmFtZSwgY3N0ciwgY29uZmlnKSBhcyB1bmtub3duIGFzIFQ7XG5cdFx0fVxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gcGFyZW50Q2xhc3MuZGVmaW5lKHMubmFtZSwgY3N0ciwgY29uZmlnKSBhcyB1bmtub3duIGFzIFQ7XG5cdH07XG5cdHJldHVybiBkZWNvcmF0b3I7XG59O1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJIb29rID0gZnVuY3Rpb24gPFQgZXh0ZW5kcyBvYmplY3Q+KENvbnN0cnVjdG9yOiBJREVGPFQ+LCBob29rVHlwZTogaG9va3NUeXBlcywgY2I6IGhvb2spOiB2b2lkIHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRDb25zdHJ1Y3Rvci5yZWdpc3Rlckhvb2soaG9va1R5cGUsIGNiKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtbmVtb25pY2EgPSBPYmplY3QuZW50cmllcyh7XG5cblx0ZGVmaW5lLFxuXHRsb29rdXAsXG5cdGFwcGx5LFxuXHRjYWxsLFxuXHRiaW5kLFxuXHRkZWNvcmF0ZSxcblx0cmVnaXN0ZXJIb29rLFxuXG5cdC4uLmRlc2NyaXB0b3JzLFxuXG5cdC4uLmVycm9yc0FwaSxcblx0Li4uY29uc3RhbnRzLFxuXG59KS5yZWR1Y2UoKGFjYzogeyBbaW5kZXg6IHN0cmluZ106IHVua25vd24gfSwgZW50cnk6IFtzdHJpbmcsIHVua25vd25dKSA9PiB7XG5cdGNvbnN0IFsgbmFtZSwgY29kZSBdID0gZW50cnk7XG5cdG9kcChhY2MsIG5hbWUsIHtcblx0XHRnZXQoKSB7XG5cdFx0XHRyZXR1cm4gY29kZTtcblx0XHR9LFxuXHRcdGVudW1lcmFibGUgOiB0cnVlXG5cdH0pO1xuXHRyZXR1cm4gYWNjO1xufSwge30pO1xuXG5leHBvcnQgY29uc3Qge1xuXG5cdFN5bWJvbFBhcmVudFR5cGUsXG5cdFN5bWJvbENvbnN0cnVjdG9yTmFtZSxcblx0U3ltYm9sRGVmYXVsdFR5cGVzQ29sbGVjdGlvbixcblx0U3ltYm9sQ29uZmlnLFxuXHRNTkVNT05JQ0EsXG5cdE1ORU1PU1lORSxcblx0VFlQRV9USVRMRV9QUkVGSVgsXG5cdEVycm9yTWVzc2FnZXMsXG5cdGNyZWF0ZVR5cGVzQ29sbGVjdGlvbixcblxufSA9IG1uZW1vbmljYTtcblxuXG5leHBvcnQgY29uc3QgZGVmYXVsdENvbGxlY3Rpb24gPSBkZWZhdWx0VHlwZXMuc3VidHlwZXM7XG5leHBvcnQgY29uc3QgZXJyb3JzID0gZGVzY3JpcHRvcnMuRXJyb3JzVHlwZXM7XG5cbmV4cG9ydCB7IHV0aWxzIH0gZnJvbSAnLi91dGlscyc7XG5leHBvcnQgeyBkZWZpbmVTdGFja0NsZWFuZXIgfSBmcm9tICcuL3V0aWxzJztcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50LCBpbmRlbnQsIG5ldy1jYXAsIHNwYWNlLWJlZm9yZS1mdW5jdGlvbi1wYXJlbiAqL1xuIl19