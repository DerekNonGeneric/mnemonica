'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineStackCleaner = exports.utils = exports.errors = exports.defaultCollection = exports.createTypesCollection = exports.ErrorMessages = exports.TYPE_TITLE_PREFIX = exports.URANUS = exports.GAIA = exports.MNEMOSYNE = exports.MNEMONICA = exports.SymbolConfig = exports.SymbolDefaultTypesCollection = exports.SymbolReplaceUranus = exports.SymbolGaia = exports.SymbolConstructorName = exports.SymbolParentType = exports.mnemonica = exports.registerHook = exports.decorate = exports.bind = exports.call = exports.apply = exports.lookup = exports.define = exports.defaultTypes = exports.setProps = exports.getProps = void 0;
var Props_1 = require("./api/types/Props");
Object.defineProperty(exports, "getProps", { enumerable: true, get: function () { return Props_1.getProps; } });
Object.defineProperty(exports, "setProps", { enumerable: true, get: function () { return Props_1.setProps; } });
const constants_1 = require("./constants");
const { odp } = constants_1.constants;
const errorsApi = require("./api/errors");
const descriptors_1 = require("./descriptors");
exports.defaultTypes = descriptors_1.descriptors.defaultTypes;
function checkThis(pointer) {
    return pointer === exports.mnemonica || pointer === exports;
}
const define = function (TypeName, constructHandler, config) {
    const types = checkThis(this) ? exports.defaultTypes : this || exports.defaultTypes;
    return types.define(TypeName, constructHandler, config);
};
exports.define = define;
exports.lookup = function (TypeNestedPath) {
    const types = checkThis(this) ? exports.defaultTypes : this || exports.defaultTypes;
    return types.lookup(TypeNestedPath);
};
const apply = function (entity, Constructor, args = []) {
    const result = new entity[Constructor.TypeName](...args);
    return result;
};
exports.apply = apply;
const call = function (entity, Constructor, ...args) {
    const result = new entity[Constructor.TypeName](...args);
    return result;
};
exports.call = call;
const bind = function (entity, Constructor) {
    return (...args) => {
        const result = new entity[Constructor.TypeName](...args);
        return result;
    };
};
exports.bind = bind;
const decorate = function (parentClass = undefined, config) {
    const decorator = function (cstr, s) {
        if (parentClass === undefined) {
            return (0, exports.define)(s.name, cstr, config);
        }
        return parentClass.define(s.name, cstr, config);
    };
    return decorator;
};
exports.decorate = decorate;
const registerHook = function (Constructor, hookType, cb) {
    Constructor.registerHook(hookType, cb);
};
exports.registerHook = registerHook;
exports.mnemonica = Object.entries(Object.assign(Object.assign(Object.assign({ define: exports.define,
    lookup: exports.lookup,
    apply: exports.apply,
    call: exports.call,
    bind: exports.bind,
    decorate: exports.decorate,
    registerHook: exports.registerHook }, descriptors_1.descriptors), errorsApi), constants_1.constants)).reduce((acc, entry) => {
    const [name, code] = entry;
    odp(acc, name, {
        get() {
            return code;
        },
        enumerable: true
    });
    return acc;
}, {});
exports.SymbolParentType = exports.mnemonica.SymbolParentType, exports.SymbolConstructorName = exports.mnemonica.SymbolConstructorName, exports.SymbolGaia = exports.mnemonica.SymbolGaia, exports.SymbolReplaceUranus = exports.mnemonica.SymbolReplaceUranus, exports.SymbolDefaultTypesCollection = exports.mnemonica.SymbolDefaultTypesCollection, exports.SymbolConfig = exports.mnemonica.SymbolConfig, exports.MNEMONICA = exports.mnemonica.MNEMONICA, exports.MNEMOSYNE = exports.mnemonica.MNEMOSYNE, exports.GAIA = exports.mnemonica.GAIA, exports.URANUS = exports.mnemonica.URANUS, exports.TYPE_TITLE_PREFIX = exports.mnemonica.TYPE_TITLE_PREFIX, exports.ErrorMessages = exports.mnemonica.ErrorMessages, exports.createTypesCollection = exports.mnemonica.createTypesCollection;
exports.defaultCollection = exports.defaultTypes.subtypes;
exports.errors = descriptors_1.descriptors.ErrorsTypes;
var utils_1 = require("./utils");
Object.defineProperty(exports, "utils", { enumerable: true, get: function () { return utils_1.utils; } });
var utils_2 = require("./utils");
Object.defineProperty(exports, "defineStackCleaner", { enumerable: true, get: function () { return utils_2.defineStackCleaner; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsWUFBWSxDQUFDOzs7QUFhYiwyQ0FBd0Q7QUFBOUMsaUdBQUEsUUFBUSxPQUFBO0FBQUUsaUdBQUEsUUFBUSxPQUFBO0FBRTVCLDJDQUF3QztBQUN4QyxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcscUJBQVMsQ0FBQztBQUUxQiwwQ0FBMEM7QUFDMUMsK0NBQTRDO0FBRzNDLG9CQUFZLEdBQ1QseUJBQVcsY0FBQztBQUVoQixTQUFTLFNBQVMsQ0FBRyxPQUFvRDtJQUN4RSxPQUFPLE9BQU8sS0FBSyxpQkFBUyxJQUFJLE9BQU8sS0FBSyxPQUFPLENBQUM7QUFDckQsQ0FBQztBQUVNLE1BQU0sTUFBTSxHQUFHLFVBYXJCLFFBQWlCLEVBQ2pCLGdCQUEwQixFQUMxQixNQUEyQjtJQUUzQixNQUFNLEtBQUssR0FBRyxTQUFTLENBQUUsSUFBSSxDQUFFLENBQUMsQ0FBQyxDQUFDLG9CQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxvQkFBWSxDQUFDO0lBQ3RFLE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxDQUFFLENBQUM7QUFDM0QsQ0FBQyxDQUFDO0FBbkJXLFFBQUEsTUFBTSxVQW1CakI7QUFFVyxRQUFBLE1BQU0sR0FBRyxVQUFXLGNBQWM7SUFDOUMsTUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFFLElBQUksQ0FBRSxDQUFDLENBQUMsQ0FBQyxvQkFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksb0JBQVksQ0FBQztJQUN0RSxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUUsY0FBYyxDQUFFLENBQUM7QUFDdkMsQ0FBZSxDQUFDO0FBRVQsTUFBTSxLQUFLLEdBQUcsVUFBdUUsTUFBUyxFQUFFLFdBQW9CLEVBQUUsT0FBa0IsRUFBRTtJQUloSixNQUFNLE1BQU0sR0FB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NkJBQXFCLEdBRWxCLGlCQUFTLHVCQUFDO0FBR0QsUUFBQSxpQkFBaUIsR0FBRyxvQkFBWSxDQUFDLFFBQVEsQ0FBQztBQUMxQyxRQUFBLE1BQU0sR0FBRyx5QkFBVyxDQUFDLFdBQVcsQ0FBQztBQUU5QyxpQ0FBZ0M7QUFBdkIsOEZBQUEsS0FBSyxPQUFBO0FBQ2QsaUNBQTZDO0FBQXBDLDJHQUFBLGtCQUFrQixPQUFBIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50LCBpbmRlbnQsIG5ldy1jYXAsIHNwYWNlLWJlZm9yZS1mdW5jdGlvbi1wYXJlbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1xuXHRUeXBlTG9va3VwLFxuXHRJREVGLFxuXHRob29rLFxuXHRob29rc1R5cGVzLFxuXHRjb25zdHJ1Y3Rvck9wdGlvbnMsXG5cdFByb3RvLFxuXHRTTixcblx0SURlZmluaXRvckluc3RhbmNlXG59IGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IHR5cGUgeyBJREVGLCBDb25zdHJ1Y3RvckZ1bmN0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgeyAgZ2V0UHJvcHMsIHNldFByb3BzIH0gZnJvbSAnLi9hcGkvdHlwZXMvUHJvcHMnO1xuXG5pbXBvcnQgeyBjb25zdGFudHMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5jb25zdCB7IG9kcCB9ID0gY29uc3RhbnRzO1xuXG5pbXBvcnQgKiBhcyBlcnJvcnNBcGkgZnJvbSAnLi9hcGkvZXJyb3JzJztcbmltcG9ydCB7IGRlc2NyaXB0b3JzIH0gZnJvbSAnLi9kZXNjcmlwdG9ycyc7XG5cbmV4cG9ydCBjb25zdCB7XG5cdGRlZmF1bHRUeXBlcyxcbn0gPSBkZXNjcmlwdG9ycztcblxuZnVuY3Rpb24gY2hlY2tUaGlzICggcG9pbnRlcjogdHlwZW9mIG1uZW1vbmljYSB8IHR5cGVvZiBleHBvcnRzIHwgdW5rbm93biApOiBib29sZWFuIHtcblx0cmV0dXJuIHBvaW50ZXIgPT09IG1uZW1vbmljYSB8fCBwb2ludGVyID09PSBleHBvcnRzO1xufVxuXG5leHBvcnQgY29uc3QgZGVmaW5lID0gZnVuY3Rpb24gPFxuXHRULFxuXHQvLyBLIGV4dGVuZHMgSURFRjxUPixcblx0Ly8gSCBleHRlbmRzIFRoaXNUeXBlPElERUY8VD4+LFxuXHRQIGV4dGVuZHMgb2JqZWN0LFxuXHROIGV4dGVuZHMgUHJvdG88UCwgVD4sXG5cdC8vIHNvIFMgaXQganVzdCBiYXNpY2FsbHkgYWxsb3dzIG5lc3RlZCBjb25zdHJ1Y3RvcnNcblx0Ly8gYW5kIGdpdmVzIGV4dHJhY3RlZCBwcm9wcyBmcm9tIGNvbnN0cnVjdEhhbmRsZXIgJiBwcm90b1xuXHQvLyB0aGVuIGl0IGdvZXMgdG8gbmV3KCkga2V5d29yZCBvZiBkZWZpbmUgb3V0cHV0XG5cdFMgZXh0ZW5kcyBTTiAmIE4sXG5cdFIgZXh0ZW5kcyBJRGVmaW5pdG9ySW5zdGFuY2U8TiwgUz5cbj4gKFxuXHR0aGlzOiB1bmtub3duLFxuXHRUeXBlTmFtZT86IHN0cmluZyxcblx0Y29uc3RydWN0SGFuZGxlcj86IElERUY8VD4sXG5cdGNvbmZpZz86IGNvbnN0cnVjdG9yT3B0aW9ucyxcbik6IFIge1xuXHRjb25zdCB0eXBlcyA9IGNoZWNrVGhpcyggdGhpcyApID8gZGVmYXVsdFR5cGVzIDogdGhpcyB8fCBkZWZhdWx0VHlwZXM7XG5cdHJldHVybiB0eXBlcy5kZWZpbmUoIFR5cGVOYW1lLCBjb25zdHJ1Y3RIYW5kbGVyLCBjb25maWcgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBsb29rdXAgPSBmdW5jdGlvbiAoIFR5cGVOZXN0ZWRQYXRoICkge1xuXHRjb25zdCB0eXBlcyA9IGNoZWNrVGhpcyggdGhpcyApID8gZGVmYXVsdFR5cGVzIDogdGhpcyB8fCBkZWZhdWx0VHlwZXM7XG5cdHJldHVybiB0eXBlcy5sb29rdXAoIFR5cGVOZXN0ZWRQYXRoICk7XG59IGFzIFR5cGVMb29rdXA7XG5cbmV4cG9ydCBjb25zdCBhcHBseSA9IGZ1bmN0aW9uIDxFIGV4dGVuZHMgb2JqZWN0LCBUIGV4dGVuZHMgb2JqZWN0LCBTIGV4dGVuZHMgUHJvdG88RSwgVD4+ICggZW50aXR5OiBFLCBDb25zdHJ1Y3RvcjogSURFRjxUPiwgYXJnczogdW5rbm93bltdID0gW10gKToge1xuXHRbIGtleSBpbiBrZXlvZiBTIF06IFNbIGtleSBdXG59IHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRjb25zdCByZXN1bHQgPSBuZXcgZW50aXR5WyBDb25zdHJ1Y3Rvci5UeXBlTmFtZSBdKCAuLi5hcmdzICk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgY29uc3QgY2FsbCA9IGZ1bmN0aW9uIDxFIGV4dGVuZHMgb2JqZWN0LCBUIGV4dGVuZHMgb2JqZWN0LCBTIGV4dGVuZHMgUHJvdG88RSwgVD4+ICggZW50aXR5OiBFLCBDb25zdHJ1Y3RvcjogSURFRjxUPiwgLi4uYXJnczogdW5rbm93bltdICk6IHtcblx0WyBrZXkgaW4ga2V5b2YgUyBdOiBTWyBrZXkgXVxufSB7XG5cdC8vIEB0cy1pZ25vcmVcblx0Y29uc3QgcmVzdWx0ID0gbmV3IGVudGl0eVsgQ29uc3RydWN0b3IuVHlwZU5hbWUgXSggLi4uYXJncyApO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGNvbnN0IGJpbmQgPSBmdW5jdGlvbiA8RSBleHRlbmRzIG9iamVjdCwgVCBleHRlbmRzIG9iamVjdCwgUyBleHRlbmRzIFByb3RvPEUsIFQ+PiAoIGVudGl0eTogRSwgQ29uc3RydWN0b3I6IElERUY8VD4gKTogKCAuLi5hcmdzOiB1bmtub3duW10gKSA9PiB7XG5cdFsga2V5IGluIGtleW9mIFMgXTogU1sga2V5IF1cbn0ge1xuXHRyZXR1cm4gKCAuLi5hcmdzICkgPT4ge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRjb25zdCByZXN1bHQgPSBuZXcgZW50aXR5WyBDb25zdHJ1Y3Rvci5UeXBlTmFtZSBdKCAuLi5hcmdzICk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWNvcmF0ZSA9IGZ1bmN0aW9uICggcGFyZW50Q2xhc3M6IHVua25vd24gPSB1bmRlZmluZWQsIGNvbmZpZz86IGNvbnN0cnVjdG9yT3B0aW9ucyApIHtcblx0Y29uc3QgZGVjb3JhdG9yID0gZnVuY3Rpb24gPFQgZXh0ZW5kcyB7IG5ldygpOiB1bmtub3duIH0+ICggY3N0cjogVCwgczogQ2xhc3NEZWNvcmF0b3JDb250ZXh0PFQ+ICk6IFQge1xuXHRcdGlmICggcGFyZW50Q2xhc3MgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBkZWZpbmUoIHMubmFtZSwgY3N0ciwgY29uZmlnICkgYXMgdW5rbm93biBhcyBUIDtcblx0XHR9XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBwYXJlbnRDbGFzcy5kZWZpbmUoIHMubmFtZSwgY3N0ciwgY29uZmlnICkgYXMgdW5rbm93biBhcyBUO1xuXHR9O1xuXHRyZXR1cm4gZGVjb3JhdG9yO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVySG9vayA9IGZ1bmN0aW9uIDxUIGV4dGVuZHMgb2JqZWN0PiAoIENvbnN0cnVjdG9yOiBJREVGPFQ+LCBob29rVHlwZTogaG9va3NUeXBlcywgY2I6IGhvb2sgKTogdm9pZCB7XG5cdC8vIEB0cy1pZ25vcmVcblx0Q29uc3RydWN0b3IucmVnaXN0ZXJIb29rKCBob29rVHlwZSwgY2IgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtbmVtb25pY2EgPSBPYmplY3QuZW50cmllcygge1xuXG5cdGRlZmluZSxcblx0bG9va3VwLFxuXHRhcHBseSxcblx0Y2FsbCxcblx0YmluZCxcblx0ZGVjb3JhdGUsXG5cdHJlZ2lzdGVySG9vayxcblxuXHQuLi5kZXNjcmlwdG9ycyxcblxuXHQuLi5lcnJvcnNBcGksXG5cdC4uLmNvbnN0YW50cyxcblxufSApLnJlZHVjZSggKCBhY2M6IHsgWyBpbmRleDogc3RyaW5nIF06IHVua25vd24gfSwgZW50cnk6IFsgc3RyaW5nLCB1bmtub3duIF0gKSA9PiB7XG5cdGNvbnN0IFsgbmFtZSwgY29kZSBdID0gZW50cnk7XG5cdG9kcCggYWNjLCBuYW1lLCB7XG5cdFx0Z2V0ICgpIHtcblx0XHRcdHJldHVybiBjb2RlO1xuXHRcdH0sXG5cdFx0ZW51bWVyYWJsZSA6IHRydWVcblx0fSApO1xuXHRyZXR1cm4gYWNjO1xufSwge30gKTtcblxuZXhwb3J0IGNvbnN0IHtcblxuXHRTeW1ib2xQYXJlbnRUeXBlLFxuXHRTeW1ib2xDb25zdHJ1Y3Rvck5hbWUsXG5cdFN5bWJvbEdhaWEsXG5cdFN5bWJvbFJlcGxhY2VVcmFudXMsXG5cdFN5bWJvbERlZmF1bHRUeXBlc0NvbGxlY3Rpb24sXG5cdFN5bWJvbENvbmZpZyxcblx0TU5FTU9OSUNBLFxuXHRNTkVNT1NZTkUsXG5cdEdBSUEsXG5cdFVSQU5VUyxcblx0VFlQRV9USVRMRV9QUkVGSVgsXG5cdEVycm9yTWVzc2FnZXMsXG5cdGNyZWF0ZVR5cGVzQ29sbGVjdGlvbixcblxufSA9IG1uZW1vbmljYTtcblxuXG5leHBvcnQgY29uc3QgZGVmYXVsdENvbGxlY3Rpb24gPSBkZWZhdWx0VHlwZXMuc3VidHlwZXM7XG5leHBvcnQgY29uc3QgZXJyb3JzID0gZGVzY3JpcHRvcnMuRXJyb3JzVHlwZXM7XG5cbmV4cG9ydCB7IHV0aWxzIH0gZnJvbSAnLi91dGlscyc7XG5leHBvcnQgeyBkZWZpbmVTdGFja0NsZWFuZXIgfSBmcm9tICcuL3V0aWxzJztcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50LCBpbmRlbnQsIG5ldy1jYXAsIHNwYWNlLWJlZm9yZS1mdW5jdGlvbi1wYXJlbiAqL1xuIl19