'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineStackCleaner = exports.utils = exports.errors = exports.defaultCollection = exports.createTypesCollection = exports.ErrorMessages = exports.TYPE_TITLE_PREFIX = exports.MNEMOSYNE = exports.MNEMONICA = exports.SymbolConfig = exports.SymbolDefaultTypesCollection = exports.SymbolConstructorName = exports.SymbolParentType = exports.mnemonica = exports.registerHook = exports.decorate = exports.bind = exports.call = exports.apply = exports.lookup = exports.define = exports.defaultTypes = exports.setProps = exports.getProps = void 0;
var Props_1 = require("./api/types/Props");
Object.defineProperty(exports, "getProps", { enumerable: true, get: function () { return Props_1.getProps; } });
Object.defineProperty(exports, "setProps", { enumerable: true, get: function () { return Props_1.setProps; } });
const constants_1 = require("./constants");
const { odp } = constants_1.constants;
const errorsApi = require("./api/errors");
const descriptors_1 = require("./descriptors");
const Mnemosyne_1 = require("./api/types/Mnemosyne");
const { prepareSubtypeForConstruction } = Mnemosyne_1.default;
exports.defaultTypes = descriptors_1.descriptors.defaultTypes;
function checkThis(pointer) {
    return pointer === exports.mnemonica || pointer === exports;
}
const define = function (TypeName, constructHandler, config) {
    const types = checkThis(this) ? exports.defaultTypes : this || exports.defaultTypes;
    return types.define(TypeName, constructHandler, config);
};
exports.define = define;
exports.lookup = function (TypeNestedPath) {
    const types = checkThis(this) ? exports.defaultTypes : this || exports.defaultTypes;
    return types.lookup(TypeNestedPath);
};
const $run = function (entity, Constructor, args) {
    const { TypeName } = Constructor;
    const Cstr = prepareSubtypeForConstruction(TypeName, entity);
    const result = new Cstr(...args);
    return result;
};
const apply = function (entity, Constructor, args = []) {
    return $run(entity, Constructor, args);
};
exports.apply = apply;
const call = function (entity, Constructor, ...args) {
    return $run(entity, Constructor, args);
};
exports.call = call;
const bind = function (entity, Constructor) {
    return (...args) => {
        return $run(entity, Constructor, args);
    };
};
exports.bind = bind;
const decorate = function (parentClass, config) {
    if (config === undefined && typeof parentClass === 'object' && !(parentClass instanceof Function)) {
        config = parentClass;
        parentClass = undefined;
    }
    const decorator = function (cstr, s) {
        if (parentClass === undefined) {
            return (0, exports.define)(s.name, cstr, config);
        }
        return parentClass.define(s.name, cstr, config);
    };
    return decorator;
};
exports.decorate = decorate;
const registerHook = function (Constructor, hookType, cb) {
    Constructor.registerHook(hookType, cb);
};
exports.registerHook = registerHook;
exports.mnemonica = Object.entries(Object.assign(Object.assign(Object.assign({ define: exports.define,
    lookup: exports.lookup,
    apply: exports.apply,
    call: exports.call,
    bind: exports.bind,
    decorate: exports.decorate,
    registerHook: exports.registerHook }, descriptors_1.descriptors), errorsApi), constants_1.constants)).reduce((acc, entry) => {
    const [name, code] = entry;
    odp(acc, name, {
        get() {
            return code;
        },
        enumerable: true
    });
    return acc;
}, {});
exports.SymbolParentType = exports.mnemonica.SymbolParentType, exports.SymbolConstructorName = exports.mnemonica.SymbolConstructorName, exports.SymbolDefaultTypesCollection = exports.mnemonica.SymbolDefaultTypesCollection, exports.SymbolConfig = exports.mnemonica.SymbolConfig, exports.MNEMONICA = exports.mnemonica.MNEMONICA, exports.MNEMOSYNE = exports.mnemonica.MNEMOSYNE, exports.TYPE_TITLE_PREFIX = exports.mnemonica.TYPE_TITLE_PREFIX, exports.ErrorMessages = exports.mnemonica.ErrorMessages, exports.createTypesCollection = exports.mnemonica.createTypesCollection;
exports.defaultCollection = exports.defaultTypes.subtypes;
exports.errors = descriptors_1.descriptors.ErrorsTypes;
var utils_1 = require("./utils");
Object.defineProperty(exports, "utils", { enumerable: true, get: function () { return utils_1.utils; } });
var utils_2 = require("./utils");
Object.defineProperty(exports, "defineStackCleaner", { enumerable: true, get: function () { return utils_2.defineStackCleaner; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsWUFBWSxDQUFDOzs7QUFhYiwyQ0FBdUQ7QUFBOUMsaUdBQUEsUUFBUSxPQUFBO0FBQUUsaUdBQUEsUUFBUSxPQUFBO0FBRTNCLDJDQUF3QztBQUN4QyxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcscUJBQVMsQ0FBQztBQUUxQiwwQ0FBMEM7QUFDMUMsK0NBQTRDO0FBRTVDLHFEQUErQztBQUMvQyxNQUFNLEVBQUUsNkJBQTZCLEVBQUUsR0FBRyxtQkFBVSxDQUFDO0FBR3BELG9CQUFZLEdBQ1QseUJBQVcsY0FBQztBQUVoQixTQUFTLFNBQVMsQ0FBQyxPQUFvRDtJQUN0RSxPQUFPLE9BQU8sS0FBSyxpQkFBUyxJQUFJLE9BQU8sS0FBSyxPQUFPLENBQUM7QUFDckQsQ0FBQztBQUVNLE1BQU0sTUFBTSxHQUFHLFVBYXJCLFFBQWlCLEVBQ2pCLGdCQUEwQixFQUMxQixNQUEyQjtJQUUzQixNQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLG9CQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxvQkFBWSxDQUFDO0lBQ3BFLE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDekQsQ0FBQyxDQUFDO0FBbkJXLFFBQUEsTUFBTSxVQW1CakI7QUFFVyxRQUFBLE1BQU0sR0FBRyxVQUFVLGNBQWM7SUFDN0MsTUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxvQkFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksb0JBQVksQ0FBQztJQUNwRSxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDckMsQ0FBZSxDQUFDO0FBR2hCLE1BQU0sSUFBSSxHQUFH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T0FBTyxHQUFHLENBQUM7QUFDWixDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFJTix3QkFBZ0IsR0FVYixpQkFBUyxtQkFUWiw2QkFBcUIsR0FTbEIsaUJBQVMsd0JBUlosb0NBQTRCLEdBUXpCLGlCQUFTLCtCQVBaLG9CQUFZLEdBT1QsaUJBQVMsZUFOWixpQkFBUyxHQU1OLGlCQUFTLFlBTFosaUJBQVMsR0FLTixpQkFBUyxZQUpaLHlCQUFpQixHQUlkLGlCQUFTLG9CQUhaLHFCQUFhLEdBR1YsaUJBQVMsZ0JBRlosNkJBQXFCLEdBRWxCLGlCQUFTLHVCQUFDO0FBR0QsUUFBQSxpQkFBaUIsR0FBRyxvQkFBWSxDQUFDLFFBQVEsQ0FBQztBQUMxQyxRQUFBLE1BQU0sR0FBRyx5QkFBVyxDQUFDLFdBQVcsQ0FBQztBQUU5QyxpQ0FBZ0M7QUFBdkIsOEZBQUEsS0FBSyxPQUFBO0FBQ2QsaUNBQTZDO0FBQXBDLDJHQUFBLGtCQUFrQixPQUFBIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50LCBzcGFjZS1iZWZvcmUtZnVuY3Rpb24tcGFyZW4gKi9cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtcblx0VHlwZUxvb2t1cCxcblx0SURFRixcblx0aG9vayxcblx0aG9va3NUeXBlcyxcblx0Y29uc3RydWN0b3JPcHRpb25zLFxuXHRQcm90byxcblx0U04sXG5cdElEZWZpbml0b3JJbnN0YW5jZVxufSBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCB0eXBlIHsgSURFRiwgQ29uc3RydWN0b3JGdW5jdGlvbiB9IGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IHsgZ2V0UHJvcHMsIHNldFByb3BzIH0gZnJvbSAnLi9hcGkvdHlwZXMvUHJvcHMnO1xuXG5pbXBvcnQgeyBjb25zdGFudHMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5jb25zdCB7IG9kcCB9ID0gY29uc3RhbnRzO1xuXG5pbXBvcnQgKiBhcyBlcnJvcnNBcGkgZnJvbSAnLi9hcGkvZXJyb3JzJztcbmltcG9ydCB7IGRlc2NyaXB0b3JzIH0gZnJvbSAnLi9kZXNjcmlwdG9ycyc7XG5cbmltcG9ydCBtbmVtb3N5bmVzIGZyb20gJy4vYXBpL3R5cGVzL01uZW1vc3luZSc7XG5jb25zdCB7IHByZXBhcmVTdWJ0eXBlRm9yQ29uc3RydWN0aW9uIH0gPSBtbmVtb3N5bmVzO1xuXG5leHBvcnQgY29uc3Qge1xuXHRkZWZhdWx0VHlwZXMsXG59ID0gZGVzY3JpcHRvcnM7XG5cbmZ1bmN0aW9uIGNoZWNrVGhpcyhwb2ludGVyOiB0eXBlb2YgbW5lbW9uaWNhIHwgdHlwZW9mIGV4cG9ydHMgfCB1bmtub3duKTogYm9vbGVhbiB7XG5cdHJldHVybiBwb2ludGVyID09PSBtbmVtb25pY2EgfHwgcG9pbnRlciA9PT0gZXhwb3J0cztcbn1cblxuZXhwb3J0IGNvbnN0IGRlZmluZSA9IGZ1bmN0aW9uIDxcblx0VCxcblx0Ly8gSyBleHRlbmRzIElERUY8VD4sXG5cdC8vIEggZXh0ZW5kcyBUaGlzVHlwZTxJREVGPFQ+Pixcblx0UCBleHRlbmRzIG9iamVjdCxcblx0TiBleHRlbmRzIFByb3RvPFAsIFQ+LFxuXHQvLyBzbyBTIGl0IGp1c3QgYmFzaWNhbGx5IGFsbG93cyBuZXN0ZWQgY29uc3RydWN0b3JzXG5cdC8vIGFuZCBnaXZlcyBleHRyYWN0ZWQgcHJvcHMgZnJvbSBjb25zdHJ1Y3RIYW5kbGVyICYgcHJvdG9cblx0Ly8gdGhlbiBpdCBnb2VzIHRvIG5ldygpIGtleXdvcmQgb2YgZGVmaW5lIG91dHB1dFxuXHRTIGV4dGVuZHMgU04gJiBOLFxuXHRSIGV4dGVuZHMgSURlZmluaXRvckluc3RhbmNlPE4sIFM+XG4+KFxuXHR0aGlzOiB1bmtub3duLFxuXHRUeXBlTmFtZT86IHN0cmluZyxcblx0Y29uc3RydWN0SGFuZGxlcj86IElERUY8VD4sXG5cdGNvbmZpZz86IGNvbnN0cnVjdG9yT3B0aW9ucyxcbik6IFIge1xuXHRjb25zdCB0eXBlcyA9IGNoZWNrVGhpcyh0aGlzKSA/IGRlZmF1bHRUeXBlcyA6IHRoaXMgfHwgZGVmYXVsdFR5cGVzO1xuXHRyZXR1cm4gdHlwZXMuZGVmaW5lKFR5cGVOYW1lLCBjb25zdHJ1Y3RIYW5kbGVyLCBjb25maWcpO1xufTtcblxuZXhwb3J0IGNvbnN0IGxvb2t1cCA9IGZ1bmN0aW9uIChUeXBlTmVzdGVkUGF0aCkge1xuXHRjb25zdCB0eXBlcyA9IGNoZWNrVGhpcyh0aGlzKSA/IGRlZmF1bHRUeXBlcyA6IHRoaXMgfHwgZGVmYXVsdFR5cGVzO1xuXHRyZXR1cm4gdHlwZXMubG9va3VwKFR5cGVOZXN0ZWRQYXRoKTtcbn0gYXMgVHlwZUxvb2t1cDtcblxuXG5jb25zdCAkcnVuID0gZnVuY3Rpb24gPEUgZXh0ZW5kcyBvYmplY3QsIFQgZXh0ZW5kcyBvYmplY3QsIFMgZXh0ZW5kcyBQcm90bzxFLCBUPj4oXG5cdGVudGl0eTogRSxcblx0Q29uc3RydWN0b3I6IElERUY8VD4sXG5cdGFyZ3M6IHVua25vd25bXVxuKToge1xuXHRcdFtrZXkgaW4ga2V5b2YgU106IFNba2V5XVxuXHR9IHtcblx0IFxuXHQvLyBkZWJ1Z2dlcjtcblx0Ly8gQHRzLWlnbm9yZVxuXHRjb25zdCB7IFR5cGVOYW1lIH0gPSBDb25zdHJ1Y3Rvcjtcblx0Y29uc3QgQ3N0ciA9IHByZXBhcmVTdWJ0eXBlRm9yQ29uc3RydWN0aW9uKFR5cGVOYW1lLCBlbnRpdHkpIGFzIHsgbmV3KCAuLi5hcnM6IHVua25vd25bXSk6IHVua25vd259O1xuXHQvLyBUT0RPOiBjaGVjayBsaW5lcyBiZWxvdyBhbmQgaWYgQ29uc3RydWN0b3IgaXMgbm90IG1uZW1vbml6ZWQgLi4uXG5cdC8vIGlmIChDc3RyID09PSB1bmRlZmluZWQpIHtcblx0Ly8gXHR0aHJvdyBuZXcgVHlwZUVycm9yKGBUeXBlICR7VHlwZU5hbWV9IGlzIG5vdCBkZWZpbmVkIGFzIGEgLmApO1xuXHQvLyB9XG5cdGNvbnN0IHJlc3VsdCA9IG5ldyBDc3RyKC4uLmFyZ3MpO1xuXHQvLyBAdHMtaWdub3JlXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBUT0RPOiBhcHBseSBpbnN0YW5jZSAudG8gdHlwZSAud2l0aCBhcmd1bWVudHNcbmV4cG9ydCBjb25zdCBhcHBseSA9IGZ1bmN0aW9uIDxFIGV4dGVuZHMgb2JqZWN0LCBUIGV4dGVuZHMgb2JqZWN0LCBTIGV4dGVuZHMgUHJvdG88RSwgVD4+KFxuXHRlbnRpdHk6IEUsXG5cdENvbnN0cnVjdG9yOiBJREVGPFQ+LFxuXHRhcmdzOiB1bmtub3duW10gPSBbXVxuKToge1xuXHRcdFtrZXkgaW4ga2V5b2YgU106IFNba2V5XVxuXHR9IHtcblx0cmV0dXJuICRydW48RSwgVCwgUz4oZW50aXR5LCBDb25zdHJ1Y3RvciwgYXJncyk7XG59O1xuXG4vLyBUT0RPOiBjYWxsIHR5cGUgLmJ5IGluc3RhbmNlIC53aXRoIGFyZ3VtZW50c1xuZXhwb3J0IGNvbnN0IGNhbGwgPSBmdW5jdGlvbiA8RSBleHRlbmRzIG9iamVjdCwgVCBleHRlbmRzIG9iamVjdCwgUyBleHRlbmRzIFByb3RvPEUsIFQ+Pihcblx0ZW50aXR5OiBFLFxuXHRDb25zdHJ1Y3RvcjogSURFRjxUPixcblx0Li4uYXJnczogdW5rbm93bltdXG4pOiB7XG5cdFx0W2tleSBpbiBrZXlvZiBTXTogU1trZXldXG5cdH0ge1xuXHRyZXR1cm4gJHJ1bjxFLCBULCBTPihlbnRpdHksIENvbnN0cnVjdG9yLCBhcmdzKTtcbn07XG5cbi8vIFRPRE86IGJpbmQgdHlwZSAud2l0aCBpbnN0YW5jZSDihpIgKC4uLmFyZ3MpXG5leHBvcnQgY29uc3QgYmluZCA9IGZ1bmN0aW9uIDxFIGV4dGVuZHMgb2JqZWN0LCBUIGV4dGVuZHMgb2JqZWN0LCBTIGV4dGVuZHMgUHJvdG88RSwgVD4+KFxuXHRlbnRpdHk6IEUsXG5cdENvbnN0cnVjdG9yOiBJREVGPFQ+XG4pOiAoLi4uYXJnczogdW5rbm93bltdKSA9PiB7XG5cdFtrZXkgaW4ga2V5b2YgU106IFNba2V5XVxufSB7XG5cdHJldHVybiAoLi4uYXJncykgPT4ge1xuXHRcdHJldHVybiAkcnVuPEUsIFQsIFM+KGVudGl0eSwgQ29uc3RydWN0b3IsIGFyZ3MpO1xuXHR9O1xufTtcblxuZXhwb3J0IGNvbnN0IGRlY29yYXRlID0gZnVuY3Rpb24gKFxuXHRwYXJlbnRDbGFzcz86IHsgbmV3KCk6IHVua25vd24gfSB8IGNvbnN0cnVjdG9yT3B0aW9ucyB8IHVuZGVmaW5lZCxcblx0Y29uZmlnPzogY29uc3RydWN0b3JPcHRpb25zXG4pIHtcblx0aWYgKGNvbmZpZyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwYXJlbnRDbGFzcyA9PT0gJ29iamVjdCcgJiYgIShwYXJlbnRDbGFzcyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuXHRcdGNvbmZpZyA9IHBhcmVudENsYXNzIGFzIGNvbnN0cnVjdG9yT3B0aW9ucztcblx0XHRwYXJlbnRDbGFzcyA9IHVuZGVmaW5lZDtcblx0fVxuXHRjb25zdCBkZWNvcmF0b3IgPSBmdW5jdGlvbiA8VCBleHRlbmRzIHsgbmV3KCk6IHVua25vd24gfT4oY3N0cjogVCwgczogQ2xhc3NEZWNvcmF0b3JDb250ZXh0PFQ+KTogVCB7XG5cdFx0aWYgKHBhcmVudENsYXNzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBkZWZpbmUocy5uYW1lLCBjc3RyLCBjb25maWcpIGFzIHVua25vd24gYXMgVDtcblx0XHR9XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBwYXJlbnRDbGFzcy5kZWZpbmUocy5uYW1lLCBjc3RyLCBjb25maWcpIGFzIHVua25vd24gYXMgVDtcblx0fTtcblx0cmV0dXJuIGRlY29yYXRvcjtcbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3Rlckhvb2sgPSBmdW5jdGlvbiA8VCBleHRlbmRzIG9iamVjdD4oQ29uc3RydWN0b3I6IElERUY8VD4sIGhvb2tUeXBlOiBob29rc1R5cGVzLCBjYjogaG9vayk6IHZvaWQge1xuXHQvLyBAdHMtaWdub3JlXG5cdENvbnN0cnVjdG9yLnJlZ2lzdGVySG9vayhob29rVHlwZSwgY2IpO1xufTtcblxuZXhwb3J0IGNvbnN0IG1uZW1vbmljYSA9IE9iamVjdC5lbnRyaWVzKHtcblxuXHRkZWZpbmUsXG5cdGxvb2t1cCxcblx0YXBwbHksXG5cdGNhbGwsXG5cdGJpbmQsXG5cdGRlY29yYXRlLFxuXHRyZWdpc3Rlckhvb2ssXG5cblx0Li4uZGVzY3JpcHRvcnMsXG5cblx0Li4uZXJyb3JzQXBpLFxuXHQuLi5jb25zdGFudHMsXG5cbn0pLnJlZHVjZSgoYWNjOiB7IFtpbmRleDogc3RyaW5nXTogdW5rbm93biB9LCBlbnRyeTogW3N0cmluZywgdW5rbm93bl0pID0+IHtcblx0Y29uc3QgWyBuYW1lLCBjb2RlIF0gPSBlbnRyeTtcblx0b2RwKGFjYywgbmFtZSwge1xuXHRcdGdldCgpIHtcblx0XHRcdHJldHVybiBjb2RlO1xuXHRcdH0sXG5cdFx0ZW51bWVyYWJsZSA6IHRydWVcblx0fSk7XG5cdHJldHVybiBhY2M7XG59LCB7fSk7XG5cbmV4cG9ydCBjb25zdCB7XG5cblx0U3ltYm9sUGFyZW50VHlwZSxcblx0U3ltYm9sQ29uc3RydWN0b3JOYW1lLFxuXHRTeW1ib2xEZWZhdWx0VHlwZXNDb2xsZWN0aW9uLFxuXHRTeW1ib2xDb25maWcsXG5cdE1ORU1PTklDQSxcblx0TU5FTU9TWU5FLFxuXHRUWVBFX1RJVExFX1BSRUZJWCxcblx0RXJyb3JNZXNzYWdlcyxcblx0Y3JlYXRlVHlwZXNDb2xsZWN0aW9uLFxuXG59ID0gbW5lbW9uaWNhO1xuXG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0Q29sbGVjdGlvbiA9IGRlZmF1bHRUeXBlcy5zdWJ0eXBlcztcbmV4cG9ydCBjb25zdCBlcnJvcnMgPSBkZXNjcmlwdG9ycy5FcnJvcnNUeXBlcztcblxuZXhwb3J0IHsgdXRpbHMgfSBmcm9tICcuL3V0aWxzJztcbmV4cG9ydCB7IGRlZmluZVN0YWNrQ2xlYW5lciB9IGZyb20gJy4vdXRpbHMnO1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQsIHNwYWNlLWJlZm9yZS1mdW5jdGlvbi1wYXJlbiAqL1xuIl19