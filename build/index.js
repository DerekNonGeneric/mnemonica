'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineStackCleaner = exports.utils = exports.errors = exports.defaultCollection = exports.createTypesCollection = exports.ErrorMessages = exports.TYPE_TITLE_PREFIX = exports.MNEMOSYNE = exports.MNEMONICA = exports.SymbolConfig = exports.SymbolDefaultTypesCollection = exports.SymbolConstructorName = exports.SymbolParentType = exports.mnemonica = exports.registerHook = exports.decorate = exports.bind = exports.call = exports.apply = exports.lookup = exports.define = exports.defaultTypes = exports.setProps = exports.getProps = void 0;
var Props_1 = require("./api/types/Props");
Object.defineProperty(exports, "getProps", { enumerable: true, get: function () { return Props_1.getProps; } });
Object.defineProperty(exports, "setProps", { enumerable: true, get: function () { return Props_1.setProps; } });
const constants_1 = require("./constants");
const { odp } = constants_1.constants;
const errorsApi = require("./api/errors");
const descriptors_1 = require("./descriptors");
const Mnemosyne_1 = require("./api/types/Mnemosyne");
const { prepareSubtypeForConstruction } = Mnemosyne_1.default;
exports.defaultTypes = descriptors_1.descriptors.defaultTypes;
function checkThis(pointer) {
    return pointer === exports.mnemonica || pointer === exports;
}
const define = function (TypeName, constructHandler, config) {
    const types = checkThis(this) ? exports.defaultTypes : this || exports.defaultTypes;
    return types.define(TypeName, constructHandler, config);
};
exports.define = define;
exports.lookup = function (TypeNestedPath) {
    const types = checkThis(this) ? exports.defaultTypes : this || exports.defaultTypes;
    return types.lookup(TypeNestedPath);
};
const $run = function (entity, Constructor, args) {
    const { TypeName } = Constructor;
    const Cstr = prepareSubtypeForConstruction(TypeName, entity);
    const result = new Cstr(...args);
    return result;
};
const apply = function (entity, Constructor, args = []) {
    return $run(entity, Constructor, args);
};
exports.apply = apply;
const call = function (entity, Constructor, ...args) {
    return $run(entity, Constructor, args);
};
exports.call = call;
const bind = function (entity, Constructor) {
    return (...args) => {
        return $run(entity, Constructor, args);
    };
};
exports.bind = bind;
const decorate = function (parentClass = {}, config) {
    if (typeof parentClass === 'object' && !(parentClass instanceof Function)) {
        config = parentClass;
        parentClass = undefined;
    }
    const decorator = function (cstr, s) {
        if (parentClass === undefined) {
            return (0, exports.define)(s.name, cstr, config);
        }
        return parentClass.define(s.name, cstr, config);
    };
    return decorator;
};
exports.decorate = decorate;
const registerHook = function (Constructor, hookType, cb) {
    Constructor.registerHook(hookType, cb);
};
exports.registerHook = registerHook;
exports.mnemonica = Object.entries(Object.assign(Object.assign(Object.assign({ define: exports.define,
    lookup: exports.lookup,
    apply: exports.apply,
    call: exports.call,
    bind: exports.bind,
    decorate: exports.decorate,
    registerHook: exports.registerHook }, descriptors_1.descriptors), errorsApi), constants_1.constants)).reduce((acc, entry) => {
    const [name, code] = entry;
    odp(acc, name, {
        get() {
            return code;
        },
        enumerable: true
    });
    return acc;
}, {});
exports.SymbolParentType = exports.mnemonica.SymbolParentType, exports.SymbolConstructorName = exports.mnemonica.SymbolConstructorName, exports.SymbolDefaultTypesCollection = exports.mnemonica.SymbolDefaultTypesCollection, exports.SymbolConfig = exports.mnemonica.SymbolConfig, exports.MNEMONICA = exports.mnemonica.MNEMONICA, exports.MNEMOSYNE = exports.mnemonica.MNEMOSYNE, exports.TYPE_TITLE_PREFIX = exports.mnemonica.TYPE_TITLE_PREFIX, exports.ErrorMessages = exports.mnemonica.ErrorMessages, exports.createTypesCollection = exports.mnemonica.createTypesCollection;
exports.defaultCollection = exports.defaultTypes.subtypes;
exports.errors = descriptors_1.descriptors.ErrorsTypes;
var utils_1 = require("./utils");
Object.defineProperty(exports, "utils", { enumerable: true, get: function () { return utils_1.utils; } });
var utils_2 = require("./utils");
Object.defineProperty(exports, "defineStackCleaner", { enumerable: true, get: function () { return utils_2.defineStackCleaner; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsWUFBWSxDQUFDOzs7QUFhYiwyQ0FBdUQ7QUFBOUMsaUdBQUEsUUFBUSxPQUFBO0FBQUUsaUdBQUEsUUFBUSxPQUFBO0FBRTNCLDJDQUF3QztBQUN4QyxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcscUJBQVMsQ0FBQztBQUUxQiwwQ0FBMEM7QUFDMUMsK0NBQTRDO0FBRTVDLHFEQUErQztBQUMvQyxNQUFNLEVBQUUsNkJBQTZCLEVBQUUsR0FBRyxtQkFBVSxDQUFDO0FBR3BELG9CQUFZLEdBQ1QseUJBQVcsY0FBQztBQUVoQixTQUFTLFNBQVMsQ0FBQyxPQUFvRDtJQUN0RSxPQUFPLE9BQU8sS0FBSyxpQkFBUyxJQUFJLE9BQU8sS0FBSyxPQUFPLENBQUM7QUFDckQsQ0FBQztBQUVNLE1BQU0sTUFBTSxHQUFHLFVBYXJCLFFBQWlCLEVBQ2pCLGdCQUEwQixFQUMxQixNQUEyQjtJQUUzQixNQUFNLEtBQUssR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLG9CQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxvQkFBWSxDQUFDO0lBQ3BFLE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDekQsQ0FBQyxDQUFDO0FBbkJXLFFBQUEsTUFBTSxVQW1CakI7QUFFVyxRQUFBLE1BQU0sR0FBRyxVQUFVLGNBQWM7SUFDN0MsTUFBTSxLQUFLLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxvQkFBWSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksb0JBQVksQ0FBQztJQUNwRSxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDckMsQ0FBZSxDQUFDO0FBR2hCLE1BQU0sSUFBSSxHQUFH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QUFDWixDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFJTix3QkFBZ0IsR0FVYixpQkFBUyxtQkFUWiw2QkFBcUIsR0FTbEIsaUJBQVMsd0JBUlosb0NBQTRCLEdBUXpCLGlCQUFTLCtCQVBaLG9CQUFZLEdBT1QsaUJBQVMsZUFOWixpQkFBUyxHQU1OLGlCQUFTLFlBTFosaUJBQVMsR0FLTixpQkFBUyxZQUpaLHlCQUFpQixHQUlkLGlCQUFTLG9CQUhaLHFCQUFhLEdBR1YsaUJBQVMsZ0JBRlosNkJBQXFCLEdBRWxCLGlCQUFTLHVCQUFDO0FBR0QsUUFBQSxpQkFBaUIsR0FBRyxvQkFBWSxDQUFDLFFBQVEsQ0FBQztBQUMxQyxRQUFBLE1BQU0sR0FBRyx5QkFBVyxDQUFDLFdBQVcsQ0FBQztBQUU5QyxpQ0FBZ0M7QUFBdkIsOEZBQUEsS0FBSyxPQUFBO0FBQ2QsaUNBQTZDO0FBQXBDLDJHQUFBLGtCQUFrQixPQUFBIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50LCBpbmRlbnQsIG5ldy1jYXAsIHNwYWNlLWJlZm9yZS1mdW5jdGlvbi1wYXJlbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1xuXHRUeXBlTG9va3VwLFxuXHRJREVGLFxuXHRob29rLFxuXHRob29rc1R5cGVzLFxuXHRjb25zdHJ1Y3Rvck9wdGlvbnMsXG5cdFByb3RvLFxuXHRTTixcblx0SURlZmluaXRvckluc3RhbmNlXG59IGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IHR5cGUgeyBJREVGLCBDb25zdHJ1Y3RvckZ1bmN0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgeyBnZXRQcm9wcywgc2V0UHJvcHMgfSBmcm9tICcuL2FwaS90eXBlcy9Qcm9wcyc7XG5cbmltcG9ydCB7IGNvbnN0YW50cyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmNvbnN0IHsgb2RwIH0gPSBjb25zdGFudHM7XG5cbmltcG9ydCAqIGFzIGVycm9yc0FwaSBmcm9tICcuL2FwaS9lcnJvcnMnO1xuaW1wb3J0IHsgZGVzY3JpcHRvcnMgfSBmcm9tICcuL2Rlc2NyaXB0b3JzJztcblxuaW1wb3J0IG1uZW1vc3luZXMgZnJvbSAnLi9hcGkvdHlwZXMvTW5lbW9zeW5lJztcbmNvbnN0IHsgcHJlcGFyZVN1YnR5cGVGb3JDb25zdHJ1Y3Rpb24gfSA9IG1uZW1vc3luZXM7XG5cbmV4cG9ydCBjb25zdCB7XG5cdGRlZmF1bHRUeXBlcyxcbn0gPSBkZXNjcmlwdG9ycztcblxuZnVuY3Rpb24gY2hlY2tUaGlzKHBvaW50ZXI6IHR5cGVvZiBtbmVtb25pY2EgfCB0eXBlb2YgZXhwb3J0cyB8IHVua25vd24pOiBib29sZWFuIHtcblx0cmV0dXJuIHBvaW50ZXIgPT09IG1uZW1vbmljYSB8fCBwb2ludGVyID09PSBleHBvcnRzO1xufVxuXG5leHBvcnQgY29uc3QgZGVmaW5lID0gZnVuY3Rpb24gPFxuXHRULFxuXHQvLyBLIGV4dGVuZHMgSURFRjxUPixcblx0Ly8gSCBleHRlbmRzIFRoaXNUeXBlPElERUY8VD4+LFxuXHRQIGV4dGVuZHMgb2JqZWN0LFxuXHROIGV4dGVuZHMgUHJvdG88UCwgVD4sXG5cdC8vIHNvIFMgaXQganVzdCBiYXNpY2FsbHkgYWxsb3dzIG5lc3RlZCBjb25zdHJ1Y3RvcnNcblx0Ly8gYW5kIGdpdmVzIGV4dHJhY3RlZCBwcm9wcyBmcm9tIGNvbnN0cnVjdEhhbmRsZXIgJiBwcm90b1xuXHQvLyB0aGVuIGl0IGdvZXMgdG8gbmV3KCkga2V5d29yZCBvZiBkZWZpbmUgb3V0cHV0XG5cdFMgZXh0ZW5kcyBTTiAmIE4sXG5cdFIgZXh0ZW5kcyBJRGVmaW5pdG9ySW5zdGFuY2U8TiwgUz5cbj4oXG5cdHRoaXM6IHVua25vd24sXG5cdFR5cGVOYW1lPzogc3RyaW5nLFxuXHRjb25zdHJ1Y3RIYW5kbGVyPzogSURFRjxUPixcblx0Y29uZmlnPzogY29uc3RydWN0b3JPcHRpb25zLFxuKTogUiB7XG5cdGNvbnN0IHR5cGVzID0gY2hlY2tUaGlzKHRoaXMpID8gZGVmYXVsdFR5cGVzIDogdGhpcyB8fCBkZWZhdWx0VHlwZXM7XG5cdHJldHVybiB0eXBlcy5kZWZpbmUoVHlwZU5hbWUsIGNvbnN0cnVjdEhhbmRsZXIsIGNvbmZpZyk7XG59O1xuXG5leHBvcnQgY29uc3QgbG9va3VwID0gZnVuY3Rpb24gKFR5cGVOZXN0ZWRQYXRoKSB7XG5cdGNvbnN0IHR5cGVzID0gY2hlY2tUaGlzKHRoaXMpID8gZGVmYXVsdFR5cGVzIDogdGhpcyB8fCBkZWZhdWx0VHlwZXM7XG5cdHJldHVybiB0eXBlcy5sb29rdXAoVHlwZU5lc3RlZFBhdGgpO1xufSBhcyBUeXBlTG9va3VwO1xuXG5cbmNvbnN0ICRydW4gPSBmdW5jdGlvbiA8RSBleHRlbmRzIG9iamVjdCwgVCBleHRlbmRzIG9iamVjdCwgUyBleHRlbmRzIFByb3RvPEUsIFQ+Pihcblx0ZW50aXR5OiBFLFxuXHRDb25zdHJ1Y3RvcjogSURFRjxUPixcblx0YXJnczogdW5rbm93bltdXG4pOiB7XG5cdFx0W2tleSBpbiBrZXlvZiBTXTogU1trZXldXG5cdH0ge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZGVidWdnZXJcblx0Ly8gZGVidWdnZXI7XG5cdC8vIEB0cy1pZ25vcmVcblx0Y29uc3QgeyBUeXBlTmFtZSB9ID0gQ29uc3RydWN0b3I7XG5cdGNvbnN0IENzdHIgPSBwcmVwYXJlU3VidHlwZUZvckNvbnN0cnVjdGlvbihUeXBlTmFtZSwgZW50aXR5KSBhcyB7IG5ldyggLi4uYXJzOiB1bmtub3duW10pOiB1bmtub3dufTtcblx0Ly8gVE9ETzogY2hlY2sgbGluZXMgYmVsb3cgYW5kIGlmIENvbnN0cnVjdG9yIGlzIG5vdCBtbmVtb25pemVkIC4uLlxuXHQvLyBpZiAoQ3N0ciA9PT0gdW5kZWZpbmVkKSB7XG5cdC8vIFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgVHlwZSAke1R5cGVOYW1lfSBpcyBub3QgZGVmaW5lZCBhcyBhIC5gKTtcblx0Ly8gfVxuXHRjb25zdCByZXN1bHQgPSBuZXcgQ3N0ciguLi5hcmdzKTtcblx0Ly8gQHRzLWlnbm9yZVxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gVE9ETzogYXBwbHkgaW5zdGFuY2UgLnRvIHR5cGUgLndpdGggYXJndW1lbnRzXG5leHBvcnQgY29uc3QgYXBwbHkgPSBmdW5jdGlvbiA8RSBleHRlbmRzIG9iamVjdCwgVCBleHRlbmRzIG9iamVjdCwgUyBleHRlbmRzIFByb3RvPEUsIFQ+Pihcblx0ZW50aXR5OiBFLFxuXHRDb25zdHJ1Y3RvcjogSURFRjxUPixcblx0YXJnczogdW5rbm93bltdID0gW11cbik6IHtcblx0XHRba2V5IGluIGtleW9mIFNdOiBTW2tleV1cblx0fSB7XG5cdHJldHVybiAkcnVuPEUsIFQsIFM+KGVudGl0eSwgQ29uc3RydWN0b3IsIGFyZ3MpO1xufTtcblxuLy8gVE9ETzogY2FsbCB0eXBlIC5ieSBpbnN0YW5jZSAud2l0aCBhcmd1bWVudHNcbmV4cG9ydCBjb25zdCBjYWxsID0gZnVuY3Rpb24gPEUgZXh0ZW5kcyBvYmplY3QsIFQgZXh0ZW5kcyBvYmplY3QsIFMgZXh0ZW5kcyBQcm90bzxFLCBUPj4oXG5cdGVudGl0eTogRSxcblx0Q29uc3RydWN0b3I6IElERUY8VD4sXG5cdC4uLmFyZ3M6IHVua25vd25bXVxuKToge1xuXHRcdFtrZXkgaW4ga2V5b2YgU106IFNba2V5XVxuXHR9IHtcblx0cmV0dXJuICRydW48RSwgVCwgUz4oZW50aXR5LCBDb25zdHJ1Y3RvciwgYXJncyk7XG59O1xuXG4vLyBUT0RPOiBiaW5kIHR5cGUgLndpdGggaW5zdGFuY2Ug4oaSICguLi5hcmdzKVxuZXhwb3J0IGNvbnN0IGJpbmQgPSBmdW5jdGlvbiA8RSBleHRlbmRzIG9iamVjdCwgVCBleHRlbmRzIG9iamVjdCwgUyBleHRlbmRzIFByb3RvPEUsIFQ+Pihcblx0ZW50aXR5OiBFLFxuXHRDb25zdHJ1Y3RvcjogSURFRjxUPlxuKTogKC4uLmFyZ3M6IHVua25vd25bXSkgPT4ge1xuXHRba2V5IGluIGtleW9mIFNdOiBTW2tleV1cbn0ge1xuXHRyZXR1cm4gKC4uLmFyZ3MpID0+IHtcblx0XHRyZXR1cm4gJHJ1bjxFLCBULCBTPihlbnRpdHksIENvbnN0cnVjdG9yLCBhcmdzKTtcblx0fTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWNvcmF0ZSA9IGZ1bmN0aW9uIChcblx0cGFyZW50Q2xhc3M6IHsgbmV3KCk6IHVua25vd24gfSB8IGNvbnN0cnVjdG9yT3B0aW9ucyB8IHVuZGVmaW5lZCA9IHt9LFxuXHRjb25maWc/OiBjb25zdHJ1Y3Rvck9wdGlvbnNcbikge1xuXHRpZiAodHlwZW9mIHBhcmVudENsYXNzID09PSAnb2JqZWN0JyAmJiAhKHBhcmVudENsYXNzIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG5cdFx0Y29uZmlnID0gcGFyZW50Q2xhc3MgYXMgY29uc3RydWN0b3JPcHRpb25zO1xuXHRcdHBhcmVudENsYXNzID0gdW5kZWZpbmVkO1xuXHR9XG5cdGNvbnN0IGRlY29yYXRvciA9IGZ1bmN0aW9uIDxUIGV4dGVuZHMgeyBuZXcoKTogdW5rbm93biB9Pihjc3RyOiBULCBzOiBDbGFzc0RlY29yYXRvckNvbnRleHQ8VD4pOiBUIHtcblx0XHRpZiAocGFyZW50Q2xhc3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGRlZmluZShzLm5hbWUsIGNzdHIsIGNvbmZpZykgYXMgdW5rbm93biBhcyBUO1xuXHRcdH1cblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIHBhcmVudENsYXNzLmRlZmluZShzLm5hbWUsIGNzdHIsIGNvbmZpZykgYXMgdW5rbm93biBhcyBUO1xuXHR9O1xuXHRyZXR1cm4gZGVjb3JhdG9yO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVySG9vayA9IGZ1bmN0aW9uIDxUIGV4dGVuZHMgb2JqZWN0PihDb25zdHJ1Y3RvcjogSURFRjxUPiwgaG9va1R5cGU6IGhvb2tzVHlwZXMsIGNiOiBob29rKTogdm9pZCB7XG5cdC8vIEB0cy1pZ25vcmVcblx0Q29uc3RydWN0b3IucmVnaXN0ZXJIb29rKGhvb2tUeXBlLCBjYik7XG59O1xuXG5leHBvcnQgY29uc3QgbW5lbW9uaWNhID0gT2JqZWN0LmVudHJpZXMoe1xuXG5cdGRlZmluZSxcblx0bG9va3VwLFxuXHRhcHBseSxcblx0Y2FsbCxcblx0YmluZCxcblx0ZGVjb3JhdGUsXG5cdHJlZ2lzdGVySG9vayxcblxuXHQuLi5kZXNjcmlwdG9ycyxcblxuXHQuLi5lcnJvcnNBcGksXG5cdC4uLmNvbnN0YW50cyxcblxufSkucmVkdWNlKChhY2M6IHsgW2luZGV4OiBzdHJpbmddOiB1bmtub3duIH0sIGVudHJ5OiBbc3RyaW5nLCB1bmtub3duXSkgPT4ge1xuXHRjb25zdCBbIG5hbWUsIGNvZGUgXSA9IGVudHJ5O1xuXHRvZHAoYWNjLCBuYW1lLCB7XG5cdFx0Z2V0KCkge1xuXHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0fSxcblx0XHRlbnVtZXJhYmxlIDogdHJ1ZVxuXHR9KTtcblx0cmV0dXJuIGFjYztcbn0sIHt9KTtcblxuZXhwb3J0IGNvbnN0IHtcblxuXHRTeW1ib2xQYXJlbnRUeXBlLFxuXHRTeW1ib2xDb25zdHJ1Y3Rvck5hbWUsXG5cdFN5bWJvbERlZmF1bHRUeXBlc0NvbGxlY3Rpb24sXG5cdFN5bWJvbENvbmZpZyxcblx0TU5FTU9OSUNBLFxuXHRNTkVNT1NZTkUsXG5cdFRZUEVfVElUTEVfUFJFRklYLFxuXHRFcnJvck1lc3NhZ2VzLFxuXHRjcmVhdGVUeXBlc0NvbGxlY3Rpb24sXG5cbn0gPSBtbmVtb25pY2E7XG5cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRDb2xsZWN0aW9uID0gZGVmYXVsdFR5cGVzLnN1YnR5cGVzO1xuZXhwb3J0IGNvbnN0IGVycm9ycyA9IGRlc2NyaXB0b3JzLkVycm9yc1R5cGVzO1xuXG5leHBvcnQgeyB1dGlscyB9IGZyb20gJy4vdXRpbHMnO1xuZXhwb3J0IHsgZGVmaW5lU3RhY2tDbGVhbmVyIH0gZnJvbSAnLi91dGlscyc7XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCwgaW5kZW50LCBuZXctY2FwLCBzcGFjZS1iZWZvcmUtZnVuY3Rpb24tcGFyZW4gKi9cbiJdfQ==